
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserCompany
 * 
 */
export type UserCompany = $Result.DefaultSelection<Prisma.$UserCompanyPayload>
/**
 * Model Person
 * 
 */
export type Person = $Result.DefaultSelection<Prisma.$PersonPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Equipment
 * 
 */
export type Equipment = $Result.DefaultSelection<Prisma.$EquipmentPayload>
/**
 * Model Maintenance
 * 
 */
export type Maintenance = $Result.DefaultSelection<Prisma.$MaintenancePayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model License
 * 
 */
export type License = $Result.DefaultSelection<Prisma.$LicensePayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model NetworkProvider
 * 
 */
export type NetworkProvider = $Result.DefaultSelection<Prisma.$NetworkProviderPayload>
/**
 * Model Network
 * 
 */
export type Network = $Result.DefaultSelection<Prisma.$NetworkPayload>
/**
 * Model AnnualSoftwareExpense
 * 
 */
export type AnnualSoftwareExpense = $Result.DefaultSelection<Prisma.$AnnualSoftwareExpensePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  MODERATOR: 'MODERATOR',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const PersonStatus: {
  Activo: 'Activo',
  Inactivo: 'Inactivo'
};

export type PersonStatus = (typeof PersonStatus)[keyof typeof PersonStatus]


export const TicketType: {
  vacations: 'vacations',
  permission: 'permission',
  ticket: 'ticket'
};

export type TicketType = (typeof TicketType)[keyof typeof TicketType]


export const TicketPriority: {
  urgent: 'urgent',
  high: 'high',
  medium: 'medium',
  low: 'low',
  trivial: 'trivial'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const TicketStatus: {
  open: 'open',
  pending: 'pending',
  approved: 'approved',
  rejected: 'rejected',
  closed: 'closed'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const EquipmentStatus: {
  ACTIVE: 'ACTIVE',
  IN_MAINTENANCE: 'IN_MAINTENANCE',
  DISPOSED: 'DISPOSED',
  DAMAGED: 'DAMAGED',
  ASSIGNED: 'ASSIGNED',
  STORAGE: 'STORAGE'
};

export type EquipmentStatus = (typeof EquipmentStatus)[keyof typeof EquipmentStatus]


export const MaintenanceType: {
  PREVENTIVE: 'PREVENTIVE',
  CORRECTIVE: 'CORRECTIVE'
};

export type MaintenanceType = (typeof MaintenanceType)[keyof typeof MaintenanceType]


export const MaintenanceStatus: {
  SCHEDULED: 'SCHEDULED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELED: 'CANCELED'
};

export type MaintenanceStatus = (typeof MaintenanceStatus)[keyof typeof MaintenanceStatus]


export const NetworkDeviceType: {
  ROUTER: 'ROUTER',
  SWITCH: 'SWITCH',
  FIREWALL: 'FIREWALL',
  ACCESS_POINT: 'ACCESS_POINT',
  SERVER: 'SERVER',
  PRINTER: 'PRINTER',
  IP_PHONE: 'IP_PHONE',
  CAMERA: 'CAMERA',
  OTHER: 'OTHER'
};

export type NetworkDeviceType = (typeof NetworkDeviceType)[keyof typeof NetworkDeviceType]


export const NetworkDeviceStatus: {
  ONLINE: 'ONLINE',
  OFFLINE: 'OFFLINE',
  MAINTENANCE: 'MAINTENANCE',
  DECOMMISSIONED: 'DECOMMISSIONED',
  UNKNOWN: 'UNKNOWN'
};

export type NetworkDeviceStatus = (typeof NetworkDeviceStatus)[keyof typeof NetworkDeviceStatus]


export const ExpenseStatus: {
  Active: 'Active',
  Inactive: 'Inactive',
  Pending: 'Pending',
  Canceled: 'Canceled',
  Expired: 'Expired'
};

export type ExpenseStatus = (typeof ExpenseStatus)[keyof typeof ExpenseStatus]


export const PaymentFrequency: {
  Annual: 'Annual',
  Monthly: 'Monthly',
  Quarterly: 'Quarterly',
  SemiAnnual: 'SemiAnnual',
  OneTime: 'OneTime'
};

export type PaymentFrequency = (typeof PaymentFrequency)[keyof typeof PaymentFrequency]


export const SoftwareCategory: {
  Accounting: 'Accounting',
  CRM: 'CRM',
  Antivirus: 'Antivirus',
  Productivity: 'Productivity',
  Design: 'Design',
  Development: 'Development',
  HRManagement: 'HRManagement',
  Marketing: 'Marketing',
  Communication: 'Communication',
  CloudStorage: 'CloudStorage',
  OperatingSystem: 'OperatingSystem',
  Other: 'Other'
};

export type SoftwareCategory = (typeof SoftwareCategory)[keyof typeof SoftwareCategory]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type PersonStatus = $Enums.PersonStatus

export const PersonStatus: typeof $Enums.PersonStatus

export type TicketType = $Enums.TicketType

export const TicketType: typeof $Enums.TicketType

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type EquipmentStatus = $Enums.EquipmentStatus

export const EquipmentStatus: typeof $Enums.EquipmentStatus

export type MaintenanceType = $Enums.MaintenanceType

export const MaintenanceType: typeof $Enums.MaintenanceType

export type MaintenanceStatus = $Enums.MaintenanceStatus

export const MaintenanceStatus: typeof $Enums.MaintenanceStatus

export type NetworkDeviceType = $Enums.NetworkDeviceType

export const NetworkDeviceType: typeof $Enums.NetworkDeviceType

export type NetworkDeviceStatus = $Enums.NetworkDeviceStatus

export const NetworkDeviceStatus: typeof $Enums.NetworkDeviceStatus

export type ExpenseStatus = $Enums.ExpenseStatus

export const ExpenseStatus: typeof $Enums.ExpenseStatus

export type PaymentFrequency = $Enums.PaymentFrequency

export const PaymentFrequency: typeof $Enums.PaymentFrequency

export type SoftwareCategory = $Enums.SoftwareCategory

export const SoftwareCategory: typeof $Enums.SoftwareCategory

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tickets
 * const tickets = await prisma.ticket.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tickets
   * const tickets = await prisma.ticket.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userCompany`: Exposes CRUD operations for the **UserCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserCompanies
    * const userCompanies = await prisma.userCompany.findMany()
    * ```
    */
  get userCompany(): Prisma.UserCompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.person`: Exposes CRUD operations for the **Person** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more People
    * const people = await prisma.person.findMany()
    * ```
    */
  get person(): Prisma.PersonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.equipment`: Exposes CRUD operations for the **Equipment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Equipment
    * const equipment = await prisma.equipment.findMany()
    * ```
    */
  get equipment(): Prisma.EquipmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenance`: Exposes CRUD operations for the **Maintenance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Maintenances
    * const maintenances = await prisma.maintenance.findMany()
    * ```
    */
  get maintenance(): Prisma.MaintenanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.license`: Exposes CRUD operations for the **License** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Licenses
    * const licenses = await prisma.license.findMany()
    * ```
    */
  get license(): Prisma.LicenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.networkProvider`: Exposes CRUD operations for the **NetworkProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NetworkProviders
    * const networkProviders = await prisma.networkProvider.findMany()
    * ```
    */
  get networkProvider(): Prisma.NetworkProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.network`: Exposes CRUD operations for the **Network** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Networks
    * const networks = await prisma.network.findMany()
    * ```
    */
  get network(): Prisma.NetworkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.annualSoftwareExpense`: Exposes CRUD operations for the **AnnualSoftwareExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnnualSoftwareExpenses
    * const annualSoftwareExpenses = await prisma.annualSoftwareExpense.findMany()
    * ```
    */
  get annualSoftwareExpense(): Prisma.AnnualSoftwareExpenseDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Ticket: 'Ticket',
    User: 'User',
    UserCompany: 'UserCompany',
    Person: 'Person',
    Company: 'Company',
    Department: 'Department',
    Equipment: 'Equipment',
    Maintenance: 'Maintenance',
    Document: 'Document',
    License: 'License',
    SystemConfig: 'SystemConfig',
    NetworkProvider: 'NetworkProvider',
    Network: 'Network',
    AnnualSoftwareExpense: 'AnnualSoftwareExpense'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "ticket" | "user" | "userCompany" | "person" | "company" | "department" | "equipment" | "maintenance" | "document" | "license" | "systemConfig" | "networkProvider" | "network" | "annualSoftwareExpense"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserCompany: {
        payload: Prisma.$UserCompanyPayload<ExtArgs>
        fields: Prisma.UserCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          findFirst: {
            args: Prisma.UserCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          findMany: {
            args: Prisma.UserCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>[]
          }
          create: {
            args: Prisma.UserCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          createMany: {
            args: Prisma.UserCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>[]
          }
          delete: {
            args: Prisma.UserCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          update: {
            args: Prisma.UserCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          deleteMany: {
            args: Prisma.UserCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserCompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>[]
          }
          upsert: {
            args: Prisma.UserCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserCompanyPayload>
          }
          aggregate: {
            args: Prisma.UserCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserCompany>
          }
          groupBy: {
            args: Prisma.UserCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<UserCompanyCountAggregateOutputType> | number
          }
        }
      }
      Person: {
        payload: Prisma.$PersonPayload<ExtArgs>
        fields: Prisma.PersonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findFirst: {
            args: Prisma.PersonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          findMany: {
            args: Prisma.PersonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          create: {
            args: Prisma.PersonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          createMany: {
            args: Prisma.PersonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          delete: {
            args: Prisma.PersonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          update: {
            args: Prisma.PersonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          deleteMany: {
            args: Prisma.PersonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>[]
          }
          upsert: {
            args: Prisma.PersonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonPayload>
          }
          aggregate: {
            args: Prisma.PersonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerson>
          }
          groupBy: {
            args: Prisma.PersonGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonCountArgs<ExtArgs>
            result: $Utils.Optional<PersonCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Equipment: {
        payload: Prisma.$EquipmentPayload<ExtArgs>
        fields: Prisma.EquipmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EquipmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EquipmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findFirst: {
            args: Prisma.EquipmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EquipmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          findMany: {
            args: Prisma.EquipmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          create: {
            args: Prisma.EquipmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          createMany: {
            args: Prisma.EquipmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EquipmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          delete: {
            args: Prisma.EquipmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          update: {
            args: Prisma.EquipmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          deleteMany: {
            args: Prisma.EquipmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EquipmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EquipmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>[]
          }
          upsert: {
            args: Prisma.EquipmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EquipmentPayload>
          }
          aggregate: {
            args: Prisma.EquipmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEquipment>
          }
          groupBy: {
            args: Prisma.EquipmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EquipmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EquipmentCountArgs<ExtArgs>
            result: $Utils.Optional<EquipmentCountAggregateOutputType> | number
          }
        }
      }
      Maintenance: {
        payload: Prisma.$MaintenancePayload<ExtArgs>
        fields: Prisma.MaintenanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findFirst: {
            args: Prisma.MaintenanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          findMany: {
            args: Prisma.MaintenanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          create: {
            args: Prisma.MaintenanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          createMany: {
            args: Prisma.MaintenanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          delete: {
            args: Prisma.MaintenanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          update: {
            args: Prisma.MaintenanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenancePayload>
          }
          aggregate: {
            args: Prisma.MaintenanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenance>
          }
          groupBy: {
            args: Prisma.MaintenanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      License: {
        payload: Prisma.$LicensePayload<ExtArgs>
        fields: Prisma.LicenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LicenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LicenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findFirst: {
            args: Prisma.LicenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LicenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          findMany: {
            args: Prisma.LicenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          create: {
            args: Prisma.LicenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          createMany: {
            args: Prisma.LicenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LicenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          delete: {
            args: Prisma.LicenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          update: {
            args: Prisma.LicenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          deleteMany: {
            args: Prisma.LicenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LicenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LicenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>[]
          }
          upsert: {
            args: Prisma.LicenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LicensePayload>
          }
          aggregate: {
            args: Prisma.LicenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLicense>
          }
          groupBy: {
            args: Prisma.LicenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<LicenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.LicenseCountArgs<ExtArgs>
            result: $Utils.Optional<LicenseCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      NetworkProvider: {
        payload: Prisma.$NetworkProviderPayload<ExtArgs>
        fields: Prisma.NetworkProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload>
          }
          findFirst: {
            args: Prisma.NetworkProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload>
          }
          findMany: {
            args: Prisma.NetworkProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload>[]
          }
          create: {
            args: Prisma.NetworkProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload>
          }
          createMany: {
            args: Prisma.NetworkProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NetworkProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload>[]
          }
          delete: {
            args: Prisma.NetworkProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload>
          }
          update: {
            args: Prisma.NetworkProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload>
          }
          deleteMany: {
            args: Prisma.NetworkProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NetworkProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload>[]
          }
          upsert: {
            args: Prisma.NetworkProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkProviderPayload>
          }
          aggregate: {
            args: Prisma.NetworkProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNetworkProvider>
          }
          groupBy: {
            args: Prisma.NetworkProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<NetworkProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkProviderCountArgs<ExtArgs>
            result: $Utils.Optional<NetworkProviderCountAggregateOutputType> | number
          }
        }
      }
      Network: {
        payload: Prisma.$NetworkPayload<ExtArgs>
        fields: Prisma.NetworkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NetworkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NetworkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          findFirst: {
            args: Prisma.NetworkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NetworkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          findMany: {
            args: Prisma.NetworkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>[]
          }
          create: {
            args: Prisma.NetworkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          createMany: {
            args: Prisma.NetworkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NetworkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>[]
          }
          delete: {
            args: Prisma.NetworkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          update: {
            args: Prisma.NetworkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          deleteMany: {
            args: Prisma.NetworkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NetworkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NetworkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>[]
          }
          upsert: {
            args: Prisma.NetworkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NetworkPayload>
          }
          aggregate: {
            args: Prisma.NetworkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNetwork>
          }
          groupBy: {
            args: Prisma.NetworkGroupByArgs<ExtArgs>
            result: $Utils.Optional<NetworkGroupByOutputType>[]
          }
          count: {
            args: Prisma.NetworkCountArgs<ExtArgs>
            result: $Utils.Optional<NetworkCountAggregateOutputType> | number
          }
        }
      }
      AnnualSoftwareExpense: {
        payload: Prisma.$AnnualSoftwareExpensePayload<ExtArgs>
        fields: Prisma.AnnualSoftwareExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnnualSoftwareExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnnualSoftwareExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload>
          }
          findFirst: {
            args: Prisma.AnnualSoftwareExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnnualSoftwareExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload>
          }
          findMany: {
            args: Prisma.AnnualSoftwareExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload>[]
          }
          create: {
            args: Prisma.AnnualSoftwareExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload>
          }
          createMany: {
            args: Prisma.AnnualSoftwareExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnnualSoftwareExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload>[]
          }
          delete: {
            args: Prisma.AnnualSoftwareExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload>
          }
          update: {
            args: Prisma.AnnualSoftwareExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload>
          }
          deleteMany: {
            args: Prisma.AnnualSoftwareExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnnualSoftwareExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AnnualSoftwareExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload>[]
          }
          upsert: {
            args: Prisma.AnnualSoftwareExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnnualSoftwareExpensePayload>
          }
          aggregate: {
            args: Prisma.AnnualSoftwareExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnnualSoftwareExpense>
          }
          groupBy: {
            args: Prisma.AnnualSoftwareExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnnualSoftwareExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnnualSoftwareExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<AnnualSoftwareExpenseCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    ticket?: TicketOmit
    user?: UserOmit
    userCompany?: UserCompanyOmit
    person?: PersonOmit
    company?: CompanyOmit
    department?: DepartmentOmit
    equipment?: EquipmentOmit
    maintenance?: MaintenanceOmit
    document?: DocumentOmit
    license?: LicenseOmit
    systemConfig?: SystemConfigOmit
    networkProvider?: NetworkProviderOmit
    network?: NetworkOmit
    annualSoftwareExpense?: AnnualSoftwareExpenseOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    companies: number
    createdCompanies: number
    assignedEquipments: number
    assignedMaintenances: number
    assignedNetworks: number
    createdNetworks: number
    ticketsSentBy: number
    ticketsSentTo: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | UserCountOutputTypeCountCompaniesArgs
    createdCompanies?: boolean | UserCountOutputTypeCountCreatedCompaniesArgs
    assignedEquipments?: boolean | UserCountOutputTypeCountAssignedEquipmentsArgs
    assignedMaintenances?: boolean | UserCountOutputTypeCountAssignedMaintenancesArgs
    assignedNetworks?: boolean | UserCountOutputTypeCountAssignedNetworksArgs
    createdNetworks?: boolean | UserCountOutputTypeCountCreatedNetworksArgs
    ticketsSentBy?: boolean | UserCountOutputTypeCountTicketsSentByArgs
    ticketsSentTo?: boolean | UserCountOutputTypeCountTicketsSentToArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCompanyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedEquipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAssignedNetworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedNetworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsSentByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsSentToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }


  /**
   * Count Type PersonCountOutputType
   */

  export type PersonCountOutputType = {
    assignedExpenses: number
  }

  export type PersonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedExpenses?: boolean | PersonCountOutputTypeCountAssignedExpensesArgs
  }

  // Custom InputTypes
  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonCountOutputType
     */
    select?: PersonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonCountOutputType without action
   */
  export type PersonCountOutputTypeCountAssignedExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnualSoftwareExpenseWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    departments: number
    documents: number
    equipments: number
    licenses: number
    maintenances: number
    networks: number
    networkProviders: number
    tickets: number
    users: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    departments?: boolean | CompanyCountOutputTypeCountDepartmentsArgs
    documents?: boolean | CompanyCountOutputTypeCountDocumentsArgs
    equipments?: boolean | CompanyCountOutputTypeCountEquipmentsArgs
    licenses?: boolean | CompanyCountOutputTypeCountLicensesArgs
    maintenances?: boolean | CompanyCountOutputTypeCountMaintenancesArgs
    networks?: boolean | CompanyCountOutputTypeCountNetworksArgs
    networkProviders?: boolean | CompanyCountOutputTypeCountNetworkProvidersArgs
    tickets?: boolean | CompanyCountOutputTypeCountTicketsArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountEquipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountLicensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountNetworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountNetworkProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkProviderWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCompanyWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    persons: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    persons?: boolean | DepartmentCountOutputTypeCountPersonsArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountPersonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
  }


  /**
   * Count Type EquipmentCountOutputType
   */

  export type EquipmentCountOutputType = {
    documents: number
    maintenances: number
  }

  export type EquipmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | EquipmentCountOutputTypeCountDocumentsArgs
    maintenances?: boolean | EquipmentCountOutputTypeCountMaintenancesArgs
  }

  // Custom InputTypes
  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EquipmentCountOutputType
     */
    select?: EquipmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * EquipmentCountOutputType without action
   */
  export type EquipmentCountOutputTypeCountMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
  }


  /**
   * Count Type NetworkProviderCountOutputType
   */

  export type NetworkProviderCountOutputType = {
    networks: number
  }

  export type NetworkProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    networks?: boolean | NetworkProviderCountOutputTypeCountNetworksArgs
  }

  // Custom InputTypes
  /**
   * NetworkProviderCountOutputType without action
   */
  export type NetworkProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProviderCountOutputType
     */
    select?: NetworkProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NetworkProviderCountOutputType without action
   */
  export type NetworkProviderCountOutputTypeCountNetworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkWhereInput
  }


  /**
   * Count Type AnnualSoftwareExpenseCountOutputType
   */

  export type AnnualSoftwareExpenseCountOutputType = {
    assignedPersons: number
  }

  export type AnnualSoftwareExpenseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedPersons?: boolean | AnnualSoftwareExpenseCountOutputTypeCountAssignedPersonsArgs
  }

  // Custom InputTypes
  /**
   * AnnualSoftwareExpenseCountOutputType without action
   */
  export type AnnualSoftwareExpenseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpenseCountOutputType
     */
    select?: AnnualSoftwareExpenseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnnualSoftwareExpenseCountOutputType without action
   */
  export type AnnualSoftwareExpenseCountOutputTypeCountAssignedPersonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketAvgAggregateOutputType = {
    ticketNumber: number | null
    requestDays: number | null
    approvedDays: number | null
  }

  export type TicketSumAggregateOutputType = {
    ticketNumber: number | null
    requestDays: number | null
    approvedDays: number | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    ticketNumber: number | null
    title: string | null
    description: string | null
    img: string | null
    comment: string | null
    type: $Enums.TicketType | null
    priority: $Enums.TicketPriority | null
    status: $Enums.TicketStatus | null
    startDate: Date | null
    endDate: Date | null
    requestDays: number | null
    approvedDays: number | null
    view: boolean | null
    sendById: string | null
    sendToId: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewed: boolean | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    ticketNumber: number | null
    title: string | null
    description: string | null
    img: string | null
    comment: string | null
    type: $Enums.TicketType | null
    priority: $Enums.TicketPriority | null
    status: $Enums.TicketStatus | null
    startDate: Date | null
    endDate: Date | null
    requestDays: number | null
    approvedDays: number | null
    view: boolean | null
    sendById: string | null
    sendToId: string | null
    companyId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    reviewed: boolean | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    ticketNumber: number
    title: number
    description: number
    img: number
    comment: number
    type: number
    priority: number
    status: number
    startDate: number
    endDate: number
    requestDays: number
    approvedDays: number
    view: number
    sendById: number
    sendToId: number
    companyId: number
    createdAt: number
    updatedAt: number
    reviewed: number
    _all: number
  }


  export type TicketAvgAggregateInputType = {
    ticketNumber?: true
    requestDays?: true
    approvedDays?: true
  }

  export type TicketSumAggregateInputType = {
    ticketNumber?: true
    requestDays?: true
    approvedDays?: true
  }

  export type TicketMinAggregateInputType = {
    id?: true
    ticketNumber?: true
    title?: true
    description?: true
    img?: true
    comment?: true
    type?: true
    priority?: true
    status?: true
    startDate?: true
    endDate?: true
    requestDays?: true
    approvedDays?: true
    view?: true
    sendById?: true
    sendToId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    reviewed?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    ticketNumber?: true
    title?: true
    description?: true
    img?: true
    comment?: true
    type?: true
    priority?: true
    status?: true
    startDate?: true
    endDate?: true
    requestDays?: true
    approvedDays?: true
    view?: true
    sendById?: true
    sendToId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    reviewed?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    ticketNumber?: true
    title?: true
    description?: true
    img?: true
    comment?: true
    type?: true
    priority?: true
    status?: true
    startDate?: true
    endDate?: true
    requestDays?: true
    approvedDays?: true
    view?: true
    sendById?: true
    sendToId?: true
    companyId?: true
    createdAt?: true
    updatedAt?: true
    reviewed?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TicketAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TicketSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _avg?: TicketAvgAggregateInputType
    _sum?: TicketSumAggregateInputType
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    ticketNumber: number | null
    title: string
    description: string
    img: string | null
    comment: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate: Date | null
    endDate: Date | null
    requestDays: number | null
    approvedDays: number | null
    view: boolean | null
    sendById: string | null
    sendToId: string | null
    companyId: string | null
    createdAt: Date
    updatedAt: Date
    reviewed: boolean | null
    _count: TicketCountAggregateOutputType | null
    _avg: TicketAvgAggregateOutputType | null
    _sum: TicketSumAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    img?: boolean
    comment?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    requestDays?: boolean
    approvedDays?: boolean
    view?: boolean
    sendById?: boolean
    sendToId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewed?: boolean
    sendBy?: boolean | Ticket$sendByArgs<ExtArgs>
    sendTo?: boolean | Ticket$sendToArgs<ExtArgs>
    company?: boolean | Ticket$companyArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    img?: boolean
    comment?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    requestDays?: boolean
    approvedDays?: boolean
    view?: boolean
    sendById?: boolean
    sendToId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewed?: boolean
    sendBy?: boolean | Ticket$sendByArgs<ExtArgs>
    sendTo?: boolean | Ticket$sendToArgs<ExtArgs>
    company?: boolean | Ticket$companyArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    img?: boolean
    comment?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    requestDays?: boolean
    approvedDays?: boolean
    view?: boolean
    sendById?: boolean
    sendToId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewed?: boolean
    sendBy?: boolean | Ticket$sendByArgs<ExtArgs>
    sendTo?: boolean | Ticket$sendToArgs<ExtArgs>
    company?: boolean | Ticket$companyArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    ticketNumber?: boolean
    title?: boolean
    description?: boolean
    img?: boolean
    comment?: boolean
    type?: boolean
    priority?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    requestDays?: boolean
    approvedDays?: boolean
    view?: boolean
    sendById?: boolean
    sendToId?: boolean
    companyId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reviewed?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketNumber" | "title" | "description" | "img" | "comment" | "type" | "priority" | "status" | "startDate" | "endDate" | "requestDays" | "approvedDays" | "view" | "sendById" | "sendToId" | "companyId" | "createdAt" | "updatedAt" | "reviewed", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sendBy?: boolean | Ticket$sendByArgs<ExtArgs>
    sendTo?: boolean | Ticket$sendToArgs<ExtArgs>
    company?: boolean | Ticket$companyArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sendBy?: boolean | Ticket$sendByArgs<ExtArgs>
    sendTo?: boolean | Ticket$sendToArgs<ExtArgs>
    company?: boolean | Ticket$companyArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sendBy?: boolean | Ticket$sendByArgs<ExtArgs>
    sendTo?: boolean | Ticket$sendToArgs<ExtArgs>
    company?: boolean | Ticket$companyArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      sendBy: Prisma.$UserPayload<ExtArgs> | null
      sendTo: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketNumber: number | null
      title: string
      description: string
      img: string | null
      comment: string | null
      type: $Enums.TicketType
      priority: $Enums.TicketPriority
      status: $Enums.TicketStatus
      startDate: Date | null
      endDate: Date | null
      requestDays: number | null
      approvedDays: number | null
      view: boolean | null
      sendById: string | null
      sendToId: string | null
      companyId: string | null
      createdAt: Date
      updatedAt: Date
      reviewed: boolean | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sendBy<T extends Ticket$sendByArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$sendByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sendTo<T extends Ticket$sendToArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$sendToArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends Ticket$companyArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$companyArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly ticketNumber: FieldRef<"Ticket", 'Int'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly img: FieldRef<"Ticket", 'String'>
    readonly comment: FieldRef<"Ticket", 'String'>
    readonly type: FieldRef<"Ticket", 'TicketType'>
    readonly priority: FieldRef<"Ticket", 'TicketPriority'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly startDate: FieldRef<"Ticket", 'DateTime'>
    readonly endDate: FieldRef<"Ticket", 'DateTime'>
    readonly requestDays: FieldRef<"Ticket", 'Int'>
    readonly approvedDays: FieldRef<"Ticket", 'Int'>
    readonly view: FieldRef<"Ticket", 'Boolean'>
    readonly sendById: FieldRef<"Ticket", 'String'>
    readonly sendToId: FieldRef<"Ticket", 'String'>
    readonly companyId: FieldRef<"Ticket", 'String'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly reviewed: FieldRef<"Ticket", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.sendBy
   */
  export type Ticket$sendByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.sendTo
   */
  export type Ticket$sendToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.company
   */
  export type Ticket$companyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    username: string
    email: string
    password: string
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companies?: boolean | User$companiesArgs<ExtArgs>
    createdCompanies?: boolean | User$createdCompaniesArgs<ExtArgs>
    assignedEquipments?: boolean | User$assignedEquipmentsArgs<ExtArgs>
    assignedMaintenances?: boolean | User$assignedMaintenancesArgs<ExtArgs>
    assignedNetworks?: boolean | User$assignedNetworksArgs<ExtArgs>
    createdNetworks?: boolean | User$createdNetworksArgs<ExtArgs>
    person?: boolean | User$personArgs<ExtArgs>
    ticketsSentBy?: boolean | User$ticketsSentByArgs<ExtArgs>
    ticketsSentTo?: boolean | User$ticketsSentToArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password" | "role" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | User$companiesArgs<ExtArgs>
    createdCompanies?: boolean | User$createdCompaniesArgs<ExtArgs>
    assignedEquipments?: boolean | User$assignedEquipmentsArgs<ExtArgs>
    assignedMaintenances?: boolean | User$assignedMaintenancesArgs<ExtArgs>
    assignedNetworks?: boolean | User$assignedNetworksArgs<ExtArgs>
    createdNetworks?: boolean | User$createdNetworksArgs<ExtArgs>
    person?: boolean | User$personArgs<ExtArgs>
    ticketsSentBy?: boolean | User$ticketsSentByArgs<ExtArgs>
    ticketsSentTo?: boolean | User$ticketsSentToArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      companies: Prisma.$UserCompanyPayload<ExtArgs>[]
      createdCompanies: Prisma.$CompanyPayload<ExtArgs>[]
      assignedEquipments: Prisma.$EquipmentPayload<ExtArgs>[]
      assignedMaintenances: Prisma.$MaintenancePayload<ExtArgs>[]
      assignedNetworks: Prisma.$NetworkPayload<ExtArgs>[]
      createdNetworks: Prisma.$NetworkPayload<ExtArgs>[]
      person: Prisma.$PersonPayload<ExtArgs> | null
      ticketsSentBy: Prisma.$TicketPayload<ExtArgs>[]
      ticketsSentTo: Prisma.$TicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      password: string
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends User$companiesArgs<ExtArgs> = {}>(args?: Subset<T, User$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdCompanies<T extends User$createdCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, User$createdCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedEquipments<T extends User$assignedEquipmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedEquipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedMaintenances<T extends User$assignedMaintenancesArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedMaintenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedNetworks<T extends User$assignedNetworksArgs<ExtArgs> = {}>(args?: Subset<T, User$assignedNetworksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdNetworks<T extends User$createdNetworksArgs<ExtArgs> = {}>(args?: Subset<T, User$createdNetworksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    person<T extends User$personArgs<ExtArgs> = {}>(args?: Subset<T, User$personArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ticketsSentBy<T extends User$ticketsSentByArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsSentByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketsSentTo<T extends User$ticketsSentToArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsSentToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.companies
   */
  export type User$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    where?: UserCompanyWhereInput
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    cursor?: UserCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * User.createdCompanies
   */
  export type User$createdCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    cursor?: CompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * User.assignedEquipments
   */
  export type User$assignedEquipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * User.assignedMaintenances
   */
  export type User$assignedMaintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * User.assignedNetworks
   */
  export type User$assignedNetworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    where?: NetworkWhereInput
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    cursor?: NetworkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * User.createdNetworks
   */
  export type User$createdNetworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    where?: NetworkWhereInput
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    cursor?: NetworkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * User.person
   */
  export type User$personArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
  }

  /**
   * User.ticketsSentBy
   */
  export type User$ticketsSentByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.ticketsSentTo
   */
  export type User$ticketsSentToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserCompany
   */

  export type AggregateUserCompany = {
    _count: UserCompanyCountAggregateOutputType | null
    _min: UserCompanyMinAggregateOutputType | null
    _max: UserCompanyMaxAggregateOutputType | null
  }

  export type UserCompanyMinAggregateOutputType = {
    userId: string | null
    companyId: string | null
  }

  export type UserCompanyMaxAggregateOutputType = {
    userId: string | null
    companyId: string | null
  }

  export type UserCompanyCountAggregateOutputType = {
    userId: number
    companyId: number
    _all: number
  }


  export type UserCompanyMinAggregateInputType = {
    userId?: true
    companyId?: true
  }

  export type UserCompanyMaxAggregateInputType = {
    userId?: true
    companyId?: true
  }

  export type UserCompanyCountAggregateInputType = {
    userId?: true
    companyId?: true
    _all?: true
  }

  export type UserCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCompany to aggregate.
     */
    where?: UserCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCompanies to fetch.
     */
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserCompanies
    **/
    _count?: true | UserCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserCompanyMaxAggregateInputType
  }

  export type GetUserCompanyAggregateType<T extends UserCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateUserCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserCompany[P]>
      : GetScalarType<T[P], AggregateUserCompany[P]>
  }




  export type UserCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserCompanyWhereInput
    orderBy?: UserCompanyOrderByWithAggregationInput | UserCompanyOrderByWithAggregationInput[]
    by: UserCompanyScalarFieldEnum[] | UserCompanyScalarFieldEnum
    having?: UserCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCompanyCountAggregateInputType | true
    _min?: UserCompanyMinAggregateInputType
    _max?: UserCompanyMaxAggregateInputType
  }

  export type UserCompanyGroupByOutputType = {
    userId: string
    companyId: string
    _count: UserCompanyCountAggregateOutputType | null
    _min: UserCompanyMinAggregateOutputType | null
    _max: UserCompanyMaxAggregateOutputType | null
  }

  type GetUserCompanyGroupByPayload<T extends UserCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], UserCompanyGroupByOutputType[P]>
        }
      >
    >


  export type UserCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCompany"]>

  export type UserCompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCompany"]>

  export type UserCompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    companyId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userCompany"]>

  export type UserCompanySelectScalar = {
    userId?: boolean
    companyId?: boolean
  }

  export type UserCompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "companyId", ExtArgs["result"]["userCompany"]>
  export type UserCompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type UserCompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type UserCompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $UserCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserCompany"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      companyId: string
    }, ExtArgs["result"]["userCompany"]>
    composites: {}
  }

  type UserCompanyGetPayload<S extends boolean | null | undefined | UserCompanyDefaultArgs> = $Result.GetResult<Prisma.$UserCompanyPayload, S>

  type UserCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserCompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCompanyCountAggregateInputType | true
    }

  export interface UserCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserCompany'], meta: { name: 'UserCompany' } }
    /**
     * Find zero or one UserCompany that matches the filter.
     * @param {UserCompanyFindUniqueArgs} args - Arguments to find a UserCompany
     * @example
     * // Get one UserCompany
     * const userCompany = await prisma.userCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserCompanyFindUniqueArgs>(args: SelectSubset<T, UserCompanyFindUniqueArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserCompany that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserCompanyFindUniqueOrThrowArgs} args - Arguments to find a UserCompany
     * @example
     * // Get one UserCompany
     * const userCompany = await prisma.userCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, UserCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyFindFirstArgs} args - Arguments to find a UserCompany
     * @example
     * // Get one UserCompany
     * const userCompany = await prisma.userCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserCompanyFindFirstArgs>(args?: SelectSubset<T, UserCompanyFindFirstArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyFindFirstOrThrowArgs} args - Arguments to find a UserCompany
     * @example
     * // Get one UserCompany
     * const userCompany = await prisma.userCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, UserCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserCompanies
     * const userCompanies = await prisma.userCompany.findMany()
     * 
     * // Get first 10 UserCompanies
     * const userCompanies = await prisma.userCompany.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const userCompanyWithUserIdOnly = await prisma.userCompany.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends UserCompanyFindManyArgs>(args?: SelectSubset<T, UserCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserCompany.
     * @param {UserCompanyCreateArgs} args - Arguments to create a UserCompany.
     * @example
     * // Create one UserCompany
     * const UserCompany = await prisma.userCompany.create({
     *   data: {
     *     // ... data to create a UserCompany
     *   }
     * })
     * 
     */
    create<T extends UserCompanyCreateArgs>(args: SelectSubset<T, UserCompanyCreateArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserCompanies.
     * @param {UserCompanyCreateManyArgs} args - Arguments to create many UserCompanies.
     * @example
     * // Create many UserCompanies
     * const userCompany = await prisma.userCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCompanyCreateManyArgs>(args?: SelectSubset<T, UserCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserCompanies and returns the data saved in the database.
     * @param {UserCompanyCreateManyAndReturnArgs} args - Arguments to create many UserCompanies.
     * @example
     * // Create many UserCompanies
     * const userCompany = await prisma.userCompany.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserCompanies and only return the `userId`
     * const userCompanyWithUserIdOnly = await prisma.userCompany.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserCompany.
     * @param {UserCompanyDeleteArgs} args - Arguments to delete one UserCompany.
     * @example
     * // Delete one UserCompany
     * const UserCompany = await prisma.userCompany.delete({
     *   where: {
     *     // ... filter to delete one UserCompany
     *   }
     * })
     * 
     */
    delete<T extends UserCompanyDeleteArgs>(args: SelectSubset<T, UserCompanyDeleteArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserCompany.
     * @param {UserCompanyUpdateArgs} args - Arguments to update one UserCompany.
     * @example
     * // Update one UserCompany
     * const userCompany = await prisma.userCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserCompanyUpdateArgs>(args: SelectSubset<T, UserCompanyUpdateArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserCompanies.
     * @param {UserCompanyDeleteManyArgs} args - Arguments to filter UserCompanies to delete.
     * @example
     * // Delete a few UserCompanies
     * const { count } = await prisma.userCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserCompanyDeleteManyArgs>(args?: SelectSubset<T, UserCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserCompanies
     * const userCompany = await prisma.userCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserCompanyUpdateManyArgs>(args: SelectSubset<T, UserCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserCompanies and returns the data updated in the database.
     * @param {UserCompanyUpdateManyAndReturnArgs} args - Arguments to update many UserCompanies.
     * @example
     * // Update many UserCompanies
     * const userCompany = await prisma.userCompany.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserCompanies and only return the `userId`
     * const userCompanyWithUserIdOnly = await prisma.userCompany.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserCompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, UserCompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserCompany.
     * @param {UserCompanyUpsertArgs} args - Arguments to update or create a UserCompany.
     * @example
     * // Update or create a UserCompany
     * const userCompany = await prisma.userCompany.upsert({
     *   create: {
     *     // ... data to create a UserCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserCompany we want to update
     *   }
     * })
     */
    upsert<T extends UserCompanyUpsertArgs>(args: SelectSubset<T, UserCompanyUpsertArgs<ExtArgs>>): Prisma__UserCompanyClient<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyCountArgs} args - Arguments to filter UserCompanies to count.
     * @example
     * // Count the number of UserCompanies
     * const count = await prisma.userCompany.count({
     *   where: {
     *     // ... the filter for the UserCompanies we want to count
     *   }
     * })
    **/
    count<T extends UserCompanyCountArgs>(
      args?: Subset<T, UserCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserCompanyAggregateArgs>(args: Subset<T, UserCompanyAggregateArgs>): Prisma.PrismaPromise<GetUserCompanyAggregateType<T>>

    /**
     * Group by UserCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserCompanyGroupByArgs['orderBy'] }
        : { orderBy?: UserCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserCompany model
   */
  readonly fields: UserCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserCompany model
   */
  interface UserCompanyFieldRefs {
    readonly userId: FieldRef<"UserCompany", 'String'>
    readonly companyId: FieldRef<"UserCompany", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserCompany findUnique
   */
  export type UserCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompany to fetch.
     */
    where: UserCompanyWhereUniqueInput
  }

  /**
   * UserCompany findUniqueOrThrow
   */
  export type UserCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompany to fetch.
     */
    where: UserCompanyWhereUniqueInput
  }

  /**
   * UserCompany findFirst
   */
  export type UserCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompany to fetch.
     */
    where?: UserCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCompanies to fetch.
     */
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCompanies.
     */
    cursor?: UserCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCompanies.
     */
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * UserCompany findFirstOrThrow
   */
  export type UserCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompany to fetch.
     */
    where?: UserCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCompanies to fetch.
     */
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserCompanies.
     */
    cursor?: UserCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserCompanies.
     */
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * UserCompany findMany
   */
  export type UserCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter, which UserCompanies to fetch.
     */
    where?: UserCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserCompanies to fetch.
     */
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserCompanies.
     */
    cursor?: UserCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserCompanies.
     */
    skip?: number
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * UserCompany create
   */
  export type UserCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a UserCompany.
     */
    data: XOR<UserCompanyCreateInput, UserCompanyUncheckedCreateInput>
  }

  /**
   * UserCompany createMany
   */
  export type UserCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserCompanies.
     */
    data: UserCompanyCreateManyInput | UserCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserCompany createManyAndReturn
   */
  export type UserCompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * The data used to create many UserCompanies.
     */
    data: UserCompanyCreateManyInput | UserCompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCompany update
   */
  export type UserCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a UserCompany.
     */
    data: XOR<UserCompanyUpdateInput, UserCompanyUncheckedUpdateInput>
    /**
     * Choose, which UserCompany to update.
     */
    where: UserCompanyWhereUniqueInput
  }

  /**
   * UserCompany updateMany
   */
  export type UserCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserCompanies.
     */
    data: XOR<UserCompanyUpdateManyMutationInput, UserCompanyUncheckedUpdateManyInput>
    /**
     * Filter which UserCompanies to update
     */
    where?: UserCompanyWhereInput
    /**
     * Limit how many UserCompanies to update.
     */
    limit?: number
  }

  /**
   * UserCompany updateManyAndReturn
   */
  export type UserCompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * The data used to update UserCompanies.
     */
    data: XOR<UserCompanyUpdateManyMutationInput, UserCompanyUncheckedUpdateManyInput>
    /**
     * Filter which UserCompanies to update
     */
    where?: UserCompanyWhereInput
    /**
     * Limit how many UserCompanies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserCompany upsert
   */
  export type UserCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the UserCompany to update in case it exists.
     */
    where: UserCompanyWhereUniqueInput
    /**
     * In case the UserCompany found by the `where` argument doesn't exist, create a new UserCompany with this data.
     */
    create: XOR<UserCompanyCreateInput, UserCompanyUncheckedCreateInput>
    /**
     * In case the UserCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserCompanyUpdateInput, UserCompanyUncheckedUpdateInput>
  }

  /**
   * UserCompany delete
   */
  export type UserCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    /**
     * Filter which UserCompany to delete.
     */
    where: UserCompanyWhereUniqueInput
  }

  /**
   * UserCompany deleteMany
   */
  export type UserCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserCompanies to delete
     */
    where?: UserCompanyWhereInput
    /**
     * Limit how many UserCompanies to delete.
     */
    limit?: number
  }

  /**
   * UserCompany without action
   */
  export type UserCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
  }


  /**
   * Model Person
   */

  export type AggregatePerson = {
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  export type PersonMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    contactEmail: string | null
    phoneNumber: string | null
    departmentId: string | null
    position: string | null
    status: $Enums.PersonStatus | null
    userCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type PersonMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    contactEmail: string | null
    phoneNumber: string | null
    departmentId: string | null
    position: string | null
    status: $Enums.PersonStatus | null
    userCode: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type PersonCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    fullName: number
    contactEmail: number
    phoneNumber: number
    departmentId: number
    position: number
    status: number
    userCode: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type PersonMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    fullName?: true
    contactEmail?: true
    phoneNumber?: true
    departmentId?: true
    position?: true
    status?: true
    userCode?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type PersonMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    fullName?: true
    contactEmail?: true
    phoneNumber?: true
    departmentId?: true
    position?: true
    status?: true
    userCode?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type PersonCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    fullName?: true
    contactEmail?: true
    phoneNumber?: true
    departmentId?: true
    position?: true
    status?: true
    userCode?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type PersonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Person to aggregate.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned People
    **/
    _count?: true | PersonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonMaxAggregateInputType
  }

  export type GetPersonAggregateType<T extends PersonAggregateArgs> = {
        [P in keyof T & keyof AggregatePerson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerson[P]>
      : GetScalarType<T[P], AggregatePerson[P]>
  }




  export type PersonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithAggregationInput | PersonOrderByWithAggregationInput[]
    by: PersonScalarFieldEnum[] | PersonScalarFieldEnum
    having?: PersonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonCountAggregateInputType | true
    _min?: PersonMinAggregateInputType
    _max?: PersonMaxAggregateInputType
  }

  export type PersonGroupByOutputType = {
    id: string
    userId: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    contactEmail: string | null
    phoneNumber: string | null
    departmentId: string | null
    position: string | null
    status: $Enums.PersonStatus
    userCode: string
    createdAt: Date
    updatedAt: Date
    companyId: string | null
    _count: PersonCountAggregateOutputType | null
    _min: PersonMinAggregateOutputType | null
    _max: PersonMaxAggregateOutputType | null
  }

  type GetPersonGroupByPayload<T extends PersonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonGroupByOutputType[P]>
            : GetScalarType<T[P], PersonGroupByOutputType[P]>
        }
      >
    >


  export type PersonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    contactEmail?: boolean
    phoneNumber?: boolean
    departmentId?: boolean
    position?: boolean
    status?: boolean
    userCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    department?: boolean | Person$departmentArgs<ExtArgs>
    user?: boolean | Person$userArgs<ExtArgs>
    assignedExpenses?: boolean | Person$assignedExpensesArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    contactEmail?: boolean
    phoneNumber?: boolean
    departmentId?: boolean
    position?: boolean
    status?: boolean
    userCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    department?: boolean | Person$departmentArgs<ExtArgs>
    user?: boolean | Person$userArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    contactEmail?: boolean
    phoneNumber?: boolean
    departmentId?: boolean
    position?: boolean
    status?: boolean
    userCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    department?: boolean | Person$departmentArgs<ExtArgs>
    user?: boolean | Person$userArgs<ExtArgs>
  }, ExtArgs["result"]["person"]>

  export type PersonSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    contactEmail?: boolean
    phoneNumber?: boolean
    departmentId?: boolean
    position?: boolean
    status?: boolean
    userCode?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type PersonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "fullName" | "contactEmail" | "phoneNumber" | "departmentId" | "position" | "status" | "userCode" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["person"]>
  export type PersonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Person$departmentArgs<ExtArgs>
    user?: boolean | Person$userArgs<ExtArgs>
    assignedExpenses?: boolean | Person$assignedExpensesArgs<ExtArgs>
    _count?: boolean | PersonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Person$departmentArgs<ExtArgs>
    user?: boolean | Person$userArgs<ExtArgs>
  }
  export type PersonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Person$departmentArgs<ExtArgs>
    user?: boolean | Person$userArgs<ExtArgs>
  }

  export type $PersonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Person"
    objects: {
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      assignedExpenses: Prisma.$AnnualSoftwareExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      firstName: string | null
      lastName: string | null
      fullName: string | null
      contactEmail: string | null
      phoneNumber: string | null
      departmentId: string | null
      position: string | null
      status: $Enums.PersonStatus
      userCode: string
      createdAt: Date
      updatedAt: Date
      companyId: string | null
    }, ExtArgs["result"]["person"]>
    composites: {}
  }

  type PersonGetPayload<S extends boolean | null | undefined | PersonDefaultArgs> = $Result.GetResult<Prisma.$PersonPayload, S>

  type PersonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonCountAggregateInputType | true
    }

  export interface PersonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Person'], meta: { name: 'Person' } }
    /**
     * Find zero or one Person that matches the filter.
     * @param {PersonFindUniqueArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonFindUniqueArgs>(args: SelectSubset<T, PersonFindUniqueArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Person that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonFindUniqueOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonFindFirstArgs>(args?: SelectSubset<T, PersonFindFirstArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Person that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindFirstOrThrowArgs} args - Arguments to find a Person
     * @example
     * // Get one Person
     * const person = await prisma.person.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more People that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all People
     * const people = await prisma.person.findMany()
     * 
     * // Get first 10 People
     * const people = await prisma.person.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personWithIdOnly = await prisma.person.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonFindManyArgs>(args?: SelectSubset<T, PersonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Person.
     * @param {PersonCreateArgs} args - Arguments to create a Person.
     * @example
     * // Create one Person
     * const Person = await prisma.person.create({
     *   data: {
     *     // ... data to create a Person
     *   }
     * })
     * 
     */
    create<T extends PersonCreateArgs>(args: SelectSubset<T, PersonCreateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many People.
     * @param {PersonCreateManyArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonCreateManyArgs>(args?: SelectSubset<T, PersonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many People and returns the data saved in the database.
     * @param {PersonCreateManyAndReturnArgs} args - Arguments to create many People.
     * @example
     * // Create many People
     * const person = await prisma.person.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many People and only return the `id`
     * const personWithIdOnly = await prisma.person.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Person.
     * @param {PersonDeleteArgs} args - Arguments to delete one Person.
     * @example
     * // Delete one Person
     * const Person = await prisma.person.delete({
     *   where: {
     *     // ... filter to delete one Person
     *   }
     * })
     * 
     */
    delete<T extends PersonDeleteArgs>(args: SelectSubset<T, PersonDeleteArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Person.
     * @param {PersonUpdateArgs} args - Arguments to update one Person.
     * @example
     * // Update one Person
     * const person = await prisma.person.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonUpdateArgs>(args: SelectSubset<T, PersonUpdateArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more People.
     * @param {PersonDeleteManyArgs} args - Arguments to filter People to delete.
     * @example
     * // Delete a few People
     * const { count } = await prisma.person.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonDeleteManyArgs>(args?: SelectSubset<T, PersonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many People
     * const person = await prisma.person.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonUpdateManyArgs>(args: SelectSubset<T, PersonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more People and returns the data updated in the database.
     * @param {PersonUpdateManyAndReturnArgs} args - Arguments to update many People.
     * @example
     * // Update many People
     * const person = await prisma.person.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more People and only return the `id`
     * const personWithIdOnly = await prisma.person.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Person.
     * @param {PersonUpsertArgs} args - Arguments to update or create a Person.
     * @example
     * // Update or create a Person
     * const person = await prisma.person.upsert({
     *   create: {
     *     // ... data to create a Person
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Person we want to update
     *   }
     * })
     */
    upsert<T extends PersonUpsertArgs>(args: SelectSubset<T, PersonUpsertArgs<ExtArgs>>): Prisma__PersonClient<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of People.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonCountArgs} args - Arguments to filter People to count.
     * @example
     * // Count the number of People
     * const count = await prisma.person.count({
     *   where: {
     *     // ... the filter for the People we want to count
     *   }
     * })
    **/
    count<T extends PersonCountArgs>(
      args?: Subset<T, PersonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonAggregateArgs>(args: Subset<T, PersonAggregateArgs>): Prisma.PrismaPromise<GetPersonAggregateType<T>>

    /**
     * Group by Person.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonGroupByArgs['orderBy'] }
        : { orderBy?: PersonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Person model
   */
  readonly fields: PersonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Person.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Person$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Person$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Person$userArgs<ExtArgs> = {}>(args?: Subset<T, Person$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedExpenses<T extends Person$assignedExpensesArgs<ExtArgs> = {}>(args?: Subset<T, Person$assignedExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Person model
   */
  interface PersonFieldRefs {
    readonly id: FieldRef<"Person", 'String'>
    readonly userId: FieldRef<"Person", 'String'>
    readonly firstName: FieldRef<"Person", 'String'>
    readonly lastName: FieldRef<"Person", 'String'>
    readonly fullName: FieldRef<"Person", 'String'>
    readonly contactEmail: FieldRef<"Person", 'String'>
    readonly phoneNumber: FieldRef<"Person", 'String'>
    readonly departmentId: FieldRef<"Person", 'String'>
    readonly position: FieldRef<"Person", 'String'>
    readonly status: FieldRef<"Person", 'PersonStatus'>
    readonly userCode: FieldRef<"Person", 'String'>
    readonly createdAt: FieldRef<"Person", 'DateTime'>
    readonly updatedAt: FieldRef<"Person", 'DateTime'>
    readonly companyId: FieldRef<"Person", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Person findUnique
   */
  export type PersonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findUniqueOrThrow
   */
  export type PersonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person findFirst
   */
  export type PersonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findFirstOrThrow
   */
  export type PersonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which Person to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of People.
     */
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person findMany
   */
  export type PersonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter, which People to fetch.
     */
    where?: PersonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of People to fetch.
     */
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing People.
     */
    cursor?: PersonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` People from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` People.
     */
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Person create
   */
  export type PersonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to create a Person.
     */
    data: XOR<PersonCreateInput, PersonUncheckedCreateInput>
  }

  /**
   * Person createMany
   */
  export type PersonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Person createManyAndReturn
   */
  export type PersonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * The data used to create many People.
     */
    data: PersonCreateManyInput | PersonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Person update
   */
  export type PersonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The data needed to update a Person.
     */
    data: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
    /**
     * Choose, which Person to update.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person updateMany
   */
  export type PersonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
  }

  /**
   * Person updateManyAndReturn
   */
  export type PersonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * The data used to update People.
     */
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyInput>
    /**
     * Filter which People to update
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Person upsert
   */
  export type PersonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * The filter to search for the Person to update in case it exists.
     */
    where: PersonWhereUniqueInput
    /**
     * In case the Person found by the `where` argument doesn't exist, create a new Person with this data.
     */
    create: XOR<PersonCreateInput, PersonUncheckedCreateInput>
    /**
     * In case the Person was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonUpdateInput, PersonUncheckedUpdateInput>
  }

  /**
   * Person delete
   */
  export type PersonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    /**
     * Filter which Person to delete.
     */
    where: PersonWhereUniqueInput
  }

  /**
   * Person deleteMany
   */
  export type PersonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which People to delete
     */
    where?: PersonWhereInput
    /**
     * Limit how many People to delete.
     */
    limit?: number
  }

  /**
   * Person.department
   */
  export type Person$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Person.user
   */
  export type Person$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Person.assignedExpenses
   */
  export type Person$assignedExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    where?: AnnualSoftwareExpenseWhereInput
    orderBy?: AnnualSoftwareExpenseOrderByWithRelationInput | AnnualSoftwareExpenseOrderByWithRelationInput[]
    cursor?: AnnualSoftwareExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnnualSoftwareExpenseScalarFieldEnum | AnnualSoftwareExpenseScalarFieldEnum[]
  }

  /**
   * Person without action
   */
  export type PersonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    ruc: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdByUserId: string | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    address: string | null
    phone: string | null
    email: string | null
    ruc: string | null
    logoUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    createdByUserId: string | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    code: number
    name: number
    address: number
    phone: number
    email: number
    ruc: number
    logoUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    createdByUserId: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    ruc?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdByUserId?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    ruc?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdByUserId?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    address?: true
    phone?: true
    email?: true
    ruc?: true
    logoUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    createdByUserId?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    code: string
    name: string
    address: string | null
    phone: string | null
    email: string | null
    ruc: string | null
    logoUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    createdByUserId: string | null
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    ruc?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByUserId?: boolean
    createdBy?: boolean | Company$createdByArgs<ExtArgs>
    departments?: boolean | Company$departmentsArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    equipments?: boolean | Company$equipmentsArgs<ExtArgs>
    licenses?: boolean | Company$licensesArgs<ExtArgs>
    maintenances?: boolean | Company$maintenancesArgs<ExtArgs>
    networks?: boolean | Company$networksArgs<ExtArgs>
    networkProviders?: boolean | Company$networkProvidersArgs<ExtArgs>
    tickets?: boolean | Company$ticketsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    ruc?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByUserId?: boolean
    createdBy?: boolean | Company$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    ruc?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByUserId?: boolean
    createdBy?: boolean | Company$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    ruc?: boolean
    logoUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdByUserId?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "address" | "phone" | "email" | "ruc" | "logoUrl" | "isActive" | "createdAt" | "updatedAt" | "createdByUserId", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Company$createdByArgs<ExtArgs>
    departments?: boolean | Company$departmentsArgs<ExtArgs>
    documents?: boolean | Company$documentsArgs<ExtArgs>
    equipments?: boolean | Company$equipmentsArgs<ExtArgs>
    licenses?: boolean | Company$licensesArgs<ExtArgs>
    maintenances?: boolean | Company$maintenancesArgs<ExtArgs>
    networks?: boolean | Company$networksArgs<ExtArgs>
    networkProviders?: boolean | Company$networkProvidersArgs<ExtArgs>
    tickets?: boolean | Company$ticketsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Company$createdByArgs<ExtArgs>
  }
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Company$createdByArgs<ExtArgs>
  }

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      departments: Prisma.$DepartmentPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      equipments: Prisma.$EquipmentPayload<ExtArgs>[]
      licenses: Prisma.$LicensePayload<ExtArgs>[]
      maintenances: Prisma.$MaintenancePayload<ExtArgs>[]
      networks: Prisma.$NetworkPayload<ExtArgs>[]
      networkProviders: Prisma.$NetworkProviderPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      users: Prisma.$UserCompanyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      address: string | null
      phone: string | null
      email: string | null
      ruc: string | null
      logoUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      createdByUserId: string | null
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Company$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Company$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    departments<T extends Company$departmentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$departmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Company$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    equipments<T extends Company$equipmentsArgs<ExtArgs> = {}>(args?: Subset<T, Company$equipmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    licenses<T extends Company$licensesArgs<ExtArgs> = {}>(args?: Subset<T, Company$licensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenances<T extends Company$maintenancesArgs<ExtArgs> = {}>(args?: Subset<T, Company$maintenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    networks<T extends Company$networksArgs<ExtArgs> = {}>(args?: Subset<T, Company$networksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    networkProviders<T extends Company$networkProvidersArgs<ExtArgs> = {}>(args?: Subset<T, Company$networkProvidersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Company$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Company$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserCompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly code: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly ruc: FieldRef<"Company", 'String'>
    readonly logoUrl: FieldRef<"Company", 'String'>
    readonly isActive: FieldRef<"Company", 'Boolean'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
    readonly createdByUserId: FieldRef<"Company", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.createdBy
   */
  export type Company$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Company.departments
   */
  export type Company$departmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Company.documents
   */
  export type Company$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Company.equipments
   */
  export type Company$equipmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    cursor?: EquipmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Company.licenses
   */
  export type Company$licensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    cursor?: LicenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * Company.maintenances
   */
  export type Company$maintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Company.networks
   */
  export type Company$networksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    where?: NetworkWhereInput
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    cursor?: NetworkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Company.networkProviders
   */
  export type Company$networkProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    where?: NetworkProviderWhereInput
    orderBy?: NetworkProviderOrderByWithRelationInput | NetworkProviderOrderByWithRelationInput[]
    cursor?: NetworkProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkProviderScalarFieldEnum | NetworkProviderScalarFieldEnum[]
  }

  /**
   * Company.tickets
   */
  export type Company$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCompany
     */
    select?: UserCompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserCompany
     */
    omit?: UserCompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserCompanyInclude<ExtArgs> | null
    where?: UserCompanyWhereInput
    orderBy?: UserCompanyOrderByWithRelationInput | UserCompanyOrderByWithRelationInput[]
    cursor?: UserCompanyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserCompanyScalarFieldEnum | UserCompanyScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: DepartmentCountAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    persons?: boolean | Department$personsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type DepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "isActive" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["department"]>
  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    persons?: boolean | Department$personsArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      persons: Prisma.$PersonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments and returns the data updated in the database.
     * @param {DepartmentUpdateManyAndReturnArgs} args - Arguments to update many Departments.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, DepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    persons<T extends Department$personsArgs<ExtArgs> = {}>(args?: Subset<T, Department$personsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
    readonly companyId: FieldRef<"Department", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
  }

  /**
   * Department updateManyAndReturn
   */
  export type DepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
    /**
     * Limit how many Departments to delete.
     */
    limit?: number
  }

  /**
   * Department.persons
   */
  export type Department$personsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    cursor?: PersonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Department
     */
    omit?: DepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Equipment
   */

  export type AggregateEquipment = {
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  export type EquipmentAvgAggregateOutputType = {
    cost: Decimal | null
  }

  export type EquipmentSumAggregateOutputType = {
    cost: Decimal | null
  }

  export type EquipmentMinAggregateOutputType = {
    id: string | null
    type: string | null
    brand: string | null
    model: string | null
    serialNumber: string | null
    plateNumber: string | null
    location: string | null
    status: $Enums.EquipmentStatus | null
    acquisitionDate: Date | null
    warrantyDetails: string | null
    qrCode: string | null
    invoiceUrl: string | null
    cost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    assignedToUserId: string | null
    endUser: string | null
    operatingSystem: string | null
  }

  export type EquipmentMaxAggregateOutputType = {
    id: string | null
    type: string | null
    brand: string | null
    model: string | null
    serialNumber: string | null
    plateNumber: string | null
    location: string | null
    status: $Enums.EquipmentStatus | null
    acquisitionDate: Date | null
    warrantyDetails: string | null
    qrCode: string | null
    invoiceUrl: string | null
    cost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    assignedToUserId: string | null
    endUser: string | null
    operatingSystem: string | null
  }

  export type EquipmentCountAggregateOutputType = {
    id: number
    type: number
    brand: number
    model: number
    serialNumber: number
    plateNumber: number
    location: number
    status: number
    acquisitionDate: number
    warrantyDetails: number
    qrCode: number
    invoiceUrl: number
    cost: number
    createdAt: number
    updatedAt: number
    companyId: number
    assignedToUserId: number
    endUser: number
    operatingSystem: number
    _all: number
  }


  export type EquipmentAvgAggregateInputType = {
    cost?: true
  }

  export type EquipmentSumAggregateInputType = {
    cost?: true
  }

  export type EquipmentMinAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    model?: true
    serialNumber?: true
    plateNumber?: true
    location?: true
    status?: true
    acquisitionDate?: true
    warrantyDetails?: true
    qrCode?: true
    invoiceUrl?: true
    cost?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    assignedToUserId?: true
    endUser?: true
    operatingSystem?: true
  }

  export type EquipmentMaxAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    model?: true
    serialNumber?: true
    plateNumber?: true
    location?: true
    status?: true
    acquisitionDate?: true
    warrantyDetails?: true
    qrCode?: true
    invoiceUrl?: true
    cost?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    assignedToUserId?: true
    endUser?: true
    operatingSystem?: true
  }

  export type EquipmentCountAggregateInputType = {
    id?: true
    type?: true
    brand?: true
    model?: true
    serialNumber?: true
    plateNumber?: true
    location?: true
    status?: true
    acquisitionDate?: true
    warrantyDetails?: true
    qrCode?: true
    invoiceUrl?: true
    cost?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    assignedToUserId?: true
    endUser?: true
    operatingSystem?: true
    _all?: true
  }

  export type EquipmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to aggregate.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Equipment
    **/
    _count?: true | EquipmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EquipmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EquipmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EquipmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EquipmentMaxAggregateInputType
  }

  export type GetEquipmentAggregateType<T extends EquipmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEquipment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEquipment[P]>
      : GetScalarType<T[P], AggregateEquipment[P]>
  }




  export type EquipmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EquipmentWhereInput
    orderBy?: EquipmentOrderByWithAggregationInput | EquipmentOrderByWithAggregationInput[]
    by: EquipmentScalarFieldEnum[] | EquipmentScalarFieldEnum
    having?: EquipmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EquipmentCountAggregateInputType | true
    _avg?: EquipmentAvgAggregateInputType
    _sum?: EquipmentSumAggregateInputType
    _min?: EquipmentMinAggregateInputType
    _max?: EquipmentMaxAggregateInputType
  }

  export type EquipmentGroupByOutputType = {
    id: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber: string | null
    location: string | null
    status: $Enums.EquipmentStatus
    acquisitionDate: Date | null
    warrantyDetails: string | null
    qrCode: string | null
    invoiceUrl: string | null
    cost: Decimal | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    assignedToUserId: string | null
    endUser: string | null
    operatingSystem: string | null
    _count: EquipmentCountAggregateOutputType | null
    _avg: EquipmentAvgAggregateOutputType | null
    _sum: EquipmentSumAggregateOutputType | null
    _min: EquipmentMinAggregateOutputType | null
    _max: EquipmentMaxAggregateOutputType | null
  }

  type GetEquipmentGroupByPayload<T extends EquipmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EquipmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EquipmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
            : GetScalarType<T[P], EquipmentGroupByOutputType[P]>
        }
      >
    >


  export type EquipmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    serialNumber?: boolean
    plateNumber?: boolean
    location?: boolean
    status?: boolean
    acquisitionDate?: boolean
    warrantyDetails?: boolean
    qrCode?: boolean
    invoiceUrl?: boolean
    cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    assignedToUserId?: boolean
    endUser?: boolean
    operatingSystem?: boolean
    documents?: boolean | Equipment$documentsArgs<ExtArgs>
    assignedToUser?: boolean | Equipment$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    maintenances?: boolean | Equipment$maintenancesArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    serialNumber?: boolean
    plateNumber?: boolean
    location?: boolean
    status?: boolean
    acquisitionDate?: boolean
    warrantyDetails?: boolean
    qrCode?: boolean
    invoiceUrl?: boolean
    cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    assignedToUserId?: boolean
    endUser?: boolean
    operatingSystem?: boolean
    assignedToUser?: boolean | Equipment$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    serialNumber?: boolean
    plateNumber?: boolean
    location?: boolean
    status?: boolean
    acquisitionDate?: boolean
    warrantyDetails?: boolean
    qrCode?: boolean
    invoiceUrl?: boolean
    cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    assignedToUserId?: boolean
    endUser?: boolean
    operatingSystem?: boolean
    assignedToUser?: boolean | Equipment$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["equipment"]>

  export type EquipmentSelectScalar = {
    id?: boolean
    type?: boolean
    brand?: boolean
    model?: boolean
    serialNumber?: boolean
    plateNumber?: boolean
    location?: boolean
    status?: boolean
    acquisitionDate?: boolean
    warrantyDetails?: boolean
    qrCode?: boolean
    invoiceUrl?: boolean
    cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    assignedToUserId?: boolean
    endUser?: boolean
    operatingSystem?: boolean
  }

  export type EquipmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "brand" | "model" | "serialNumber" | "plateNumber" | "location" | "status" | "acquisitionDate" | "warrantyDetails" | "qrCode" | "invoiceUrl" | "cost" | "createdAt" | "updatedAt" | "companyId" | "assignedToUserId" | "endUser" | "operatingSystem", ExtArgs["result"]["equipment"]>
  export type EquipmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | Equipment$documentsArgs<ExtArgs>
    assignedToUser?: boolean | Equipment$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    maintenances?: boolean | Equipment$maintenancesArgs<ExtArgs>
    _count?: boolean | EquipmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | Equipment$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type EquipmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | Equipment$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $EquipmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Equipment"
    objects: {
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      assignedToUser: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      maintenances: Prisma.$MaintenancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      brand: string
      model: string
      serialNumber: string
      plateNumber: string | null
      location: string | null
      status: $Enums.EquipmentStatus
      acquisitionDate: Date | null
      warrantyDetails: string | null
      qrCode: string | null
      invoiceUrl: string | null
      cost: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
      companyId: string
      assignedToUserId: string | null
      endUser: string | null
      operatingSystem: string | null
    }, ExtArgs["result"]["equipment"]>
    composites: {}
  }

  type EquipmentGetPayload<S extends boolean | null | undefined | EquipmentDefaultArgs> = $Result.GetResult<Prisma.$EquipmentPayload, S>

  type EquipmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EquipmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EquipmentCountAggregateInputType | true
    }

  export interface EquipmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Equipment'], meta: { name: 'Equipment' } }
    /**
     * Find zero or one Equipment that matches the filter.
     * @param {EquipmentFindUniqueArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EquipmentFindUniqueArgs>(args: SelectSubset<T, EquipmentFindUniqueArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Equipment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EquipmentFindUniqueOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EquipmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EquipmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EquipmentFindFirstArgs>(args?: SelectSubset<T, EquipmentFindFirstArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Equipment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindFirstOrThrowArgs} args - Arguments to find a Equipment
     * @example
     * // Get one Equipment
     * const equipment = await prisma.equipment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EquipmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EquipmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Equipment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Equipment
     * const equipment = await prisma.equipment.findMany()
     * 
     * // Get first 10 Equipment
     * const equipment = await prisma.equipment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const equipmentWithIdOnly = await prisma.equipment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EquipmentFindManyArgs>(args?: SelectSubset<T, EquipmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Equipment.
     * @param {EquipmentCreateArgs} args - Arguments to create a Equipment.
     * @example
     * // Create one Equipment
     * const Equipment = await prisma.equipment.create({
     *   data: {
     *     // ... data to create a Equipment
     *   }
     * })
     * 
     */
    create<T extends EquipmentCreateArgs>(args: SelectSubset<T, EquipmentCreateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Equipment.
     * @param {EquipmentCreateManyArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EquipmentCreateManyArgs>(args?: SelectSubset<T, EquipmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Equipment and returns the data saved in the database.
     * @param {EquipmentCreateManyAndReturnArgs} args - Arguments to create many Equipment.
     * @example
     * // Create many Equipment
     * const equipment = await prisma.equipment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EquipmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EquipmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Equipment.
     * @param {EquipmentDeleteArgs} args - Arguments to delete one Equipment.
     * @example
     * // Delete one Equipment
     * const Equipment = await prisma.equipment.delete({
     *   where: {
     *     // ... filter to delete one Equipment
     *   }
     * })
     * 
     */
    delete<T extends EquipmentDeleteArgs>(args: SelectSubset<T, EquipmentDeleteArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Equipment.
     * @param {EquipmentUpdateArgs} args - Arguments to update one Equipment.
     * @example
     * // Update one Equipment
     * const equipment = await prisma.equipment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EquipmentUpdateArgs>(args: SelectSubset<T, EquipmentUpdateArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Equipment.
     * @param {EquipmentDeleteManyArgs} args - Arguments to filter Equipment to delete.
     * @example
     * // Delete a few Equipment
     * const { count } = await prisma.equipment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EquipmentDeleteManyArgs>(args?: SelectSubset<T, EquipmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EquipmentUpdateManyArgs>(args: SelectSubset<T, EquipmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Equipment and returns the data updated in the database.
     * @param {EquipmentUpdateManyAndReturnArgs} args - Arguments to update many Equipment.
     * @example
     * // Update many Equipment
     * const equipment = await prisma.equipment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Equipment and only return the `id`
     * const equipmentWithIdOnly = await prisma.equipment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EquipmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EquipmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Equipment.
     * @param {EquipmentUpsertArgs} args - Arguments to update or create a Equipment.
     * @example
     * // Update or create a Equipment
     * const equipment = await prisma.equipment.upsert({
     *   create: {
     *     // ... data to create a Equipment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Equipment we want to update
     *   }
     * })
     */
    upsert<T extends EquipmentUpsertArgs>(args: SelectSubset<T, EquipmentUpsertArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentCountArgs} args - Arguments to filter Equipment to count.
     * @example
     * // Count the number of Equipment
     * const count = await prisma.equipment.count({
     *   where: {
     *     // ... the filter for the Equipment we want to count
     *   }
     * })
    **/
    count<T extends EquipmentCountArgs>(
      args?: Subset<T, EquipmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EquipmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EquipmentAggregateArgs>(args: Subset<T, EquipmentAggregateArgs>): Prisma.PrismaPromise<GetEquipmentAggregateType<T>>

    /**
     * Group by Equipment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EquipmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EquipmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EquipmentGroupByArgs['orderBy'] }
        : { orderBy?: EquipmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EquipmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEquipmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Equipment model
   */
  readonly fields: EquipmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Equipment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EquipmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends Equipment$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedToUser<T extends Equipment$assignedToUserArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$assignedToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    maintenances<T extends Equipment$maintenancesArgs<ExtArgs> = {}>(args?: Subset<T, Equipment$maintenancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Equipment model
   */
  interface EquipmentFieldRefs {
    readonly id: FieldRef<"Equipment", 'String'>
    readonly type: FieldRef<"Equipment", 'String'>
    readonly brand: FieldRef<"Equipment", 'String'>
    readonly model: FieldRef<"Equipment", 'String'>
    readonly serialNumber: FieldRef<"Equipment", 'String'>
    readonly plateNumber: FieldRef<"Equipment", 'String'>
    readonly location: FieldRef<"Equipment", 'String'>
    readonly status: FieldRef<"Equipment", 'EquipmentStatus'>
    readonly acquisitionDate: FieldRef<"Equipment", 'DateTime'>
    readonly warrantyDetails: FieldRef<"Equipment", 'String'>
    readonly qrCode: FieldRef<"Equipment", 'String'>
    readonly invoiceUrl: FieldRef<"Equipment", 'String'>
    readonly cost: FieldRef<"Equipment", 'Decimal'>
    readonly createdAt: FieldRef<"Equipment", 'DateTime'>
    readonly updatedAt: FieldRef<"Equipment", 'DateTime'>
    readonly companyId: FieldRef<"Equipment", 'String'>
    readonly assignedToUserId: FieldRef<"Equipment", 'String'>
    readonly endUser: FieldRef<"Equipment", 'String'>
    readonly operatingSystem: FieldRef<"Equipment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Equipment findUnique
   */
  export type EquipmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findUniqueOrThrow
   */
  export type EquipmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment findFirst
   */
  export type EquipmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findFirstOrThrow
   */
  export type EquipmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Equipment.
     */
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment findMany
   */
  export type EquipmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter, which Equipment to fetch.
     */
    where?: EquipmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Equipment to fetch.
     */
    orderBy?: EquipmentOrderByWithRelationInput | EquipmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Equipment.
     */
    cursor?: EquipmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Equipment from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Equipment.
     */
    skip?: number
    distinct?: EquipmentScalarFieldEnum | EquipmentScalarFieldEnum[]
  }

  /**
   * Equipment create
   */
  export type EquipmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Equipment.
     */
    data: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
  }

  /**
   * Equipment createMany
   */
  export type EquipmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Equipment createManyAndReturn
   */
  export type EquipmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to create many Equipment.
     */
    data: EquipmentCreateManyInput | EquipmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment update
   */
  export type EquipmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Equipment.
     */
    data: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
    /**
     * Choose, which Equipment to update.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment updateMany
   */
  export type EquipmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
  }

  /**
   * Equipment updateManyAndReturn
   */
  export type EquipmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * The data used to update Equipment.
     */
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyInput>
    /**
     * Filter which Equipment to update
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Equipment upsert
   */
  export type EquipmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Equipment to update in case it exists.
     */
    where: EquipmentWhereUniqueInput
    /**
     * In case the Equipment found by the `where` argument doesn't exist, create a new Equipment with this data.
     */
    create: XOR<EquipmentCreateInput, EquipmentUncheckedCreateInput>
    /**
     * In case the Equipment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EquipmentUpdateInput, EquipmentUncheckedUpdateInput>
  }

  /**
   * Equipment delete
   */
  export type EquipmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    /**
     * Filter which Equipment to delete.
     */
    where: EquipmentWhereUniqueInput
  }

  /**
   * Equipment deleteMany
   */
  export type EquipmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Equipment to delete
     */
    where?: EquipmentWhereInput
    /**
     * Limit how many Equipment to delete.
     */
    limit?: number
  }

  /**
   * Equipment.documents
   */
  export type Equipment$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Equipment.assignedToUser
   */
  export type Equipment$assignedToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Equipment.maintenances
   */
  export type Equipment$maintenancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    cursor?: MaintenanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Equipment without action
   */
  export type EquipmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
  }


  /**
   * Model Maintenance
   */

  export type AggregateMaintenance = {
    _count: MaintenanceCountAggregateOutputType | null
    _avg: MaintenanceAvgAggregateOutputType | null
    _sum: MaintenanceSumAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  export type MaintenanceAvgAggregateOutputType = {
    cost: Decimal | null
  }

  export type MaintenanceSumAggregateOutputType = {
    cost: Decimal | null
  }

  export type MaintenanceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.MaintenanceType | null
    status: $Enums.MaintenanceStatus | null
    scheduledDate: Date | null
    completionDate: Date | null
    cost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    equipmentId: string | null
    assignedToUserId: string | null
    companyId: string | null
  }

  export type MaintenanceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: $Enums.MaintenanceType | null
    status: $Enums.MaintenanceStatus | null
    scheduledDate: Date | null
    completionDate: Date | null
    cost: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
    equipmentId: string | null
    assignedToUserId: string | null
    companyId: string | null
  }

  export type MaintenanceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    status: number
    scheduledDate: number
    completionDate: number
    cost: number
    createdAt: number
    updatedAt: number
    equipmentId: number
    assignedToUserId: number
    companyId: number
    _all: number
  }


  export type MaintenanceAvgAggregateInputType = {
    cost?: true
  }

  export type MaintenanceSumAggregateInputType = {
    cost?: true
  }

  export type MaintenanceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    scheduledDate?: true
    completionDate?: true
    cost?: true
    createdAt?: true
    updatedAt?: true
    equipmentId?: true
    assignedToUserId?: true
    companyId?: true
  }

  export type MaintenanceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    scheduledDate?: true
    completionDate?: true
    cost?: true
    createdAt?: true
    updatedAt?: true
    equipmentId?: true
    assignedToUserId?: true
    companyId?: true
  }

  export type MaintenanceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    status?: true
    scheduledDate?: true
    completionDate?: true
    cost?: true
    createdAt?: true
    updatedAt?: true
    equipmentId?: true
    assignedToUserId?: true
    companyId?: true
    _all?: true
  }

  export type MaintenanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenance to aggregate.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Maintenances
    **/
    _count?: true | MaintenanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MaintenanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MaintenanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceMaxAggregateInputType
  }

  export type GetMaintenanceAggregateType<T extends MaintenanceAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenance[P]>
      : GetScalarType<T[P], AggregateMaintenance[P]>
  }




  export type MaintenanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceWhereInput
    orderBy?: MaintenanceOrderByWithAggregationInput | MaintenanceOrderByWithAggregationInput[]
    by: MaintenanceScalarFieldEnum[] | MaintenanceScalarFieldEnum
    having?: MaintenanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceCountAggregateInputType | true
    _avg?: MaintenanceAvgAggregateInputType
    _sum?: MaintenanceSumAggregateInputType
    _min?: MaintenanceMinAggregateInputType
    _max?: MaintenanceMaxAggregateInputType
  }

  export type MaintenanceGroupByOutputType = {
    id: string
    title: string
    description: string | null
    type: $Enums.MaintenanceType
    status: $Enums.MaintenanceStatus
    scheduledDate: Date
    completionDate: Date | null
    cost: Decimal | null
    createdAt: Date
    updatedAt: Date
    equipmentId: string
    assignedToUserId: string | null
    companyId: string
    _count: MaintenanceCountAggregateOutputType | null
    _avg: MaintenanceAvgAggregateOutputType | null
    _sum: MaintenanceSumAggregateOutputType | null
    _min: MaintenanceMinAggregateOutputType | null
    _max: MaintenanceMaxAggregateOutputType | null
  }

  type GetMaintenanceGroupByPayload<T extends MaintenanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    scheduledDate?: boolean
    completionDate?: boolean
    cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipmentId?: boolean
    assignedToUserId?: boolean
    companyId?: boolean
    assignedToUser?: boolean | Maintenance$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    scheduledDate?: boolean
    completionDate?: boolean
    cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipmentId?: boolean
    assignedToUserId?: boolean
    companyId?: boolean
    assignedToUser?: boolean | Maintenance$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    scheduledDate?: boolean
    completionDate?: boolean
    cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipmentId?: boolean
    assignedToUserId?: boolean
    companyId?: boolean
    assignedToUser?: boolean | Maintenance$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenance"]>

  export type MaintenanceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    status?: boolean
    scheduledDate?: boolean
    completionDate?: boolean
    cost?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    equipmentId?: boolean
    assignedToUserId?: boolean
    companyId?: boolean
  }

  export type MaintenanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "type" | "status" | "scheduledDate" | "completionDate" | "cost" | "createdAt" | "updatedAt" | "equipmentId" | "assignedToUserId" | "companyId", ExtArgs["result"]["maintenance"]>
  export type MaintenanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | Maintenance$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type MaintenanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | Maintenance$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }
  export type MaintenanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | Maintenance$assignedToUserArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | EquipmentDefaultArgs<ExtArgs>
  }

  export type $MaintenancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Maintenance"
    objects: {
      assignedToUser: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      equipment: Prisma.$EquipmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      type: $Enums.MaintenanceType
      status: $Enums.MaintenanceStatus
      scheduledDate: Date
      completionDate: Date | null
      cost: Prisma.Decimal | null
      createdAt: Date
      updatedAt: Date
      equipmentId: string
      assignedToUserId: string | null
      companyId: string
    }, ExtArgs["result"]["maintenance"]>
    composites: {}
  }

  type MaintenanceGetPayload<S extends boolean | null | undefined | MaintenanceDefaultArgs> = $Result.GetResult<Prisma.$MaintenancePayload, S>

  type MaintenanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceCountAggregateInputType | true
    }

  export interface MaintenanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Maintenance'], meta: { name: 'Maintenance' } }
    /**
     * Find zero or one Maintenance that matches the filter.
     * @param {MaintenanceFindUniqueArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceFindUniqueArgs>(args: SelectSubset<T, MaintenanceFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Maintenance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceFindUniqueOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceFindFirstArgs>(args?: SelectSubset<T, MaintenanceFindFirstArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Maintenance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindFirstOrThrowArgs} args - Arguments to find a Maintenance
     * @example
     * // Get one Maintenance
     * const maintenance = await prisma.maintenance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Maintenances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Maintenances
     * const maintenances = await prisma.maintenance.findMany()
     * 
     * // Get first 10 Maintenances
     * const maintenances = await prisma.maintenance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceFindManyArgs>(args?: SelectSubset<T, MaintenanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Maintenance.
     * @param {MaintenanceCreateArgs} args - Arguments to create a Maintenance.
     * @example
     * // Create one Maintenance
     * const Maintenance = await prisma.maintenance.create({
     *   data: {
     *     // ... data to create a Maintenance
     *   }
     * })
     * 
     */
    create<T extends MaintenanceCreateArgs>(args: SelectSubset<T, MaintenanceCreateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Maintenances.
     * @param {MaintenanceCreateManyArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceCreateManyArgs>(args?: SelectSubset<T, MaintenanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Maintenances and returns the data saved in the database.
     * @param {MaintenanceCreateManyAndReturnArgs} args - Arguments to create many Maintenances.
     * @example
     * // Create many Maintenances
     * const maintenance = await prisma.maintenance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Maintenances and only return the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Maintenance.
     * @param {MaintenanceDeleteArgs} args - Arguments to delete one Maintenance.
     * @example
     * // Delete one Maintenance
     * const Maintenance = await prisma.maintenance.delete({
     *   where: {
     *     // ... filter to delete one Maintenance
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceDeleteArgs>(args: SelectSubset<T, MaintenanceDeleteArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Maintenance.
     * @param {MaintenanceUpdateArgs} args - Arguments to update one Maintenance.
     * @example
     * // Update one Maintenance
     * const maintenance = await prisma.maintenance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceUpdateArgs>(args: SelectSubset<T, MaintenanceUpdateArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Maintenances.
     * @param {MaintenanceDeleteManyArgs} args - Arguments to filter Maintenances to delete.
     * @example
     * // Delete a few Maintenances
     * const { count } = await prisma.maintenance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceDeleteManyArgs>(args?: SelectSubset<T, MaintenanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceUpdateManyArgs>(args: SelectSubset<T, MaintenanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Maintenances and returns the data updated in the database.
     * @param {MaintenanceUpdateManyAndReturnArgs} args - Arguments to update many Maintenances.
     * @example
     * // Update many Maintenances
     * const maintenance = await prisma.maintenance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Maintenances and only return the `id`
     * const maintenanceWithIdOnly = await prisma.maintenance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Maintenance.
     * @param {MaintenanceUpsertArgs} args - Arguments to update or create a Maintenance.
     * @example
     * // Update or create a Maintenance
     * const maintenance = await prisma.maintenance.upsert({
     *   create: {
     *     // ... data to create a Maintenance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Maintenance we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceUpsertArgs>(args: SelectSubset<T, MaintenanceUpsertArgs<ExtArgs>>): Prisma__MaintenanceClient<$Result.GetResult<Prisma.$MaintenancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Maintenances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceCountArgs} args - Arguments to filter Maintenances to count.
     * @example
     * // Count the number of Maintenances
     * const count = await prisma.maintenance.count({
     *   where: {
     *     // ... the filter for the Maintenances we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceCountArgs>(
      args?: Subset<T, MaintenanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceAggregateArgs>(args: Subset<T, MaintenanceAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceAggregateType<T>>

    /**
     * Group by Maintenance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Maintenance model
   */
  readonly fields: MaintenanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Maintenance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedToUser<T extends Maintenance$assignedToUserArgs<ExtArgs> = {}>(args?: Subset<T, Maintenance$assignedToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipment<T extends EquipmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EquipmentDefaultArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Maintenance model
   */
  interface MaintenanceFieldRefs {
    readonly id: FieldRef<"Maintenance", 'String'>
    readonly title: FieldRef<"Maintenance", 'String'>
    readonly description: FieldRef<"Maintenance", 'String'>
    readonly type: FieldRef<"Maintenance", 'MaintenanceType'>
    readonly status: FieldRef<"Maintenance", 'MaintenanceStatus'>
    readonly scheduledDate: FieldRef<"Maintenance", 'DateTime'>
    readonly completionDate: FieldRef<"Maintenance", 'DateTime'>
    readonly cost: FieldRef<"Maintenance", 'Decimal'>
    readonly createdAt: FieldRef<"Maintenance", 'DateTime'>
    readonly updatedAt: FieldRef<"Maintenance", 'DateTime'>
    readonly equipmentId: FieldRef<"Maintenance", 'String'>
    readonly assignedToUserId: FieldRef<"Maintenance", 'String'>
    readonly companyId: FieldRef<"Maintenance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Maintenance findUnique
   */
  export type MaintenanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findUniqueOrThrow
   */
  export type MaintenanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance findFirst
   */
  export type MaintenanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findFirstOrThrow
   */
  export type MaintenanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenance to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Maintenances.
     */
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance findMany
   */
  export type MaintenanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter, which Maintenances to fetch.
     */
    where?: MaintenanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Maintenances to fetch.
     */
    orderBy?: MaintenanceOrderByWithRelationInput | MaintenanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Maintenances.
     */
    cursor?: MaintenanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Maintenances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Maintenances.
     */
    skip?: number
    distinct?: MaintenanceScalarFieldEnum | MaintenanceScalarFieldEnum[]
  }

  /**
   * Maintenance create
   */
  export type MaintenanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Maintenance.
     */
    data: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
  }

  /**
   * Maintenance createMany
   */
  export type MaintenanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Maintenance createManyAndReturn
   */
  export type MaintenanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * The data used to create many Maintenances.
     */
    data: MaintenanceCreateManyInput | MaintenanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maintenance update
   */
  export type MaintenanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Maintenance.
     */
    data: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
    /**
     * Choose, which Maintenance to update.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance updateMany
   */
  export type MaintenanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to update.
     */
    limit?: number
  }

  /**
   * Maintenance updateManyAndReturn
   */
  export type MaintenanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * The data used to update Maintenances.
     */
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyInput>
    /**
     * Filter which Maintenances to update
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Maintenance upsert
   */
  export type MaintenanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Maintenance to update in case it exists.
     */
    where: MaintenanceWhereUniqueInput
    /**
     * In case the Maintenance found by the `where` argument doesn't exist, create a new Maintenance with this data.
     */
    create: XOR<MaintenanceCreateInput, MaintenanceUncheckedCreateInput>
    /**
     * In case the Maintenance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceUpdateInput, MaintenanceUncheckedUpdateInput>
  }

  /**
   * Maintenance delete
   */
  export type MaintenanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
    /**
     * Filter which Maintenance to delete.
     */
    where: MaintenanceWhereUniqueInput
  }

  /**
   * Maintenance deleteMany
   */
  export type MaintenanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Maintenances to delete
     */
    where?: MaintenanceWhereInput
    /**
     * Limit how many Maintenances to delete.
     */
    limit?: number
  }

  /**
   * Maintenance.assignedToUser
   */
  export type Maintenance$assignedToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Maintenance without action
   */
  export type MaintenanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Maintenance
     */
    select?: MaintenanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Maintenance
     */
    omit?: MaintenanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    equipmentId: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    fileType: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    equipmentId: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    title: number
    description: number
    fileUrl: number
    fileType: number
    category: number
    createdAt: number
    updatedAt: number
    companyId: number
    equipmentId: number
    _all: number
  }


  export type DocumentMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileUrl?: true
    fileType?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    equipmentId?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileUrl?: true
    fileType?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    equipmentId?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    fileUrl?: true
    fileType?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    equipmentId?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    title: string
    description: string | null
    fileUrl: string
    fileType: string | null
    category: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    equipmentId: string | null
    _count: DocumentCountAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    equipmentId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | Document$equipmentArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    equipmentId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | Document$equipmentArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    equipmentId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | Document$equipmentArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileType?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    equipmentId?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "fileUrl" | "fileType" | "category" | "createdAt" | "updatedAt" | "companyId" | "equipmentId", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | Document$equipmentArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | Document$equipmentArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    equipment?: boolean | Document$equipmentArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      equipment: Prisma.$EquipmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      fileUrl: string
      fileType: string | null
      category: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
      equipmentId: string | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    equipment<T extends Document$equipmentArgs<ExtArgs> = {}>(args?: Subset<T, Document$equipmentArgs<ExtArgs>>): Prisma__EquipmentClient<$Result.GetResult<Prisma.$EquipmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly description: FieldRef<"Document", 'String'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly fileType: FieldRef<"Document", 'String'>
    readonly category: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly companyId: FieldRef<"Document", 'String'>
    readonly equipmentId: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.equipment
   */
  export type Document$equipmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Equipment
     */
    select?: EquipmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Equipment
     */
    omit?: EquipmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EquipmentInclude<ExtArgs> | null
    where?: EquipmentWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model License
   */

  export type AggregateLicense = {
    _count: LicenseCountAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  export type LicenseMinAggregateOutputType = {
    id: string | null
    softwareName: string | null
    licenseKey: string | null
    provider: string | null
    activationDate: Date | null
    expirationDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type LicenseMaxAggregateOutputType = {
    id: string | null
    softwareName: string | null
    licenseKey: string | null
    provider: string | null
    activationDate: Date | null
    expirationDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
  }

  export type LicenseCountAggregateOutputType = {
    id: number
    softwareName: number
    licenseKey: number
    provider: number
    activationDate: number
    expirationDate: number
    notes: number
    createdAt: number
    updatedAt: number
    companyId: number
    _all: number
  }


  export type LicenseMinAggregateInputType = {
    id?: true
    softwareName?: true
    licenseKey?: true
    provider?: true
    activationDate?: true
    expirationDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type LicenseMaxAggregateInputType = {
    id?: true
    softwareName?: true
    licenseKey?: true
    provider?: true
    activationDate?: true
    expirationDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
  }

  export type LicenseCountAggregateInputType = {
    id?: true
    softwareName?: true
    licenseKey?: true
    provider?: true
    activationDate?: true
    expirationDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    _all?: true
  }

  export type LicenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which License to aggregate.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Licenses
    **/
    _count?: true | LicenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LicenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LicenseMaxAggregateInputType
  }

  export type GetLicenseAggregateType<T extends LicenseAggregateArgs> = {
        [P in keyof T & keyof AggregateLicense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLicense[P]>
      : GetScalarType<T[P], AggregateLicense[P]>
  }




  export type LicenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LicenseWhereInput
    orderBy?: LicenseOrderByWithAggregationInput | LicenseOrderByWithAggregationInput[]
    by: LicenseScalarFieldEnum[] | LicenseScalarFieldEnum
    having?: LicenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LicenseCountAggregateInputType | true
    _min?: LicenseMinAggregateInputType
    _max?: LicenseMaxAggregateInputType
  }

  export type LicenseGroupByOutputType = {
    id: string
    softwareName: string
    licenseKey: string
    provider: string | null
    activationDate: Date
    expirationDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    _count: LicenseCountAggregateOutputType | null
    _min: LicenseMinAggregateOutputType | null
    _max: LicenseMaxAggregateOutputType | null
  }

  type GetLicenseGroupByPayload<T extends LicenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LicenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LicenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LicenseGroupByOutputType[P]>
            : GetScalarType<T[P], LicenseGroupByOutputType[P]>
        }
      >
    >


  export type LicenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    softwareName?: boolean
    licenseKey?: boolean
    provider?: boolean
    activationDate?: boolean
    expirationDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    softwareName?: boolean
    licenseKey?: boolean
    provider?: boolean
    activationDate?: boolean
    expirationDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    softwareName?: boolean
    licenseKey?: boolean
    provider?: boolean
    activationDate?: boolean
    expirationDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["license"]>

  export type LicenseSelectScalar = {
    id?: boolean
    softwareName?: boolean
    licenseKey?: boolean
    provider?: boolean
    activationDate?: boolean
    expirationDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
  }

  export type LicenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "softwareName" | "licenseKey" | "provider" | "activationDate" | "expirationDate" | "notes" | "createdAt" | "updatedAt" | "companyId", ExtArgs["result"]["license"]>
  export type LicenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type LicenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type LicenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $LicensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "License"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      softwareName: string
      licenseKey: string
      provider: string | null
      activationDate: Date
      expirationDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
    }, ExtArgs["result"]["license"]>
    composites: {}
  }

  type LicenseGetPayload<S extends boolean | null | undefined | LicenseDefaultArgs> = $Result.GetResult<Prisma.$LicensePayload, S>

  type LicenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LicenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LicenseCountAggregateInputType | true
    }

  export interface LicenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['License'], meta: { name: 'License' } }
    /**
     * Find zero or one License that matches the filter.
     * @param {LicenseFindUniqueArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LicenseFindUniqueArgs>(args: SelectSubset<T, LicenseFindUniqueArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one License that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LicenseFindUniqueOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LicenseFindUniqueOrThrowArgs>(args: SelectSubset<T, LicenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LicenseFindFirstArgs>(args?: SelectSubset<T, LicenseFindFirstArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first License that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindFirstOrThrowArgs} args - Arguments to find a License
     * @example
     * // Get one License
     * const license = await prisma.license.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LicenseFindFirstOrThrowArgs>(args?: SelectSubset<T, LicenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Licenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Licenses
     * const licenses = await prisma.license.findMany()
     * 
     * // Get first 10 Licenses
     * const licenses = await prisma.license.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const licenseWithIdOnly = await prisma.license.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LicenseFindManyArgs>(args?: SelectSubset<T, LicenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a License.
     * @param {LicenseCreateArgs} args - Arguments to create a License.
     * @example
     * // Create one License
     * const License = await prisma.license.create({
     *   data: {
     *     // ... data to create a License
     *   }
     * })
     * 
     */
    create<T extends LicenseCreateArgs>(args: SelectSubset<T, LicenseCreateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Licenses.
     * @param {LicenseCreateManyArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LicenseCreateManyArgs>(args?: SelectSubset<T, LicenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Licenses and returns the data saved in the database.
     * @param {LicenseCreateManyAndReturnArgs} args - Arguments to create many Licenses.
     * @example
     * // Create many Licenses
     * const license = await prisma.license.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Licenses and only return the `id`
     * const licenseWithIdOnly = await prisma.license.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LicenseCreateManyAndReturnArgs>(args?: SelectSubset<T, LicenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a License.
     * @param {LicenseDeleteArgs} args - Arguments to delete one License.
     * @example
     * // Delete one License
     * const License = await prisma.license.delete({
     *   where: {
     *     // ... filter to delete one License
     *   }
     * })
     * 
     */
    delete<T extends LicenseDeleteArgs>(args: SelectSubset<T, LicenseDeleteArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one License.
     * @param {LicenseUpdateArgs} args - Arguments to update one License.
     * @example
     * // Update one License
     * const license = await prisma.license.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LicenseUpdateArgs>(args: SelectSubset<T, LicenseUpdateArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Licenses.
     * @param {LicenseDeleteManyArgs} args - Arguments to filter Licenses to delete.
     * @example
     * // Delete a few Licenses
     * const { count } = await prisma.license.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LicenseDeleteManyArgs>(args?: SelectSubset<T, LicenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LicenseUpdateManyArgs>(args: SelectSubset<T, LicenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Licenses and returns the data updated in the database.
     * @param {LicenseUpdateManyAndReturnArgs} args - Arguments to update many Licenses.
     * @example
     * // Update many Licenses
     * const license = await prisma.license.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Licenses and only return the `id`
     * const licenseWithIdOnly = await prisma.license.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LicenseUpdateManyAndReturnArgs>(args: SelectSubset<T, LicenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one License.
     * @param {LicenseUpsertArgs} args - Arguments to update or create a License.
     * @example
     * // Update or create a License
     * const license = await prisma.license.upsert({
     *   create: {
     *     // ... data to create a License
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the License we want to update
     *   }
     * })
     */
    upsert<T extends LicenseUpsertArgs>(args: SelectSubset<T, LicenseUpsertArgs<ExtArgs>>): Prisma__LicenseClient<$Result.GetResult<Prisma.$LicensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Licenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseCountArgs} args - Arguments to filter Licenses to count.
     * @example
     * // Count the number of Licenses
     * const count = await prisma.license.count({
     *   where: {
     *     // ... the filter for the Licenses we want to count
     *   }
     * })
    **/
    count<T extends LicenseCountArgs>(
      args?: Subset<T, LicenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LicenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LicenseAggregateArgs>(args: Subset<T, LicenseAggregateArgs>): Prisma.PrismaPromise<GetLicenseAggregateType<T>>

    /**
     * Group by License.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LicenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LicenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LicenseGroupByArgs['orderBy'] }
        : { orderBy?: LicenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LicenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLicenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the License model
   */
  readonly fields: LicenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for License.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LicenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the License model
   */
  interface LicenseFieldRefs {
    readonly id: FieldRef<"License", 'String'>
    readonly softwareName: FieldRef<"License", 'String'>
    readonly licenseKey: FieldRef<"License", 'String'>
    readonly provider: FieldRef<"License", 'String'>
    readonly activationDate: FieldRef<"License", 'DateTime'>
    readonly expirationDate: FieldRef<"License", 'DateTime'>
    readonly notes: FieldRef<"License", 'String'>
    readonly createdAt: FieldRef<"License", 'DateTime'>
    readonly updatedAt: FieldRef<"License", 'DateTime'>
    readonly companyId: FieldRef<"License", 'String'>
  }
    

  // Custom InputTypes
  /**
   * License findUnique
   */
  export type LicenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findUniqueOrThrow
   */
  export type LicenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License findFirst
   */
  export type LicenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findFirstOrThrow
   */
  export type LicenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which License to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Licenses.
     */
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License findMany
   */
  export type LicenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter, which Licenses to fetch.
     */
    where?: LicenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Licenses to fetch.
     */
    orderBy?: LicenseOrderByWithRelationInput | LicenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Licenses.
     */
    cursor?: LicenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Licenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Licenses.
     */
    skip?: number
    distinct?: LicenseScalarFieldEnum | LicenseScalarFieldEnum[]
  }

  /**
   * License create
   */
  export type LicenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to create a License.
     */
    data: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
  }

  /**
   * License createMany
   */
  export type LicenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * License createManyAndReturn
   */
  export type LicenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data used to create many Licenses.
     */
    data: LicenseCreateManyInput | LicenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * License update
   */
  export type LicenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The data needed to update a License.
     */
    data: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
    /**
     * Choose, which License to update.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License updateMany
   */
  export type LicenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to update.
     */
    limit?: number
  }

  /**
   * License updateManyAndReturn
   */
  export type LicenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * The data used to update Licenses.
     */
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyInput>
    /**
     * Filter which Licenses to update
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * License upsert
   */
  export type LicenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * The filter to search for the License to update in case it exists.
     */
    where: LicenseWhereUniqueInput
    /**
     * In case the License found by the `where` argument doesn't exist, create a new License with this data.
     */
    create: XOR<LicenseCreateInput, LicenseUncheckedCreateInput>
    /**
     * In case the License was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LicenseUpdateInput, LicenseUncheckedUpdateInput>
  }

  /**
   * License delete
   */
  export type LicenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
    /**
     * Filter which License to delete.
     */
    where: LicenseWhereUniqueInput
  }

  /**
   * License deleteMany
   */
  export type LicenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Licenses to delete
     */
    where?: LicenseWhereInput
    /**
     * Limit how many Licenses to delete.
     */
    limit?: number
  }

  /**
   * License without action
   */
  export type LicenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the License
     */
    select?: LicenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the License
     */
    omit?: LicenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LicenseInclude<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["systemConfig"]>

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
  }


  /**
   * Model NetworkProvider
   */

  export type AggregateNetworkProvider = {
    _count: NetworkProviderCountAggregateOutputType | null
    _avg: NetworkProviderAvgAggregateOutputType | null
    _sum: NetworkProviderSumAggregateOutputType | null
    _min: NetworkProviderMinAggregateOutputType | null
    _max: NetworkProviderMaxAggregateOutputType | null
  }

  export type NetworkProviderAvgAggregateOutputType = {
    cost: Decimal | null
  }

  export type NetworkProviderSumAggregateOutputType = {
    cost: Decimal | null
  }

  export type NetworkProviderMinAggregateOutputType = {
    id: string | null
    name: string | null
    providerIp: string | null
    dnsGateway: string | null
    speed: string | null
    cost: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    meshDevices: string | null
    switchDevices: string | null
    companyId: string | null
  }

  export type NetworkProviderMaxAggregateOutputType = {
    id: string | null
    name: string | null
    providerIp: string | null
    dnsGateway: string | null
    speed: string | null
    cost: Decimal | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    meshDevices: string | null
    switchDevices: string | null
    companyId: string | null
  }

  export type NetworkProviderCountAggregateOutputType = {
    id: number
    name: number
    providerIp: number
    dnsGateway: number
    speed: number
    cost: number
    notes: number
    createdAt: number
    updatedAt: number
    meshDevices: number
    switchDevices: number
    companyId: number
    _all: number
  }


  export type NetworkProviderAvgAggregateInputType = {
    cost?: true
  }

  export type NetworkProviderSumAggregateInputType = {
    cost?: true
  }

  export type NetworkProviderMinAggregateInputType = {
    id?: true
    name?: true
    providerIp?: true
    dnsGateway?: true
    speed?: true
    cost?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    meshDevices?: true
    switchDevices?: true
    companyId?: true
  }

  export type NetworkProviderMaxAggregateInputType = {
    id?: true
    name?: true
    providerIp?: true
    dnsGateway?: true
    speed?: true
    cost?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    meshDevices?: true
    switchDevices?: true
    companyId?: true
  }

  export type NetworkProviderCountAggregateInputType = {
    id?: true
    name?: true
    providerIp?: true
    dnsGateway?: true
    speed?: true
    cost?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    meshDevices?: true
    switchDevices?: true
    companyId?: true
    _all?: true
  }

  export type NetworkProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkProvider to aggregate.
     */
    where?: NetworkProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkProviders to fetch.
     */
    orderBy?: NetworkProviderOrderByWithRelationInput | NetworkProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NetworkProviders
    **/
    _count?: true | NetworkProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NetworkProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NetworkProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkProviderMaxAggregateInputType
  }

  export type GetNetworkProviderAggregateType<T extends NetworkProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateNetworkProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetworkProvider[P]>
      : GetScalarType<T[P], AggregateNetworkProvider[P]>
  }




  export type NetworkProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkProviderWhereInput
    orderBy?: NetworkProviderOrderByWithAggregationInput | NetworkProviderOrderByWithAggregationInput[]
    by: NetworkProviderScalarFieldEnum[] | NetworkProviderScalarFieldEnum
    having?: NetworkProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkProviderCountAggregateInputType | true
    _avg?: NetworkProviderAvgAggregateInputType
    _sum?: NetworkProviderSumAggregateInputType
    _min?: NetworkProviderMinAggregateInputType
    _max?: NetworkProviderMaxAggregateInputType
  }

  export type NetworkProviderGroupByOutputType = {
    id: string
    name: string
    providerIp: string | null
    dnsGateway: string | null
    speed: string | null
    cost: Decimal | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    meshDevices: string | null
    switchDevices: string | null
    companyId: string
    _count: NetworkProviderCountAggregateOutputType | null
    _avg: NetworkProviderAvgAggregateOutputType | null
    _sum: NetworkProviderSumAggregateOutputType | null
    _min: NetworkProviderMinAggregateOutputType | null
    _max: NetworkProviderMaxAggregateOutputType | null
  }

  type GetNetworkProviderGroupByPayload<T extends NetworkProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkProviderGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkProviderGroupByOutputType[P]>
        }
      >
    >


  export type NetworkProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    providerIp?: boolean
    dnsGateway?: boolean
    speed?: boolean
    cost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meshDevices?: boolean
    switchDevices?: boolean
    companyId?: boolean
    networks?: boolean | NetworkProvider$networksArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | NetworkProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkProvider"]>

  export type NetworkProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    providerIp?: boolean
    dnsGateway?: boolean
    speed?: boolean
    cost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meshDevices?: boolean
    switchDevices?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkProvider"]>

  export type NetworkProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    providerIp?: boolean
    dnsGateway?: boolean
    speed?: boolean
    cost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meshDevices?: boolean
    switchDevices?: boolean
    companyId?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["networkProvider"]>

  export type NetworkProviderSelectScalar = {
    id?: boolean
    name?: boolean
    providerIp?: boolean
    dnsGateway?: boolean
    speed?: boolean
    cost?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    meshDevices?: boolean
    switchDevices?: boolean
    companyId?: boolean
  }

  export type NetworkProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "providerIp" | "dnsGateway" | "speed" | "cost" | "notes" | "createdAt" | "updatedAt" | "meshDevices" | "switchDevices" | "companyId", ExtArgs["result"]["networkProvider"]>
  export type NetworkProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    networks?: boolean | NetworkProvider$networksArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    _count?: boolean | NetworkProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NetworkProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type NetworkProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $NetworkProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NetworkProvider"
    objects: {
      networks: Prisma.$NetworkPayload<ExtArgs>[]
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      providerIp: string | null
      dnsGateway: string | null
      speed: string | null
      cost: Prisma.Decimal | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      meshDevices: string | null
      switchDevices: string | null
      companyId: string
    }, ExtArgs["result"]["networkProvider"]>
    composites: {}
  }

  type NetworkProviderGetPayload<S extends boolean | null | undefined | NetworkProviderDefaultArgs> = $Result.GetResult<Prisma.$NetworkProviderPayload, S>

  type NetworkProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NetworkProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NetworkProviderCountAggregateInputType | true
    }

  export interface NetworkProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NetworkProvider'], meta: { name: 'NetworkProvider' } }
    /**
     * Find zero or one NetworkProvider that matches the filter.
     * @param {NetworkProviderFindUniqueArgs} args - Arguments to find a NetworkProvider
     * @example
     * // Get one NetworkProvider
     * const networkProvider = await prisma.networkProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NetworkProviderFindUniqueArgs>(args: SelectSubset<T, NetworkProviderFindUniqueArgs<ExtArgs>>): Prisma__NetworkProviderClient<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NetworkProvider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NetworkProviderFindUniqueOrThrowArgs} args - Arguments to find a NetworkProvider
     * @example
     * // Get one NetworkProvider
     * const networkProvider = await prisma.networkProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NetworkProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, NetworkProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NetworkProviderClient<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkProviderFindFirstArgs} args - Arguments to find a NetworkProvider
     * @example
     * // Get one NetworkProvider
     * const networkProvider = await prisma.networkProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NetworkProviderFindFirstArgs>(args?: SelectSubset<T, NetworkProviderFindFirstArgs<ExtArgs>>): Prisma__NetworkProviderClient<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NetworkProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkProviderFindFirstOrThrowArgs} args - Arguments to find a NetworkProvider
     * @example
     * // Get one NetworkProvider
     * const networkProvider = await prisma.networkProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NetworkProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, NetworkProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__NetworkProviderClient<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NetworkProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NetworkProviders
     * const networkProviders = await prisma.networkProvider.findMany()
     * 
     * // Get first 10 NetworkProviders
     * const networkProviders = await prisma.networkProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const networkProviderWithIdOnly = await prisma.networkProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NetworkProviderFindManyArgs>(args?: SelectSubset<T, NetworkProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NetworkProvider.
     * @param {NetworkProviderCreateArgs} args - Arguments to create a NetworkProvider.
     * @example
     * // Create one NetworkProvider
     * const NetworkProvider = await prisma.networkProvider.create({
     *   data: {
     *     // ... data to create a NetworkProvider
     *   }
     * })
     * 
     */
    create<T extends NetworkProviderCreateArgs>(args: SelectSubset<T, NetworkProviderCreateArgs<ExtArgs>>): Prisma__NetworkProviderClient<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NetworkProviders.
     * @param {NetworkProviderCreateManyArgs} args - Arguments to create many NetworkProviders.
     * @example
     * // Create many NetworkProviders
     * const networkProvider = await prisma.networkProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NetworkProviderCreateManyArgs>(args?: SelectSubset<T, NetworkProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NetworkProviders and returns the data saved in the database.
     * @param {NetworkProviderCreateManyAndReturnArgs} args - Arguments to create many NetworkProviders.
     * @example
     * // Create many NetworkProviders
     * const networkProvider = await prisma.networkProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NetworkProviders and only return the `id`
     * const networkProviderWithIdOnly = await prisma.networkProvider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NetworkProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, NetworkProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NetworkProvider.
     * @param {NetworkProviderDeleteArgs} args - Arguments to delete one NetworkProvider.
     * @example
     * // Delete one NetworkProvider
     * const NetworkProvider = await prisma.networkProvider.delete({
     *   where: {
     *     // ... filter to delete one NetworkProvider
     *   }
     * })
     * 
     */
    delete<T extends NetworkProviderDeleteArgs>(args: SelectSubset<T, NetworkProviderDeleteArgs<ExtArgs>>): Prisma__NetworkProviderClient<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NetworkProvider.
     * @param {NetworkProviderUpdateArgs} args - Arguments to update one NetworkProvider.
     * @example
     * // Update one NetworkProvider
     * const networkProvider = await prisma.networkProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NetworkProviderUpdateArgs>(args: SelectSubset<T, NetworkProviderUpdateArgs<ExtArgs>>): Prisma__NetworkProviderClient<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NetworkProviders.
     * @param {NetworkProviderDeleteManyArgs} args - Arguments to filter NetworkProviders to delete.
     * @example
     * // Delete a few NetworkProviders
     * const { count } = await prisma.networkProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NetworkProviderDeleteManyArgs>(args?: SelectSubset<T, NetworkProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NetworkProviders
     * const networkProvider = await prisma.networkProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NetworkProviderUpdateManyArgs>(args: SelectSubset<T, NetworkProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NetworkProviders and returns the data updated in the database.
     * @param {NetworkProviderUpdateManyAndReturnArgs} args - Arguments to update many NetworkProviders.
     * @example
     * // Update many NetworkProviders
     * const networkProvider = await prisma.networkProvider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NetworkProviders and only return the `id`
     * const networkProviderWithIdOnly = await prisma.networkProvider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NetworkProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, NetworkProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NetworkProvider.
     * @param {NetworkProviderUpsertArgs} args - Arguments to update or create a NetworkProvider.
     * @example
     * // Update or create a NetworkProvider
     * const networkProvider = await prisma.networkProvider.upsert({
     *   create: {
     *     // ... data to create a NetworkProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NetworkProvider we want to update
     *   }
     * })
     */
    upsert<T extends NetworkProviderUpsertArgs>(args: SelectSubset<T, NetworkProviderUpsertArgs<ExtArgs>>): Prisma__NetworkProviderClient<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NetworkProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkProviderCountArgs} args - Arguments to filter NetworkProviders to count.
     * @example
     * // Count the number of NetworkProviders
     * const count = await prisma.networkProvider.count({
     *   where: {
     *     // ... the filter for the NetworkProviders we want to count
     *   }
     * })
    **/
    count<T extends NetworkProviderCountArgs>(
      args?: Subset<T, NetworkProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NetworkProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkProviderAggregateArgs>(args: Subset<T, NetworkProviderAggregateArgs>): Prisma.PrismaPromise<GetNetworkProviderAggregateType<T>>

    /**
     * Group by NetworkProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkProviderGroupByArgs['orderBy'] }
        : { orderBy?: NetworkProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NetworkProvider model
   */
  readonly fields: NetworkProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NetworkProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    networks<T extends NetworkProvider$networksArgs<ExtArgs> = {}>(args?: Subset<T, NetworkProvider$networksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NetworkProvider model
   */
  interface NetworkProviderFieldRefs {
    readonly id: FieldRef<"NetworkProvider", 'String'>
    readonly name: FieldRef<"NetworkProvider", 'String'>
    readonly providerIp: FieldRef<"NetworkProvider", 'String'>
    readonly dnsGateway: FieldRef<"NetworkProvider", 'String'>
    readonly speed: FieldRef<"NetworkProvider", 'String'>
    readonly cost: FieldRef<"NetworkProvider", 'Decimal'>
    readonly notes: FieldRef<"NetworkProvider", 'String'>
    readonly createdAt: FieldRef<"NetworkProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"NetworkProvider", 'DateTime'>
    readonly meshDevices: FieldRef<"NetworkProvider", 'String'>
    readonly switchDevices: FieldRef<"NetworkProvider", 'String'>
    readonly companyId: FieldRef<"NetworkProvider", 'String'>
  }
    

  // Custom InputTypes
  /**
   * NetworkProvider findUnique
   */
  export type NetworkProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    /**
     * Filter, which NetworkProvider to fetch.
     */
    where: NetworkProviderWhereUniqueInput
  }

  /**
   * NetworkProvider findUniqueOrThrow
   */
  export type NetworkProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    /**
     * Filter, which NetworkProvider to fetch.
     */
    where: NetworkProviderWhereUniqueInput
  }

  /**
   * NetworkProvider findFirst
   */
  export type NetworkProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    /**
     * Filter, which NetworkProvider to fetch.
     */
    where?: NetworkProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkProviders to fetch.
     */
    orderBy?: NetworkProviderOrderByWithRelationInput | NetworkProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkProviders.
     */
    cursor?: NetworkProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkProviders.
     */
    distinct?: NetworkProviderScalarFieldEnum | NetworkProviderScalarFieldEnum[]
  }

  /**
   * NetworkProvider findFirstOrThrow
   */
  export type NetworkProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    /**
     * Filter, which NetworkProvider to fetch.
     */
    where?: NetworkProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkProviders to fetch.
     */
    orderBy?: NetworkProviderOrderByWithRelationInput | NetworkProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NetworkProviders.
     */
    cursor?: NetworkProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NetworkProviders.
     */
    distinct?: NetworkProviderScalarFieldEnum | NetworkProviderScalarFieldEnum[]
  }

  /**
   * NetworkProvider findMany
   */
  export type NetworkProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    /**
     * Filter, which NetworkProviders to fetch.
     */
    where?: NetworkProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NetworkProviders to fetch.
     */
    orderBy?: NetworkProviderOrderByWithRelationInput | NetworkProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NetworkProviders.
     */
    cursor?: NetworkProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NetworkProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NetworkProviders.
     */
    skip?: number
    distinct?: NetworkProviderScalarFieldEnum | NetworkProviderScalarFieldEnum[]
  }

  /**
   * NetworkProvider create
   */
  export type NetworkProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a NetworkProvider.
     */
    data: XOR<NetworkProviderCreateInput, NetworkProviderUncheckedCreateInput>
  }

  /**
   * NetworkProvider createMany
   */
  export type NetworkProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NetworkProviders.
     */
    data: NetworkProviderCreateManyInput | NetworkProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NetworkProvider createManyAndReturn
   */
  export type NetworkProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * The data used to create many NetworkProviders.
     */
    data: NetworkProviderCreateManyInput | NetworkProviderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkProvider update
   */
  export type NetworkProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a NetworkProvider.
     */
    data: XOR<NetworkProviderUpdateInput, NetworkProviderUncheckedUpdateInput>
    /**
     * Choose, which NetworkProvider to update.
     */
    where: NetworkProviderWhereUniqueInput
  }

  /**
   * NetworkProvider updateMany
   */
  export type NetworkProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NetworkProviders.
     */
    data: XOR<NetworkProviderUpdateManyMutationInput, NetworkProviderUncheckedUpdateManyInput>
    /**
     * Filter which NetworkProviders to update
     */
    where?: NetworkProviderWhereInput
    /**
     * Limit how many NetworkProviders to update.
     */
    limit?: number
  }

  /**
   * NetworkProvider updateManyAndReturn
   */
  export type NetworkProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * The data used to update NetworkProviders.
     */
    data: XOR<NetworkProviderUpdateManyMutationInput, NetworkProviderUncheckedUpdateManyInput>
    /**
     * Filter which NetworkProviders to update
     */
    where?: NetworkProviderWhereInput
    /**
     * Limit how many NetworkProviders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NetworkProvider upsert
   */
  export type NetworkProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the NetworkProvider to update in case it exists.
     */
    where: NetworkProviderWhereUniqueInput
    /**
     * In case the NetworkProvider found by the `where` argument doesn't exist, create a new NetworkProvider with this data.
     */
    create: XOR<NetworkProviderCreateInput, NetworkProviderUncheckedCreateInput>
    /**
     * In case the NetworkProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkProviderUpdateInput, NetworkProviderUncheckedUpdateInput>
  }

  /**
   * NetworkProvider delete
   */
  export type NetworkProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    /**
     * Filter which NetworkProvider to delete.
     */
    where: NetworkProviderWhereUniqueInput
  }

  /**
   * NetworkProvider deleteMany
   */
  export type NetworkProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NetworkProviders to delete
     */
    where?: NetworkProviderWhereInput
    /**
     * Limit how many NetworkProviders to delete.
     */
    limit?: number
  }

  /**
   * NetworkProvider.networks
   */
  export type NetworkProvider$networksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    where?: NetworkWhereInput
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    cursor?: NetworkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * NetworkProvider without action
   */
  export type NetworkProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
  }


  /**
   * Model Network
   */

  export type AggregateNetwork = {
    _count: NetworkCountAggregateOutputType | null
    _min: NetworkMinAggregateOutputType | null
    _max: NetworkMaxAggregateOutputType | null
  }

  export type NetworkMinAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.NetworkDeviceStatus | null
    location: string | null
    description: string | null
    notes: string | null
    ssid: string | null
    password: string | null
    ip: string | null
    dns: string | null
    gw: string | null
    uploadSpeed: string | null
    downloadSpeed: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    assignedToUserId: string | null
    createdByUserId: string | null
    providerId: string | null
  }

  export type NetworkMaxAggregateOutputType = {
    id: string | null
    name: string | null
    status: $Enums.NetworkDeviceStatus | null
    location: string | null
    description: string | null
    notes: string | null
    ssid: string | null
    password: string | null
    ip: string | null
    dns: string | null
    gw: string | null
    uploadSpeed: string | null
    downloadSpeed: string | null
    createdAt: Date | null
    updatedAt: Date | null
    companyId: string | null
    assignedToUserId: string | null
    createdByUserId: string | null
    providerId: string | null
  }

  export type NetworkCountAggregateOutputType = {
    id: number
    name: number
    status: number
    location: number
    description: number
    notes: number
    ssid: number
    password: number
    ip: number
    dns: number
    gw: number
    uploadSpeed: number
    downloadSpeed: number
    createdAt: number
    updatedAt: number
    companyId: number
    assignedToUserId: number
    createdByUserId: number
    providerId: number
    _all: number
  }


  export type NetworkMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
    location?: true
    description?: true
    notes?: true
    ssid?: true
    password?: true
    ip?: true
    dns?: true
    gw?: true
    uploadSpeed?: true
    downloadSpeed?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    assignedToUserId?: true
    createdByUserId?: true
    providerId?: true
  }

  export type NetworkMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
    location?: true
    description?: true
    notes?: true
    ssid?: true
    password?: true
    ip?: true
    dns?: true
    gw?: true
    uploadSpeed?: true
    downloadSpeed?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    assignedToUserId?: true
    createdByUserId?: true
    providerId?: true
  }

  export type NetworkCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    location?: true
    description?: true
    notes?: true
    ssid?: true
    password?: true
    ip?: true
    dns?: true
    gw?: true
    uploadSpeed?: true
    downloadSpeed?: true
    createdAt?: true
    updatedAt?: true
    companyId?: true
    assignedToUserId?: true
    createdByUserId?: true
    providerId?: true
    _all?: true
  }

  export type NetworkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Network to aggregate.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Networks
    **/
    _count?: true | NetworkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NetworkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NetworkMaxAggregateInputType
  }

  export type GetNetworkAggregateType<T extends NetworkAggregateArgs> = {
        [P in keyof T & keyof AggregateNetwork]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNetwork[P]>
      : GetScalarType<T[P], AggregateNetwork[P]>
  }




  export type NetworkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NetworkWhereInput
    orderBy?: NetworkOrderByWithAggregationInput | NetworkOrderByWithAggregationInput[]
    by: NetworkScalarFieldEnum[] | NetworkScalarFieldEnum
    having?: NetworkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NetworkCountAggregateInputType | true
    _min?: NetworkMinAggregateInputType
    _max?: NetworkMaxAggregateInputType
  }

  export type NetworkGroupByOutputType = {
    id: string
    name: string
    status: $Enums.NetworkDeviceStatus
    location: string | null
    description: string | null
    notes: string | null
    ssid: string | null
    password: string | null
    ip: string | null
    dns: string | null
    gw: string | null
    uploadSpeed: string | null
    downloadSpeed: string | null
    createdAt: Date
    updatedAt: Date
    companyId: string
    assignedToUserId: string | null
    createdByUserId: string | null
    providerId: string | null
    _count: NetworkCountAggregateOutputType | null
    _min: NetworkMinAggregateOutputType | null
    _max: NetworkMaxAggregateOutputType | null
  }

  type GetNetworkGroupByPayload<T extends NetworkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NetworkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NetworkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NetworkGroupByOutputType[P]>
            : GetScalarType<T[P], NetworkGroupByOutputType[P]>
        }
      >
    >


  export type NetworkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    location?: boolean
    description?: boolean
    notes?: boolean
    ssid?: boolean
    password?: boolean
    ip?: boolean
    dns?: boolean
    gw?: boolean
    uploadSpeed?: boolean
    downloadSpeed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    assignedToUserId?: boolean
    createdByUserId?: boolean
    providerId?: boolean
    assignedToUser?: boolean | Network$assignedToUserArgs<ExtArgs>
    createdBy?: boolean | Network$createdByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    provider?: boolean | Network$providerArgs<ExtArgs>
  }, ExtArgs["result"]["network"]>

  export type NetworkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    location?: boolean
    description?: boolean
    notes?: boolean
    ssid?: boolean
    password?: boolean
    ip?: boolean
    dns?: boolean
    gw?: boolean
    uploadSpeed?: boolean
    downloadSpeed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    assignedToUserId?: boolean
    createdByUserId?: boolean
    providerId?: boolean
    assignedToUser?: boolean | Network$assignedToUserArgs<ExtArgs>
    createdBy?: boolean | Network$createdByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    provider?: boolean | Network$providerArgs<ExtArgs>
  }, ExtArgs["result"]["network"]>

  export type NetworkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    location?: boolean
    description?: boolean
    notes?: boolean
    ssid?: boolean
    password?: boolean
    ip?: boolean
    dns?: boolean
    gw?: boolean
    uploadSpeed?: boolean
    downloadSpeed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    assignedToUserId?: boolean
    createdByUserId?: boolean
    providerId?: boolean
    assignedToUser?: boolean | Network$assignedToUserArgs<ExtArgs>
    createdBy?: boolean | Network$createdByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    provider?: boolean | Network$providerArgs<ExtArgs>
  }, ExtArgs["result"]["network"]>

  export type NetworkSelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
    location?: boolean
    description?: boolean
    notes?: boolean
    ssid?: boolean
    password?: boolean
    ip?: boolean
    dns?: boolean
    gw?: boolean
    uploadSpeed?: boolean
    downloadSpeed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    companyId?: boolean
    assignedToUserId?: boolean
    createdByUserId?: boolean
    providerId?: boolean
  }

  export type NetworkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "status" | "location" | "description" | "notes" | "ssid" | "password" | "ip" | "dns" | "gw" | "uploadSpeed" | "downloadSpeed" | "createdAt" | "updatedAt" | "companyId" | "assignedToUserId" | "createdByUserId" | "providerId", ExtArgs["result"]["network"]>
  export type NetworkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | Network$assignedToUserArgs<ExtArgs>
    createdBy?: boolean | Network$createdByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    provider?: boolean | Network$providerArgs<ExtArgs>
  }
  export type NetworkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | Network$assignedToUserArgs<ExtArgs>
    createdBy?: boolean | Network$createdByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    provider?: boolean | Network$providerArgs<ExtArgs>
  }
  export type NetworkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedToUser?: boolean | Network$assignedToUserArgs<ExtArgs>
    createdBy?: boolean | Network$createdByArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    provider?: boolean | Network$providerArgs<ExtArgs>
  }

  export type $NetworkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Network"
    objects: {
      assignedToUser: Prisma.$UserPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs> | null
      company: Prisma.$CompanyPayload<ExtArgs>
      provider: Prisma.$NetworkProviderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      status: $Enums.NetworkDeviceStatus
      location: string | null
      description: string | null
      notes: string | null
      ssid: string | null
      password: string | null
      ip: string | null
      dns: string | null
      gw: string | null
      uploadSpeed: string | null
      downloadSpeed: string | null
      createdAt: Date
      updatedAt: Date
      companyId: string
      assignedToUserId: string | null
      createdByUserId: string | null
      providerId: string | null
    }, ExtArgs["result"]["network"]>
    composites: {}
  }

  type NetworkGetPayload<S extends boolean | null | undefined | NetworkDefaultArgs> = $Result.GetResult<Prisma.$NetworkPayload, S>

  type NetworkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NetworkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NetworkCountAggregateInputType | true
    }

  export interface NetworkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Network'], meta: { name: 'Network' } }
    /**
     * Find zero or one Network that matches the filter.
     * @param {NetworkFindUniqueArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NetworkFindUniqueArgs>(args: SelectSubset<T, NetworkFindUniqueArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Network that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NetworkFindUniqueOrThrowArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NetworkFindUniqueOrThrowArgs>(args: SelectSubset<T, NetworkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Network that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkFindFirstArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NetworkFindFirstArgs>(args?: SelectSubset<T, NetworkFindFirstArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Network that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkFindFirstOrThrowArgs} args - Arguments to find a Network
     * @example
     * // Get one Network
     * const network = await prisma.network.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NetworkFindFirstOrThrowArgs>(args?: SelectSubset<T, NetworkFindFirstOrThrowArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Networks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Networks
     * const networks = await prisma.network.findMany()
     * 
     * // Get first 10 Networks
     * const networks = await prisma.network.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const networkWithIdOnly = await prisma.network.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NetworkFindManyArgs>(args?: SelectSubset<T, NetworkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Network.
     * @param {NetworkCreateArgs} args - Arguments to create a Network.
     * @example
     * // Create one Network
     * const Network = await prisma.network.create({
     *   data: {
     *     // ... data to create a Network
     *   }
     * })
     * 
     */
    create<T extends NetworkCreateArgs>(args: SelectSubset<T, NetworkCreateArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Networks.
     * @param {NetworkCreateManyArgs} args - Arguments to create many Networks.
     * @example
     * // Create many Networks
     * const network = await prisma.network.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NetworkCreateManyArgs>(args?: SelectSubset<T, NetworkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Networks and returns the data saved in the database.
     * @param {NetworkCreateManyAndReturnArgs} args - Arguments to create many Networks.
     * @example
     * // Create many Networks
     * const network = await prisma.network.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Networks and only return the `id`
     * const networkWithIdOnly = await prisma.network.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NetworkCreateManyAndReturnArgs>(args?: SelectSubset<T, NetworkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Network.
     * @param {NetworkDeleteArgs} args - Arguments to delete one Network.
     * @example
     * // Delete one Network
     * const Network = await prisma.network.delete({
     *   where: {
     *     // ... filter to delete one Network
     *   }
     * })
     * 
     */
    delete<T extends NetworkDeleteArgs>(args: SelectSubset<T, NetworkDeleteArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Network.
     * @param {NetworkUpdateArgs} args - Arguments to update one Network.
     * @example
     * // Update one Network
     * const network = await prisma.network.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NetworkUpdateArgs>(args: SelectSubset<T, NetworkUpdateArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Networks.
     * @param {NetworkDeleteManyArgs} args - Arguments to filter Networks to delete.
     * @example
     * // Delete a few Networks
     * const { count } = await prisma.network.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NetworkDeleteManyArgs>(args?: SelectSubset<T, NetworkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Networks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Networks
     * const network = await prisma.network.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NetworkUpdateManyArgs>(args: SelectSubset<T, NetworkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Networks and returns the data updated in the database.
     * @param {NetworkUpdateManyAndReturnArgs} args - Arguments to update many Networks.
     * @example
     * // Update many Networks
     * const network = await prisma.network.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Networks and only return the `id`
     * const networkWithIdOnly = await prisma.network.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NetworkUpdateManyAndReturnArgs>(args: SelectSubset<T, NetworkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Network.
     * @param {NetworkUpsertArgs} args - Arguments to update or create a Network.
     * @example
     * // Update or create a Network
     * const network = await prisma.network.upsert({
     *   create: {
     *     // ... data to create a Network
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Network we want to update
     *   }
     * })
     */
    upsert<T extends NetworkUpsertArgs>(args: SelectSubset<T, NetworkUpsertArgs<ExtArgs>>): Prisma__NetworkClient<$Result.GetResult<Prisma.$NetworkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Networks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkCountArgs} args - Arguments to filter Networks to count.
     * @example
     * // Count the number of Networks
     * const count = await prisma.network.count({
     *   where: {
     *     // ... the filter for the Networks we want to count
     *   }
     * })
    **/
    count<T extends NetworkCountArgs>(
      args?: Subset<T, NetworkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NetworkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Network.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NetworkAggregateArgs>(args: Subset<T, NetworkAggregateArgs>): Prisma.PrismaPromise<GetNetworkAggregateType<T>>

    /**
     * Group by Network.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NetworkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NetworkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NetworkGroupByArgs['orderBy'] }
        : { orderBy?: NetworkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NetworkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNetworkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Network model
   */
  readonly fields: NetworkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Network.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NetworkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedToUser<T extends Network$assignedToUserArgs<ExtArgs> = {}>(args?: Subset<T, Network$assignedToUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdBy<T extends Network$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Network$createdByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends Network$providerArgs<ExtArgs> = {}>(args?: Subset<T, Network$providerArgs<ExtArgs>>): Prisma__NetworkProviderClient<$Result.GetResult<Prisma.$NetworkProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Network model
   */
  interface NetworkFieldRefs {
    readonly id: FieldRef<"Network", 'String'>
    readonly name: FieldRef<"Network", 'String'>
    readonly status: FieldRef<"Network", 'NetworkDeviceStatus'>
    readonly location: FieldRef<"Network", 'String'>
    readonly description: FieldRef<"Network", 'String'>
    readonly notes: FieldRef<"Network", 'String'>
    readonly ssid: FieldRef<"Network", 'String'>
    readonly password: FieldRef<"Network", 'String'>
    readonly ip: FieldRef<"Network", 'String'>
    readonly dns: FieldRef<"Network", 'String'>
    readonly gw: FieldRef<"Network", 'String'>
    readonly uploadSpeed: FieldRef<"Network", 'String'>
    readonly downloadSpeed: FieldRef<"Network", 'String'>
    readonly createdAt: FieldRef<"Network", 'DateTime'>
    readonly updatedAt: FieldRef<"Network", 'DateTime'>
    readonly companyId: FieldRef<"Network", 'String'>
    readonly assignedToUserId: FieldRef<"Network", 'String'>
    readonly createdByUserId: FieldRef<"Network", 'String'>
    readonly providerId: FieldRef<"Network", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Network findUnique
   */
  export type NetworkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network findUniqueOrThrow
   */
  export type NetworkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network findFirst
   */
  export type NetworkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Networks.
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Networks.
     */
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Network findFirstOrThrow
   */
  export type NetworkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Network to fetch.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Networks.
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Networks.
     */
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Network findMany
   */
  export type NetworkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter, which Networks to fetch.
     */
    where?: NetworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Networks to fetch.
     */
    orderBy?: NetworkOrderByWithRelationInput | NetworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Networks.
     */
    cursor?: NetworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Networks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Networks.
     */
    skip?: number
    distinct?: NetworkScalarFieldEnum | NetworkScalarFieldEnum[]
  }

  /**
   * Network create
   */
  export type NetworkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * The data needed to create a Network.
     */
    data: XOR<NetworkCreateInput, NetworkUncheckedCreateInput>
  }

  /**
   * Network createMany
   */
  export type NetworkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Networks.
     */
    data: NetworkCreateManyInput | NetworkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Network createManyAndReturn
   */
  export type NetworkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * The data used to create many Networks.
     */
    data: NetworkCreateManyInput | NetworkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Network update
   */
  export type NetworkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * The data needed to update a Network.
     */
    data: XOR<NetworkUpdateInput, NetworkUncheckedUpdateInput>
    /**
     * Choose, which Network to update.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network updateMany
   */
  export type NetworkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Networks.
     */
    data: XOR<NetworkUpdateManyMutationInput, NetworkUncheckedUpdateManyInput>
    /**
     * Filter which Networks to update
     */
    where?: NetworkWhereInput
    /**
     * Limit how many Networks to update.
     */
    limit?: number
  }

  /**
   * Network updateManyAndReturn
   */
  export type NetworkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * The data used to update Networks.
     */
    data: XOR<NetworkUpdateManyMutationInput, NetworkUncheckedUpdateManyInput>
    /**
     * Filter which Networks to update
     */
    where?: NetworkWhereInput
    /**
     * Limit how many Networks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Network upsert
   */
  export type NetworkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * The filter to search for the Network to update in case it exists.
     */
    where: NetworkWhereUniqueInput
    /**
     * In case the Network found by the `where` argument doesn't exist, create a new Network with this data.
     */
    create: XOR<NetworkCreateInput, NetworkUncheckedCreateInput>
    /**
     * In case the Network was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NetworkUpdateInput, NetworkUncheckedUpdateInput>
  }

  /**
   * Network delete
   */
  export type NetworkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
    /**
     * Filter which Network to delete.
     */
    where: NetworkWhereUniqueInput
  }

  /**
   * Network deleteMany
   */
  export type NetworkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Networks to delete
     */
    where?: NetworkWhereInput
    /**
     * Limit how many Networks to delete.
     */
    limit?: number
  }

  /**
   * Network.assignedToUser
   */
  export type Network$assignedToUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Network.createdBy
   */
  export type Network$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Network.provider
   */
  export type Network$providerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NetworkProvider
     */
    select?: NetworkProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NetworkProvider
     */
    omit?: NetworkProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkProviderInclude<ExtArgs> | null
    where?: NetworkProviderWhereInput
  }

  /**
   * Network without action
   */
  export type NetworkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Network
     */
    select?: NetworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Network
     */
    omit?: NetworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NetworkInclude<ExtArgs> | null
  }


  /**
   * Model AnnualSoftwareExpense
   */

  export type AggregateAnnualSoftwareExpense = {
    _count: AnnualSoftwareExpenseCountAggregateOutputType | null
    _avg: AnnualSoftwareExpenseAvgAggregateOutputType | null
    _sum: AnnualSoftwareExpenseSumAggregateOutputType | null
    _min: AnnualSoftwareExpenseMinAggregateOutputType | null
    _max: AnnualSoftwareExpenseMaxAggregateOutputType | null
  }

  export type AnnualSoftwareExpenseAvgAggregateOutputType = {
    annualCost: number | null
    numberOfUsers: number | null
    costPerUser: number | null
  }

  export type AnnualSoftwareExpenseSumAggregateOutputType = {
    annualCost: number | null
    numberOfUsers: number | null
    costPerUser: number | null
  }

  export type AnnualSoftwareExpenseMinAggregateOutputType = {
    id: string | null
    applicationName: string | null
    provider: string | null
    category: $Enums.SoftwareCategory | null
    status: $Enums.ExpenseStatus | null
    annualCost: number | null
    numberOfUsers: number | null
    costPerUser: number | null
    renewalDate: Date | null
    paymentFrequency: $Enums.PaymentFrequency | null
    additionalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnualSoftwareExpenseMaxAggregateOutputType = {
    id: string | null
    applicationName: string | null
    provider: string | null
    category: $Enums.SoftwareCategory | null
    status: $Enums.ExpenseStatus | null
    annualCost: number | null
    numberOfUsers: number | null
    costPerUser: number | null
    renewalDate: Date | null
    paymentFrequency: $Enums.PaymentFrequency | null
    additionalNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnnualSoftwareExpenseCountAggregateOutputType = {
    id: number
    applicationName: number
    provider: number
    category: number
    status: number
    annualCost: number
    numberOfUsers: number
    costPerUser: number
    renewalDate: number
    paymentFrequency: number
    additionalNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnnualSoftwareExpenseAvgAggregateInputType = {
    annualCost?: true
    numberOfUsers?: true
    costPerUser?: true
  }

  export type AnnualSoftwareExpenseSumAggregateInputType = {
    annualCost?: true
    numberOfUsers?: true
    costPerUser?: true
  }

  export type AnnualSoftwareExpenseMinAggregateInputType = {
    id?: true
    applicationName?: true
    provider?: true
    category?: true
    status?: true
    annualCost?: true
    numberOfUsers?: true
    costPerUser?: true
    renewalDate?: true
    paymentFrequency?: true
    additionalNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnualSoftwareExpenseMaxAggregateInputType = {
    id?: true
    applicationName?: true
    provider?: true
    category?: true
    status?: true
    annualCost?: true
    numberOfUsers?: true
    costPerUser?: true
    renewalDate?: true
    paymentFrequency?: true
    additionalNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnnualSoftwareExpenseCountAggregateInputType = {
    id?: true
    applicationName?: true
    provider?: true
    category?: true
    status?: true
    annualCost?: true
    numberOfUsers?: true
    costPerUser?: true
    renewalDate?: true
    paymentFrequency?: true
    additionalNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnnualSoftwareExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnualSoftwareExpense to aggregate.
     */
    where?: AnnualSoftwareExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnualSoftwareExpenses to fetch.
     */
    orderBy?: AnnualSoftwareExpenseOrderByWithRelationInput | AnnualSoftwareExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnnualSoftwareExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnualSoftwareExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnualSoftwareExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnnualSoftwareExpenses
    **/
    _count?: true | AnnualSoftwareExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnnualSoftwareExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnnualSoftwareExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnnualSoftwareExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnnualSoftwareExpenseMaxAggregateInputType
  }

  export type GetAnnualSoftwareExpenseAggregateType<T extends AnnualSoftwareExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateAnnualSoftwareExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnualSoftwareExpense[P]>
      : GetScalarType<T[P], AggregateAnnualSoftwareExpense[P]>
  }




  export type AnnualSoftwareExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnnualSoftwareExpenseWhereInput
    orderBy?: AnnualSoftwareExpenseOrderByWithAggregationInput | AnnualSoftwareExpenseOrderByWithAggregationInput[]
    by: AnnualSoftwareExpenseScalarFieldEnum[] | AnnualSoftwareExpenseScalarFieldEnum
    having?: AnnualSoftwareExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnnualSoftwareExpenseCountAggregateInputType | true
    _avg?: AnnualSoftwareExpenseAvgAggregateInputType
    _sum?: AnnualSoftwareExpenseSumAggregateInputType
    _min?: AnnualSoftwareExpenseMinAggregateInputType
    _max?: AnnualSoftwareExpenseMaxAggregateInputType
  }

  export type AnnualSoftwareExpenseGroupByOutputType = {
    id: string
    applicationName: string
    provider: string
    category: $Enums.SoftwareCategory
    status: $Enums.ExpenseStatus
    annualCost: number
    numberOfUsers: number
    costPerUser: number
    renewalDate: Date
    paymentFrequency: $Enums.PaymentFrequency
    additionalNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AnnualSoftwareExpenseCountAggregateOutputType | null
    _avg: AnnualSoftwareExpenseAvgAggregateOutputType | null
    _sum: AnnualSoftwareExpenseSumAggregateOutputType | null
    _min: AnnualSoftwareExpenseMinAggregateOutputType | null
    _max: AnnualSoftwareExpenseMaxAggregateOutputType | null
  }

  type GetAnnualSoftwareExpenseGroupByPayload<T extends AnnualSoftwareExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnualSoftwareExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnnualSoftwareExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnualSoftwareExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], AnnualSoftwareExpenseGroupByOutputType[P]>
        }
      >
    >


  export type AnnualSoftwareExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationName?: boolean
    provider?: boolean
    category?: boolean
    status?: boolean
    annualCost?: boolean
    numberOfUsers?: boolean
    costPerUser?: boolean
    renewalDate?: boolean
    paymentFrequency?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedPersons?: boolean | AnnualSoftwareExpense$assignedPersonsArgs<ExtArgs>
    _count?: boolean | AnnualSoftwareExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["annualSoftwareExpense"]>

  export type AnnualSoftwareExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationName?: boolean
    provider?: boolean
    category?: boolean
    status?: boolean
    annualCost?: boolean
    numberOfUsers?: boolean
    costPerUser?: boolean
    renewalDate?: boolean
    paymentFrequency?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["annualSoftwareExpense"]>

  export type AnnualSoftwareExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    applicationName?: boolean
    provider?: boolean
    category?: boolean
    status?: boolean
    annualCost?: boolean
    numberOfUsers?: boolean
    costPerUser?: boolean
    renewalDate?: boolean
    paymentFrequency?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["annualSoftwareExpense"]>

  export type AnnualSoftwareExpenseSelectScalar = {
    id?: boolean
    applicationName?: boolean
    provider?: boolean
    category?: boolean
    status?: boolean
    annualCost?: boolean
    numberOfUsers?: boolean
    costPerUser?: boolean
    renewalDate?: boolean
    paymentFrequency?: boolean
    additionalNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnnualSoftwareExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "applicationName" | "provider" | "category" | "status" | "annualCost" | "numberOfUsers" | "costPerUser" | "renewalDate" | "paymentFrequency" | "additionalNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["annualSoftwareExpense"]>
  export type AnnualSoftwareExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedPersons?: boolean | AnnualSoftwareExpense$assignedPersonsArgs<ExtArgs>
    _count?: boolean | AnnualSoftwareExpenseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AnnualSoftwareExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AnnualSoftwareExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AnnualSoftwareExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnnualSoftwareExpense"
    objects: {
      assignedPersons: Prisma.$PersonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      applicationName: string
      provider: string
      category: $Enums.SoftwareCategory
      status: $Enums.ExpenseStatus
      annualCost: number
      numberOfUsers: number
      costPerUser: number
      renewalDate: Date
      paymentFrequency: $Enums.PaymentFrequency
      additionalNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["annualSoftwareExpense"]>
    composites: {}
  }

  type AnnualSoftwareExpenseGetPayload<S extends boolean | null | undefined | AnnualSoftwareExpenseDefaultArgs> = $Result.GetResult<Prisma.$AnnualSoftwareExpensePayload, S>

  type AnnualSoftwareExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AnnualSoftwareExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnnualSoftwareExpenseCountAggregateInputType | true
    }

  export interface AnnualSoftwareExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnnualSoftwareExpense'], meta: { name: 'AnnualSoftwareExpense' } }
    /**
     * Find zero or one AnnualSoftwareExpense that matches the filter.
     * @param {AnnualSoftwareExpenseFindUniqueArgs} args - Arguments to find a AnnualSoftwareExpense
     * @example
     * // Get one AnnualSoftwareExpense
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnualSoftwareExpenseFindUniqueArgs>(args: SelectSubset<T, AnnualSoftwareExpenseFindUniqueArgs<ExtArgs>>): Prisma__AnnualSoftwareExpenseClient<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AnnualSoftwareExpense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnualSoftwareExpenseFindUniqueOrThrowArgs} args - Arguments to find a AnnualSoftwareExpense
     * @example
     * // Get one AnnualSoftwareExpense
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnualSoftwareExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, AnnualSoftwareExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnnualSoftwareExpenseClient<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnnualSoftwareExpense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnualSoftwareExpenseFindFirstArgs} args - Arguments to find a AnnualSoftwareExpense
     * @example
     * // Get one AnnualSoftwareExpense
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnualSoftwareExpenseFindFirstArgs>(args?: SelectSubset<T, AnnualSoftwareExpenseFindFirstArgs<ExtArgs>>): Prisma__AnnualSoftwareExpenseClient<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AnnualSoftwareExpense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnualSoftwareExpenseFindFirstOrThrowArgs} args - Arguments to find a AnnualSoftwareExpense
     * @example
     * // Get one AnnualSoftwareExpense
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnualSoftwareExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, AnnualSoftwareExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnnualSoftwareExpenseClient<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AnnualSoftwareExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnualSoftwareExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnnualSoftwareExpenses
     * const annualSoftwareExpenses = await prisma.annualSoftwareExpense.findMany()
     * 
     * // Get first 10 AnnualSoftwareExpenses
     * const annualSoftwareExpenses = await prisma.annualSoftwareExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const annualSoftwareExpenseWithIdOnly = await prisma.annualSoftwareExpense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnnualSoftwareExpenseFindManyArgs>(args?: SelectSubset<T, AnnualSoftwareExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AnnualSoftwareExpense.
     * @param {AnnualSoftwareExpenseCreateArgs} args - Arguments to create a AnnualSoftwareExpense.
     * @example
     * // Create one AnnualSoftwareExpense
     * const AnnualSoftwareExpense = await prisma.annualSoftwareExpense.create({
     *   data: {
     *     // ... data to create a AnnualSoftwareExpense
     *   }
     * })
     * 
     */
    create<T extends AnnualSoftwareExpenseCreateArgs>(args: SelectSubset<T, AnnualSoftwareExpenseCreateArgs<ExtArgs>>): Prisma__AnnualSoftwareExpenseClient<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AnnualSoftwareExpenses.
     * @param {AnnualSoftwareExpenseCreateManyArgs} args - Arguments to create many AnnualSoftwareExpenses.
     * @example
     * // Create many AnnualSoftwareExpenses
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnnualSoftwareExpenseCreateManyArgs>(args?: SelectSubset<T, AnnualSoftwareExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnnualSoftwareExpenses and returns the data saved in the database.
     * @param {AnnualSoftwareExpenseCreateManyAndReturnArgs} args - Arguments to create many AnnualSoftwareExpenses.
     * @example
     * // Create many AnnualSoftwareExpenses
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnnualSoftwareExpenses and only return the `id`
     * const annualSoftwareExpenseWithIdOnly = await prisma.annualSoftwareExpense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnnualSoftwareExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, AnnualSoftwareExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AnnualSoftwareExpense.
     * @param {AnnualSoftwareExpenseDeleteArgs} args - Arguments to delete one AnnualSoftwareExpense.
     * @example
     * // Delete one AnnualSoftwareExpense
     * const AnnualSoftwareExpense = await prisma.annualSoftwareExpense.delete({
     *   where: {
     *     // ... filter to delete one AnnualSoftwareExpense
     *   }
     * })
     * 
     */
    delete<T extends AnnualSoftwareExpenseDeleteArgs>(args: SelectSubset<T, AnnualSoftwareExpenseDeleteArgs<ExtArgs>>): Prisma__AnnualSoftwareExpenseClient<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AnnualSoftwareExpense.
     * @param {AnnualSoftwareExpenseUpdateArgs} args - Arguments to update one AnnualSoftwareExpense.
     * @example
     * // Update one AnnualSoftwareExpense
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnnualSoftwareExpenseUpdateArgs>(args: SelectSubset<T, AnnualSoftwareExpenseUpdateArgs<ExtArgs>>): Prisma__AnnualSoftwareExpenseClient<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AnnualSoftwareExpenses.
     * @param {AnnualSoftwareExpenseDeleteManyArgs} args - Arguments to filter AnnualSoftwareExpenses to delete.
     * @example
     * // Delete a few AnnualSoftwareExpenses
     * const { count } = await prisma.annualSoftwareExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnnualSoftwareExpenseDeleteManyArgs>(args?: SelectSubset<T, AnnualSoftwareExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnnualSoftwareExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnualSoftwareExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnnualSoftwareExpenses
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnnualSoftwareExpenseUpdateManyArgs>(args: SelectSubset<T, AnnualSoftwareExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnnualSoftwareExpenses and returns the data updated in the database.
     * @param {AnnualSoftwareExpenseUpdateManyAndReturnArgs} args - Arguments to update many AnnualSoftwareExpenses.
     * @example
     * // Update many AnnualSoftwareExpenses
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AnnualSoftwareExpenses and only return the `id`
     * const annualSoftwareExpenseWithIdOnly = await prisma.annualSoftwareExpense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AnnualSoftwareExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, AnnualSoftwareExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AnnualSoftwareExpense.
     * @param {AnnualSoftwareExpenseUpsertArgs} args - Arguments to update or create a AnnualSoftwareExpense.
     * @example
     * // Update or create a AnnualSoftwareExpense
     * const annualSoftwareExpense = await prisma.annualSoftwareExpense.upsert({
     *   create: {
     *     // ... data to create a AnnualSoftwareExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnnualSoftwareExpense we want to update
     *   }
     * })
     */
    upsert<T extends AnnualSoftwareExpenseUpsertArgs>(args: SelectSubset<T, AnnualSoftwareExpenseUpsertArgs<ExtArgs>>): Prisma__AnnualSoftwareExpenseClient<$Result.GetResult<Prisma.$AnnualSoftwareExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AnnualSoftwareExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnualSoftwareExpenseCountArgs} args - Arguments to filter AnnualSoftwareExpenses to count.
     * @example
     * // Count the number of AnnualSoftwareExpenses
     * const count = await prisma.annualSoftwareExpense.count({
     *   where: {
     *     // ... the filter for the AnnualSoftwareExpenses we want to count
     *   }
     * })
    **/
    count<T extends AnnualSoftwareExpenseCountArgs>(
      args?: Subset<T, AnnualSoftwareExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnualSoftwareExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnnualSoftwareExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnualSoftwareExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnnualSoftwareExpenseAggregateArgs>(args: Subset<T, AnnualSoftwareExpenseAggregateArgs>): Prisma.PrismaPromise<GetAnnualSoftwareExpenseAggregateType<T>>

    /**
     * Group by AnnualSoftwareExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnualSoftwareExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnnualSoftwareExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnualSoftwareExpenseGroupByArgs['orderBy'] }
        : { orderBy?: AnnualSoftwareExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnnualSoftwareExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnnualSoftwareExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnnualSoftwareExpense model
   */
  readonly fields: AnnualSoftwareExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnnualSoftwareExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnualSoftwareExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedPersons<T extends AnnualSoftwareExpense$assignedPersonsArgs<ExtArgs> = {}>(args?: Subset<T, AnnualSoftwareExpense$assignedPersonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnnualSoftwareExpense model
   */
  interface AnnualSoftwareExpenseFieldRefs {
    readonly id: FieldRef<"AnnualSoftwareExpense", 'String'>
    readonly applicationName: FieldRef<"AnnualSoftwareExpense", 'String'>
    readonly provider: FieldRef<"AnnualSoftwareExpense", 'String'>
    readonly category: FieldRef<"AnnualSoftwareExpense", 'SoftwareCategory'>
    readonly status: FieldRef<"AnnualSoftwareExpense", 'ExpenseStatus'>
    readonly annualCost: FieldRef<"AnnualSoftwareExpense", 'Float'>
    readonly numberOfUsers: FieldRef<"AnnualSoftwareExpense", 'Int'>
    readonly costPerUser: FieldRef<"AnnualSoftwareExpense", 'Float'>
    readonly renewalDate: FieldRef<"AnnualSoftwareExpense", 'DateTime'>
    readonly paymentFrequency: FieldRef<"AnnualSoftwareExpense", 'PaymentFrequency'>
    readonly additionalNotes: FieldRef<"AnnualSoftwareExpense", 'String'>
    readonly createdAt: FieldRef<"AnnualSoftwareExpense", 'DateTime'>
    readonly updatedAt: FieldRef<"AnnualSoftwareExpense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnnualSoftwareExpense findUnique
   */
  export type AnnualSoftwareExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    /**
     * Filter, which AnnualSoftwareExpense to fetch.
     */
    where: AnnualSoftwareExpenseWhereUniqueInput
  }

  /**
   * AnnualSoftwareExpense findUniqueOrThrow
   */
  export type AnnualSoftwareExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    /**
     * Filter, which AnnualSoftwareExpense to fetch.
     */
    where: AnnualSoftwareExpenseWhereUniqueInput
  }

  /**
   * AnnualSoftwareExpense findFirst
   */
  export type AnnualSoftwareExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    /**
     * Filter, which AnnualSoftwareExpense to fetch.
     */
    where?: AnnualSoftwareExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnualSoftwareExpenses to fetch.
     */
    orderBy?: AnnualSoftwareExpenseOrderByWithRelationInput | AnnualSoftwareExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnualSoftwareExpenses.
     */
    cursor?: AnnualSoftwareExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnualSoftwareExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnualSoftwareExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnualSoftwareExpenses.
     */
    distinct?: AnnualSoftwareExpenseScalarFieldEnum | AnnualSoftwareExpenseScalarFieldEnum[]
  }

  /**
   * AnnualSoftwareExpense findFirstOrThrow
   */
  export type AnnualSoftwareExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    /**
     * Filter, which AnnualSoftwareExpense to fetch.
     */
    where?: AnnualSoftwareExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnualSoftwareExpenses to fetch.
     */
    orderBy?: AnnualSoftwareExpenseOrderByWithRelationInput | AnnualSoftwareExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnnualSoftwareExpenses.
     */
    cursor?: AnnualSoftwareExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnualSoftwareExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnualSoftwareExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnnualSoftwareExpenses.
     */
    distinct?: AnnualSoftwareExpenseScalarFieldEnum | AnnualSoftwareExpenseScalarFieldEnum[]
  }

  /**
   * AnnualSoftwareExpense findMany
   */
  export type AnnualSoftwareExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    /**
     * Filter, which AnnualSoftwareExpenses to fetch.
     */
    where?: AnnualSoftwareExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnnualSoftwareExpenses to fetch.
     */
    orderBy?: AnnualSoftwareExpenseOrderByWithRelationInput | AnnualSoftwareExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnnualSoftwareExpenses.
     */
    cursor?: AnnualSoftwareExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnnualSoftwareExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnnualSoftwareExpenses.
     */
    skip?: number
    distinct?: AnnualSoftwareExpenseScalarFieldEnum | AnnualSoftwareExpenseScalarFieldEnum[]
  }

  /**
   * AnnualSoftwareExpense create
   */
  export type AnnualSoftwareExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a AnnualSoftwareExpense.
     */
    data: XOR<AnnualSoftwareExpenseCreateInput, AnnualSoftwareExpenseUncheckedCreateInput>
  }

  /**
   * AnnualSoftwareExpense createMany
   */
  export type AnnualSoftwareExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnnualSoftwareExpenses.
     */
    data: AnnualSoftwareExpenseCreateManyInput | AnnualSoftwareExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnnualSoftwareExpense createManyAndReturn
   */
  export type AnnualSoftwareExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many AnnualSoftwareExpenses.
     */
    data: AnnualSoftwareExpenseCreateManyInput | AnnualSoftwareExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnnualSoftwareExpense update
   */
  export type AnnualSoftwareExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a AnnualSoftwareExpense.
     */
    data: XOR<AnnualSoftwareExpenseUpdateInput, AnnualSoftwareExpenseUncheckedUpdateInput>
    /**
     * Choose, which AnnualSoftwareExpense to update.
     */
    where: AnnualSoftwareExpenseWhereUniqueInput
  }

  /**
   * AnnualSoftwareExpense updateMany
   */
  export type AnnualSoftwareExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnnualSoftwareExpenses.
     */
    data: XOR<AnnualSoftwareExpenseUpdateManyMutationInput, AnnualSoftwareExpenseUncheckedUpdateManyInput>
    /**
     * Filter which AnnualSoftwareExpenses to update
     */
    where?: AnnualSoftwareExpenseWhereInput
    /**
     * Limit how many AnnualSoftwareExpenses to update.
     */
    limit?: number
  }

  /**
   * AnnualSoftwareExpense updateManyAndReturn
   */
  export type AnnualSoftwareExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * The data used to update AnnualSoftwareExpenses.
     */
    data: XOR<AnnualSoftwareExpenseUpdateManyMutationInput, AnnualSoftwareExpenseUncheckedUpdateManyInput>
    /**
     * Filter which AnnualSoftwareExpenses to update
     */
    where?: AnnualSoftwareExpenseWhereInput
    /**
     * Limit how many AnnualSoftwareExpenses to update.
     */
    limit?: number
  }

  /**
   * AnnualSoftwareExpense upsert
   */
  export type AnnualSoftwareExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the AnnualSoftwareExpense to update in case it exists.
     */
    where: AnnualSoftwareExpenseWhereUniqueInput
    /**
     * In case the AnnualSoftwareExpense found by the `where` argument doesn't exist, create a new AnnualSoftwareExpense with this data.
     */
    create: XOR<AnnualSoftwareExpenseCreateInput, AnnualSoftwareExpenseUncheckedCreateInput>
    /**
     * In case the AnnualSoftwareExpense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnualSoftwareExpenseUpdateInput, AnnualSoftwareExpenseUncheckedUpdateInput>
  }

  /**
   * AnnualSoftwareExpense delete
   */
  export type AnnualSoftwareExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
    /**
     * Filter which AnnualSoftwareExpense to delete.
     */
    where: AnnualSoftwareExpenseWhereUniqueInput
  }

  /**
   * AnnualSoftwareExpense deleteMany
   */
  export type AnnualSoftwareExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnnualSoftwareExpenses to delete
     */
    where?: AnnualSoftwareExpenseWhereInput
    /**
     * Limit how many AnnualSoftwareExpenses to delete.
     */
    limit?: number
  }

  /**
   * AnnualSoftwareExpense.assignedPersons
   */
  export type AnnualSoftwareExpense$assignedPersonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Person
     */
    select?: PersonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Person
     */
    omit?: PersonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonInclude<ExtArgs> | null
    where?: PersonWhereInput
    orderBy?: PersonOrderByWithRelationInput | PersonOrderByWithRelationInput[]
    cursor?: PersonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonScalarFieldEnum | PersonScalarFieldEnum[]
  }

  /**
   * AnnualSoftwareExpense without action
   */
  export type AnnualSoftwareExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnnualSoftwareExpense
     */
    select?: AnnualSoftwareExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AnnualSoftwareExpense
     */
    omit?: AnnualSoftwareExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnualSoftwareExpenseInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TicketScalarFieldEnum: {
    id: 'id',
    ticketNumber: 'ticketNumber',
    title: 'title',
    description: 'description',
    img: 'img',
    comment: 'comment',
    type: 'type',
    priority: 'priority',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    requestDays: 'requestDays',
    approvedDays: 'approvedDays',
    view: 'view',
    sendById: 'sendById',
    sendToId: 'sendToId',
    companyId: 'companyId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    reviewed: 'reviewed'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password: 'password',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserCompanyScalarFieldEnum: {
    userId: 'userId',
    companyId: 'companyId'
  };

  export type UserCompanyScalarFieldEnum = (typeof UserCompanyScalarFieldEnum)[keyof typeof UserCompanyScalarFieldEnum]


  export const PersonScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    fullName: 'fullName',
    contactEmail: 'contactEmail',
    phoneNumber: 'phoneNumber',
    departmentId: 'departmentId',
    position: 'position',
    status: 'status',
    userCode: 'userCode',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type PersonScalarFieldEnum = (typeof PersonScalarFieldEnum)[keyof typeof PersonScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    address: 'address',
    phone: 'phone',
    email: 'email',
    ruc: 'ruc',
    logoUrl: 'logoUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    createdByUserId: 'createdByUserId'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const EquipmentScalarFieldEnum: {
    id: 'id',
    type: 'type',
    brand: 'brand',
    model: 'model',
    serialNumber: 'serialNumber',
    plateNumber: 'plateNumber',
    location: 'location',
    status: 'status',
    acquisitionDate: 'acquisitionDate',
    warrantyDetails: 'warrantyDetails',
    qrCode: 'qrCode',
    invoiceUrl: 'invoiceUrl',
    cost: 'cost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    assignedToUserId: 'assignedToUserId',
    endUser: 'endUser',
    operatingSystem: 'operatingSystem'
  };

  export type EquipmentScalarFieldEnum = (typeof EquipmentScalarFieldEnum)[keyof typeof EquipmentScalarFieldEnum]


  export const MaintenanceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    status: 'status',
    scheduledDate: 'scheduledDate',
    completionDate: 'completionDate',
    cost: 'cost',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    equipmentId: 'equipmentId',
    assignedToUserId: 'assignedToUserId',
    companyId: 'companyId'
  };

  export type MaintenanceScalarFieldEnum = (typeof MaintenanceScalarFieldEnum)[keyof typeof MaintenanceScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    equipmentId: 'equipmentId'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const LicenseScalarFieldEnum: {
    id: 'id',
    softwareName: 'softwareName',
    licenseKey: 'licenseKey',
    provider: 'provider',
    activationDate: 'activationDate',
    expirationDate: 'expirationDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId'
  };

  export type LicenseScalarFieldEnum = (typeof LicenseScalarFieldEnum)[keyof typeof LicenseScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const NetworkProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    providerIp: 'providerIp',
    dnsGateway: 'dnsGateway',
    speed: 'speed',
    cost: 'cost',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    meshDevices: 'meshDevices',
    switchDevices: 'switchDevices',
    companyId: 'companyId'
  };

  export type NetworkProviderScalarFieldEnum = (typeof NetworkProviderScalarFieldEnum)[keyof typeof NetworkProviderScalarFieldEnum]


  export const NetworkScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status',
    location: 'location',
    description: 'description',
    notes: 'notes',
    ssid: 'ssid',
    password: 'password',
    ip: 'ip',
    dns: 'dns',
    gw: 'gw',
    uploadSpeed: 'uploadSpeed',
    downloadSpeed: 'downloadSpeed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    companyId: 'companyId',
    assignedToUserId: 'assignedToUserId',
    createdByUserId: 'createdByUserId',
    providerId: 'providerId'
  };

  export type NetworkScalarFieldEnum = (typeof NetworkScalarFieldEnum)[keyof typeof NetworkScalarFieldEnum]


  export const AnnualSoftwareExpenseScalarFieldEnum: {
    id: 'id',
    applicationName: 'applicationName',
    provider: 'provider',
    category: 'category',
    status: 'status',
    annualCost: 'annualCost',
    numberOfUsers: 'numberOfUsers',
    costPerUser: 'costPerUser',
    renewalDate: 'renewalDate',
    paymentFrequency: 'paymentFrequency',
    additionalNotes: 'additionalNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnnualSoftwareExpenseScalarFieldEnum = (typeof AnnualSoftwareExpenseScalarFieldEnum)[keyof typeof AnnualSoftwareExpenseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'TicketType'
   */
  export type EnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType'>
    


  /**
   * Reference to a field of type 'TicketType[]'
   */
  export type ListEnumTicketTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketType[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'PersonStatus'
   */
  export type EnumPersonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonStatus'>
    


  /**
   * Reference to a field of type 'PersonStatus[]'
   */
  export type ListEnumPersonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PersonStatus[]'>
    


  /**
   * Reference to a field of type 'EquipmentStatus'
   */
  export type EnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus'>
    


  /**
   * Reference to a field of type 'EquipmentStatus[]'
   */
  export type ListEnumEquipmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EquipmentStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'MaintenanceType'
   */
  export type EnumMaintenanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceType'>
    


  /**
   * Reference to a field of type 'MaintenanceType[]'
   */
  export type ListEnumMaintenanceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceType[]'>
    


  /**
   * Reference to a field of type 'MaintenanceStatus'
   */
  export type EnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus'>
    


  /**
   * Reference to a field of type 'MaintenanceStatus[]'
   */
  export type ListEnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus[]'>
    


  /**
   * Reference to a field of type 'NetworkDeviceStatus'
   */
  export type EnumNetworkDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NetworkDeviceStatus'>
    


  /**
   * Reference to a field of type 'NetworkDeviceStatus[]'
   */
  export type ListEnumNetworkDeviceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NetworkDeviceStatus[]'>
    


  /**
   * Reference to a field of type 'SoftwareCategory'
   */
  export type EnumSoftwareCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SoftwareCategory'>
    


  /**
   * Reference to a field of type 'SoftwareCategory[]'
   */
  export type ListEnumSoftwareCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SoftwareCategory[]'>
    


  /**
   * Reference to a field of type 'ExpenseStatus'
   */
  export type EnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus'>
    


  /**
   * Reference to a field of type 'ExpenseStatus[]'
   */
  export type ListEnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PaymentFrequency'
   */
  export type EnumPaymentFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentFrequency'>
    


  /**
   * Reference to a field of type 'PaymentFrequency[]'
   */
  export type ListEnumPaymentFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentFrequency[]'>
    
  /**
   * Deep Input Types
   */


  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    ticketNumber?: IntNullableFilter<"Ticket"> | number | null
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    img?: StringNullableFilter<"Ticket"> | string | null
    comment?: StringNullableFilter<"Ticket"> | string | null
    type?: EnumTicketTypeFilter<"Ticket"> | $Enums.TicketType
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    startDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    requestDays?: IntNullableFilter<"Ticket"> | number | null
    approvedDays?: IntNullableFilter<"Ticket"> | number | null
    view?: BoolNullableFilter<"Ticket"> | boolean | null
    sendById?: StringNullableFilter<"Ticket"> | string | null
    sendToId?: StringNullableFilter<"Ticket"> | string | null
    companyId?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    reviewed?: BoolNullableFilter<"Ticket"> | boolean | null
    sendBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sendTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    ticketNumber?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    img?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    requestDays?: SortOrderInput | SortOrder
    approvedDays?: SortOrderInput | SortOrder
    view?: SortOrderInput | SortOrder
    sendById?: SortOrderInput | SortOrder
    sendToId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewed?: SortOrderInput | SortOrder
    sendBy?: UserOrderByWithRelationInput
    sendTo?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    ticketNumber?: IntNullableFilter<"Ticket"> | number | null
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    img?: StringNullableFilter<"Ticket"> | string | null
    comment?: StringNullableFilter<"Ticket"> | string | null
    type?: EnumTicketTypeFilter<"Ticket"> | $Enums.TicketType
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    startDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    requestDays?: IntNullableFilter<"Ticket"> | number | null
    approvedDays?: IntNullableFilter<"Ticket"> | number | null
    view?: BoolNullableFilter<"Ticket"> | boolean | null
    sendById?: StringNullableFilter<"Ticket"> | string | null
    sendToId?: StringNullableFilter<"Ticket"> | string | null
    companyId?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    reviewed?: BoolNullableFilter<"Ticket"> | boolean | null
    sendBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    sendTo?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyNullableScalarRelationFilter, CompanyWhereInput> | null
  }, "id">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    ticketNumber?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    img?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    requestDays?: SortOrderInput | SortOrder
    approvedDays?: SortOrderInput | SortOrder
    view?: SortOrderInput | SortOrder
    sendById?: SortOrderInput | SortOrder
    sendToId?: SortOrderInput | SortOrder
    companyId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewed?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _avg?: TicketAvgOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
    _sum?: TicketSumOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    ticketNumber?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringWithAggregatesFilter<"Ticket"> | string
    img?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    type?: EnumTicketTypeWithAggregatesFilter<"Ticket"> | $Enums.TicketType
    priority?: EnumTicketPriorityWithAggregatesFilter<"Ticket"> | $Enums.TicketPriority
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    startDate?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Ticket"> | Date | string | null
    requestDays?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    approvedDays?: IntNullableWithAggregatesFilter<"Ticket"> | number | null
    view?: BoolNullableWithAggregatesFilter<"Ticket"> | boolean | null
    sendById?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    sendToId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    companyId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    reviewed?: BoolNullableWithAggregatesFilter<"Ticket"> | boolean | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    companies?: UserCompanyListRelationFilter
    createdCompanies?: CompanyListRelationFilter
    assignedEquipments?: EquipmentListRelationFilter
    assignedMaintenances?: MaintenanceListRelationFilter
    assignedNetworks?: NetworkListRelationFilter
    createdNetworks?: NetworkListRelationFilter
    person?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    ticketsSentBy?: TicketListRelationFilter
    ticketsSentTo?: TicketListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companies?: UserCompanyOrderByRelationAggregateInput
    createdCompanies?: CompanyOrderByRelationAggregateInput
    assignedEquipments?: EquipmentOrderByRelationAggregateInput
    assignedMaintenances?: MaintenanceOrderByRelationAggregateInput
    assignedNetworks?: NetworkOrderByRelationAggregateInput
    createdNetworks?: NetworkOrderByRelationAggregateInput
    person?: PersonOrderByWithRelationInput
    ticketsSentBy?: TicketOrderByRelationAggregateInput
    ticketsSentTo?: TicketOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    companies?: UserCompanyListRelationFilter
    createdCompanies?: CompanyListRelationFilter
    assignedEquipments?: EquipmentListRelationFilter
    assignedMaintenances?: MaintenanceListRelationFilter
    assignedNetworks?: NetworkListRelationFilter
    createdNetworks?: NetworkListRelationFilter
    person?: XOR<PersonNullableScalarRelationFilter, PersonWhereInput> | null
    ticketsSentBy?: TicketListRelationFilter
    ticketsSentTo?: TicketListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserCompanyWhereInput = {
    AND?: UserCompanyWhereInput | UserCompanyWhereInput[]
    OR?: UserCompanyWhereInput[]
    NOT?: UserCompanyWhereInput | UserCompanyWhereInput[]
    userId?: StringFilter<"UserCompany"> | string
    companyId?: StringFilter<"UserCompany"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type UserCompanyOrderByWithRelationInput = {
    userId?: SortOrder
    companyId?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type UserCompanyWhereUniqueInput = Prisma.AtLeast<{
    userId_companyId?: UserCompanyUserIdCompanyIdCompoundUniqueInput
    AND?: UserCompanyWhereInput | UserCompanyWhereInput[]
    OR?: UserCompanyWhereInput[]
    NOT?: UserCompanyWhereInput | UserCompanyWhereInput[]
    userId?: StringFilter<"UserCompany"> | string
    companyId?: StringFilter<"UserCompany"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "userId_companyId">

  export type UserCompanyOrderByWithAggregationInput = {
    userId?: SortOrder
    companyId?: SortOrder
    _count?: UserCompanyCountOrderByAggregateInput
    _max?: UserCompanyMaxOrderByAggregateInput
    _min?: UserCompanyMinOrderByAggregateInput
  }

  export type UserCompanyScalarWhereWithAggregatesInput = {
    AND?: UserCompanyScalarWhereWithAggregatesInput | UserCompanyScalarWhereWithAggregatesInput[]
    OR?: UserCompanyScalarWhereWithAggregatesInput[]
    NOT?: UserCompanyScalarWhereWithAggregatesInput | UserCompanyScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"UserCompany"> | string
    companyId?: StringWithAggregatesFilter<"UserCompany"> | string
  }

  export type PersonWhereInput = {
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    id?: StringFilter<"Person"> | string
    userId?: StringNullableFilter<"Person"> | string | null
    firstName?: StringNullableFilter<"Person"> | string | null
    lastName?: StringNullableFilter<"Person"> | string | null
    fullName?: StringNullableFilter<"Person"> | string | null
    contactEmail?: StringNullableFilter<"Person"> | string | null
    phoneNumber?: StringNullableFilter<"Person"> | string | null
    departmentId?: StringNullableFilter<"Person"> | string | null
    position?: StringNullableFilter<"Person"> | string | null
    status?: EnumPersonStatusFilter<"Person"> | $Enums.PersonStatus
    userCode?: StringFilter<"Person"> | string
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    companyId?: StringNullableFilter<"Person"> | string | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    assignedExpenses?: AnnualSoftwareExpenseListRelationFilter
  }

  export type PersonOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    status?: SortOrder
    userCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    department?: DepartmentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    assignedExpenses?: AnnualSoftwareExpenseOrderByRelationAggregateInput
  }

  export type PersonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    userCode?: string
    AND?: PersonWhereInput | PersonWhereInput[]
    OR?: PersonWhereInput[]
    NOT?: PersonWhereInput | PersonWhereInput[]
    firstName?: StringNullableFilter<"Person"> | string | null
    lastName?: StringNullableFilter<"Person"> | string | null
    fullName?: StringNullableFilter<"Person"> | string | null
    contactEmail?: StringNullableFilter<"Person"> | string | null
    phoneNumber?: StringNullableFilter<"Person"> | string | null
    departmentId?: StringNullableFilter<"Person"> | string | null
    position?: StringNullableFilter<"Person"> | string | null
    status?: EnumPersonStatusFilter<"Person"> | $Enums.PersonStatus
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    companyId?: StringNullableFilter<"Person"> | string | null
    department?: XOR<DepartmentNullableScalarRelationFilter, DepartmentWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    assignedExpenses?: AnnualSoftwareExpenseListRelationFilter
  }, "id" | "userId" | "userCode">

  export type PersonOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    contactEmail?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    status?: SortOrder
    userCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrderInput | SortOrder
    _count?: PersonCountOrderByAggregateInput
    _max?: PersonMaxOrderByAggregateInput
    _min?: PersonMinOrderByAggregateInput
  }

  export type PersonScalarWhereWithAggregatesInput = {
    AND?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    OR?: PersonScalarWhereWithAggregatesInput[]
    NOT?: PersonScalarWhereWithAggregatesInput | PersonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Person"> | string
    userId?: StringNullableWithAggregatesFilter<"Person"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"Person"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"Person"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"Person"> | string | null
    contactEmail?: StringNullableWithAggregatesFilter<"Person"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"Person"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Person"> | string | null
    position?: StringNullableWithAggregatesFilter<"Person"> | string | null
    status?: EnumPersonStatusWithAggregatesFilter<"Person"> | $Enums.PersonStatus
    userCode?: StringWithAggregatesFilter<"Person"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Person"> | Date | string
    companyId?: StringNullableWithAggregatesFilter<"Person"> | string | null
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    code?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    ruc?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    createdByUserId?: StringNullableFilter<"Company"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    departments?: DepartmentListRelationFilter
    documents?: DocumentListRelationFilter
    equipments?: EquipmentListRelationFilter
    licenses?: LicenseListRelationFilter
    maintenances?: MaintenanceListRelationFilter
    networks?: NetworkListRelationFilter
    networkProviders?: NetworkProviderListRelationFilter
    tickets?: TicketListRelationFilter
    users?: UserCompanyListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ruc?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    createdBy?: UserOrderByWithRelationInput
    departments?: DepartmentOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    equipments?: EquipmentOrderByRelationAggregateInput
    licenses?: LicenseOrderByRelationAggregateInput
    maintenances?: MaintenanceOrderByRelationAggregateInput
    networks?: NetworkOrderByRelationAggregateInput
    networkProviders?: NetworkProviderOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    users?: UserCompanyOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    name?: string
    ruc?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    address?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    createdByUserId?: StringNullableFilter<"Company"> | string | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    departments?: DepartmentListRelationFilter
    documents?: DocumentListRelationFilter
    equipments?: EquipmentListRelationFilter
    licenses?: LicenseListRelationFilter
    maintenances?: MaintenanceListRelationFilter
    networks?: NetworkListRelationFilter
    networkProviders?: NetworkProviderListRelationFilter
    tickets?: TicketListRelationFilter
    users?: UserCompanyListRelationFilter
  }, "id" | "code" | "name" | "ruc">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ruc?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    code?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    address?: StringNullableWithAggregatesFilter<"Company"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Company"> | string | null
    email?: StringNullableWithAggregatesFilter<"Company"> | string | null
    ruc?: StringNullableWithAggregatesFilter<"Company"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Company"> | string | null
    isActive?: BoolWithAggregatesFilter<"Company"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    createdByUserId?: StringNullableWithAggregatesFilter<"Company"> | string | null
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    companyId?: StringFilter<"Department"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    persons?: PersonListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
    persons?: PersonOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    companyId?: StringFilter<"Department"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    persons?: PersonListRelationFilter
  }, "id">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    companyId?: StringWithAggregatesFilter<"Department"> | string
  }

  export type EquipmentWhereInput = {
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    id?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    brand?: StringFilter<"Equipment"> | string
    model?: StringFilter<"Equipment"> | string
    serialNumber?: StringFilter<"Equipment"> | string
    plateNumber?: StringNullableFilter<"Equipment"> | string | null
    location?: StringNullableFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    acquisitionDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    warrantyDetails?: StringNullableFilter<"Equipment"> | string | null
    qrCode?: StringNullableFilter<"Equipment"> | string | null
    invoiceUrl?: StringNullableFilter<"Equipment"> | string | null
    cost?: DecimalNullableFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    companyId?: StringFilter<"Equipment"> | string
    assignedToUserId?: StringNullableFilter<"Equipment"> | string | null
    endUser?: StringNullableFilter<"Equipment"> | string | null
    operatingSystem?: StringNullableFilter<"Equipment"> | string | null
    documents?: DocumentListRelationFilter
    assignedToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    maintenances?: MaintenanceListRelationFilter
  }

  export type EquipmentOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    plateNumber?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    acquisitionDate?: SortOrderInput | SortOrder
    warrantyDetails?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    endUser?: SortOrderInput | SortOrder
    operatingSystem?: SortOrderInput | SortOrder
    documents?: DocumentOrderByRelationAggregateInput
    assignedToUser?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    maintenances?: MaintenanceOrderByRelationAggregateInput
  }

  export type EquipmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    serialNumber?: string
    plateNumber?: string
    AND?: EquipmentWhereInput | EquipmentWhereInput[]
    OR?: EquipmentWhereInput[]
    NOT?: EquipmentWhereInput | EquipmentWhereInput[]
    type?: StringFilter<"Equipment"> | string
    brand?: StringFilter<"Equipment"> | string
    model?: StringFilter<"Equipment"> | string
    location?: StringNullableFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    acquisitionDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    warrantyDetails?: StringNullableFilter<"Equipment"> | string | null
    qrCode?: StringNullableFilter<"Equipment"> | string | null
    invoiceUrl?: StringNullableFilter<"Equipment"> | string | null
    cost?: DecimalNullableFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    companyId?: StringFilter<"Equipment"> | string
    assignedToUserId?: StringNullableFilter<"Equipment"> | string | null
    endUser?: StringNullableFilter<"Equipment"> | string | null
    operatingSystem?: StringNullableFilter<"Equipment"> | string | null
    documents?: DocumentListRelationFilter
    assignedToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    maintenances?: MaintenanceListRelationFilter
  }, "id" | "serialNumber" | "plateNumber">

  export type EquipmentOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    plateNumber?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    status?: SortOrder
    acquisitionDate?: SortOrderInput | SortOrder
    warrantyDetails?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    invoiceUrl?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    endUser?: SortOrderInput | SortOrder
    operatingSystem?: SortOrderInput | SortOrder
    _count?: EquipmentCountOrderByAggregateInput
    _avg?: EquipmentAvgOrderByAggregateInput
    _max?: EquipmentMaxOrderByAggregateInput
    _min?: EquipmentMinOrderByAggregateInput
    _sum?: EquipmentSumOrderByAggregateInput
  }

  export type EquipmentScalarWhereWithAggregatesInput = {
    AND?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    OR?: EquipmentScalarWhereWithAggregatesInput[]
    NOT?: EquipmentScalarWhereWithAggregatesInput | EquipmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Equipment"> | string
    type?: StringWithAggregatesFilter<"Equipment"> | string
    brand?: StringWithAggregatesFilter<"Equipment"> | string
    model?: StringWithAggregatesFilter<"Equipment"> | string
    serialNumber?: StringWithAggregatesFilter<"Equipment"> | string
    plateNumber?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    location?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusWithAggregatesFilter<"Equipment"> | $Enums.EquipmentStatus
    acquisitionDate?: DateTimeNullableWithAggregatesFilter<"Equipment"> | Date | string | null
    warrantyDetails?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    invoiceUrl?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    cost?: DecimalNullableWithAggregatesFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Equipment"> | Date | string
    companyId?: StringWithAggregatesFilter<"Equipment"> | string
    assignedToUserId?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    endUser?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
    operatingSystem?: StringNullableWithAggregatesFilter<"Equipment"> | string | null
  }

  export type MaintenanceWhereInput = {
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    id?: StringFilter<"Maintenance"> | string
    title?: StringFilter<"Maintenance"> | string
    description?: StringNullableFilter<"Maintenance"> | string | null
    type?: EnumMaintenanceTypeFilter<"Maintenance"> | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFilter<"Maintenance"> | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFilter<"Maintenance"> | Date | string
    completionDate?: DateTimeNullableFilter<"Maintenance"> | Date | string | null
    cost?: DecimalNullableFilter<"Maintenance"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    equipmentId?: StringFilter<"Maintenance"> | string
    assignedToUserId?: StringNullableFilter<"Maintenance"> | string | null
    companyId?: StringFilter<"Maintenance"> | string
    assignedToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }

  export type MaintenanceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipmentId?: SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    assignedToUser?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type MaintenanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceWhereInput | MaintenanceWhereInput[]
    OR?: MaintenanceWhereInput[]
    NOT?: MaintenanceWhereInput | MaintenanceWhereInput[]
    title?: StringFilter<"Maintenance"> | string
    description?: StringNullableFilter<"Maintenance"> | string | null
    type?: EnumMaintenanceTypeFilter<"Maintenance"> | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFilter<"Maintenance"> | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFilter<"Maintenance"> | Date | string
    completionDate?: DateTimeNullableFilter<"Maintenance"> | Date | string | null
    cost?: DecimalNullableFilter<"Maintenance"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    equipmentId?: StringFilter<"Maintenance"> | string
    assignedToUserId?: StringNullableFilter<"Maintenance"> | string | null
    companyId?: StringFilter<"Maintenance"> | string
    assignedToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    equipment?: XOR<EquipmentScalarRelationFilter, EquipmentWhereInput>
  }, "id">

  export type MaintenanceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completionDate?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipmentId?: SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    companyId?: SortOrder
    _count?: MaintenanceCountOrderByAggregateInput
    _avg?: MaintenanceAvgOrderByAggregateInput
    _max?: MaintenanceMaxOrderByAggregateInput
    _min?: MaintenanceMinOrderByAggregateInput
    _sum?: MaintenanceSumOrderByAggregateInput
  }

  export type MaintenanceScalarWhereWithAggregatesInput = {
    AND?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    OR?: MaintenanceScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceScalarWhereWithAggregatesInput | MaintenanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Maintenance"> | string
    title?: StringWithAggregatesFilter<"Maintenance"> | string
    description?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    type?: EnumMaintenanceTypeWithAggregatesFilter<"Maintenance"> | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusWithAggregatesFilter<"Maintenance"> | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    completionDate?: DateTimeNullableWithAggregatesFilter<"Maintenance"> | Date | string | null
    cost?: DecimalNullableWithAggregatesFilter<"Maintenance"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Maintenance"> | Date | string
    equipmentId?: StringWithAggregatesFilter<"Maintenance"> | string
    assignedToUserId?: StringNullableWithAggregatesFilter<"Maintenance"> | string | null
    companyId?: StringWithAggregatesFilter<"Maintenance"> | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    fileUrl?: StringFilter<"Document"> | string
    fileType?: StringNullableFilter<"Document"> | string | null
    category?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    companyId?: StringFilter<"Document"> | string
    equipmentId?: StringNullableFilter<"Document"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    equipmentId?: SortOrderInput | SortOrder
    company?: CompanyOrderByWithRelationInput
    equipment?: EquipmentOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    fileUrl?: StringFilter<"Document"> | string
    fileType?: StringNullableFilter<"Document"> | string | null
    category?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    companyId?: StringFilter<"Document"> | string
    equipmentId?: StringNullableFilter<"Document"> | string | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    equipment?: XOR<EquipmentNullableScalarRelationFilter, EquipmentWhereInput> | null
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    equipmentId?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    description?: StringNullableWithAggregatesFilter<"Document"> | string | null
    fileUrl?: StringWithAggregatesFilter<"Document"> | string
    fileType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    category?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    companyId?: StringWithAggregatesFilter<"Document"> | string
    equipmentId?: StringNullableWithAggregatesFilter<"Document"> | string | null
  }

  export type LicenseWhereInput = {
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    id?: StringFilter<"License"> | string
    softwareName?: StringFilter<"License"> | string
    licenseKey?: StringFilter<"License"> | string
    provider?: StringNullableFilter<"License"> | string | null
    activationDate?: DateTimeFilter<"License"> | Date | string
    expirationDate?: DateTimeNullableFilter<"License"> | Date | string | null
    notes?: StringNullableFilter<"License"> | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
    companyId?: StringFilter<"License"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type LicenseOrderByWithRelationInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    provider?: SortOrderInput | SortOrder
    activationDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    company?: CompanyOrderByWithRelationInput
  }

  export type LicenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    licenseKey?: string
    AND?: LicenseWhereInput | LicenseWhereInput[]
    OR?: LicenseWhereInput[]
    NOT?: LicenseWhereInput | LicenseWhereInput[]
    softwareName?: StringFilter<"License"> | string
    provider?: StringNullableFilter<"License"> | string | null
    activationDate?: DateTimeFilter<"License"> | Date | string
    expirationDate?: DateTimeNullableFilter<"License"> | Date | string | null
    notes?: StringNullableFilter<"License"> | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
    companyId?: StringFilter<"License"> | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "licenseKey">

  export type LicenseOrderByWithAggregationInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    provider?: SortOrderInput | SortOrder
    activationDate?: SortOrder
    expirationDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    _count?: LicenseCountOrderByAggregateInput
    _max?: LicenseMaxOrderByAggregateInput
    _min?: LicenseMinOrderByAggregateInput
  }

  export type LicenseScalarWhereWithAggregatesInput = {
    AND?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    OR?: LicenseScalarWhereWithAggregatesInput[]
    NOT?: LicenseScalarWhereWithAggregatesInput | LicenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"License"> | string
    softwareName?: StringWithAggregatesFilter<"License"> | string
    licenseKey?: StringWithAggregatesFilter<"License"> | string
    provider?: StringNullableWithAggregatesFilter<"License"> | string | null
    activationDate?: DateTimeWithAggregatesFilter<"License"> | Date | string
    expirationDate?: DateTimeNullableWithAggregatesFilter<"License"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"License"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"License"> | Date | string
    companyId?: StringWithAggregatesFilter<"License"> | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
  }

  export type NetworkProviderWhereInput = {
    AND?: NetworkProviderWhereInput | NetworkProviderWhereInput[]
    OR?: NetworkProviderWhereInput[]
    NOT?: NetworkProviderWhereInput | NetworkProviderWhereInput[]
    id?: StringFilter<"NetworkProvider"> | string
    name?: StringFilter<"NetworkProvider"> | string
    providerIp?: StringNullableFilter<"NetworkProvider"> | string | null
    dnsGateway?: StringNullableFilter<"NetworkProvider"> | string | null
    speed?: StringNullableFilter<"NetworkProvider"> | string | null
    cost?: DecimalNullableFilter<"NetworkProvider"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"NetworkProvider"> | string | null
    createdAt?: DateTimeFilter<"NetworkProvider"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkProvider"> | Date | string
    meshDevices?: StringNullableFilter<"NetworkProvider"> | string | null
    switchDevices?: StringNullableFilter<"NetworkProvider"> | string | null
    companyId?: StringFilter<"NetworkProvider"> | string
    networks?: NetworkListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type NetworkProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    providerIp?: SortOrderInput | SortOrder
    dnsGateway?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meshDevices?: SortOrderInput | SortOrder
    switchDevices?: SortOrderInput | SortOrder
    companyId?: SortOrder
    networks?: NetworkOrderByRelationAggregateInput
    company?: CompanyOrderByWithRelationInput
  }

  export type NetworkProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name_companyId?: NetworkProviderNameCompanyIdCompoundUniqueInput
    AND?: NetworkProviderWhereInput | NetworkProviderWhereInput[]
    OR?: NetworkProviderWhereInput[]
    NOT?: NetworkProviderWhereInput | NetworkProviderWhereInput[]
    name?: StringFilter<"NetworkProvider"> | string
    providerIp?: StringNullableFilter<"NetworkProvider"> | string | null
    dnsGateway?: StringNullableFilter<"NetworkProvider"> | string | null
    speed?: StringNullableFilter<"NetworkProvider"> | string | null
    cost?: DecimalNullableFilter<"NetworkProvider"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"NetworkProvider"> | string | null
    createdAt?: DateTimeFilter<"NetworkProvider"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkProvider"> | Date | string
    meshDevices?: StringNullableFilter<"NetworkProvider"> | string | null
    switchDevices?: StringNullableFilter<"NetworkProvider"> | string | null
    companyId?: StringFilter<"NetworkProvider"> | string
    networks?: NetworkListRelationFilter
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "name_companyId">

  export type NetworkProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    providerIp?: SortOrderInput | SortOrder
    dnsGateway?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    cost?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meshDevices?: SortOrderInput | SortOrder
    switchDevices?: SortOrderInput | SortOrder
    companyId?: SortOrder
    _count?: NetworkProviderCountOrderByAggregateInput
    _avg?: NetworkProviderAvgOrderByAggregateInput
    _max?: NetworkProviderMaxOrderByAggregateInput
    _min?: NetworkProviderMinOrderByAggregateInput
    _sum?: NetworkProviderSumOrderByAggregateInput
  }

  export type NetworkProviderScalarWhereWithAggregatesInput = {
    AND?: NetworkProviderScalarWhereWithAggregatesInput | NetworkProviderScalarWhereWithAggregatesInput[]
    OR?: NetworkProviderScalarWhereWithAggregatesInput[]
    NOT?: NetworkProviderScalarWhereWithAggregatesInput | NetworkProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NetworkProvider"> | string
    name?: StringWithAggregatesFilter<"NetworkProvider"> | string
    providerIp?: StringNullableWithAggregatesFilter<"NetworkProvider"> | string | null
    dnsGateway?: StringNullableWithAggregatesFilter<"NetworkProvider"> | string | null
    speed?: StringNullableWithAggregatesFilter<"NetworkProvider"> | string | null
    cost?: DecimalNullableWithAggregatesFilter<"NetworkProvider"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"NetworkProvider"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NetworkProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NetworkProvider"> | Date | string
    meshDevices?: StringNullableWithAggregatesFilter<"NetworkProvider"> | string | null
    switchDevices?: StringNullableWithAggregatesFilter<"NetworkProvider"> | string | null
    companyId?: StringWithAggregatesFilter<"NetworkProvider"> | string
  }

  export type NetworkWhereInput = {
    AND?: NetworkWhereInput | NetworkWhereInput[]
    OR?: NetworkWhereInput[]
    NOT?: NetworkWhereInput | NetworkWhereInput[]
    id?: StringFilter<"Network"> | string
    name?: StringFilter<"Network"> | string
    status?: EnumNetworkDeviceStatusFilter<"Network"> | $Enums.NetworkDeviceStatus
    location?: StringNullableFilter<"Network"> | string | null
    description?: StringNullableFilter<"Network"> | string | null
    notes?: StringNullableFilter<"Network"> | string | null
    ssid?: StringNullableFilter<"Network"> | string | null
    password?: StringNullableFilter<"Network"> | string | null
    ip?: StringNullableFilter<"Network"> | string | null
    dns?: StringNullableFilter<"Network"> | string | null
    gw?: StringNullableFilter<"Network"> | string | null
    uploadSpeed?: StringNullableFilter<"Network"> | string | null
    downloadSpeed?: StringNullableFilter<"Network"> | string | null
    createdAt?: DateTimeFilter<"Network"> | Date | string
    updatedAt?: DateTimeFilter<"Network"> | Date | string
    companyId?: StringFilter<"Network"> | string
    assignedToUserId?: StringNullableFilter<"Network"> | string | null
    createdByUserId?: StringNullableFilter<"Network"> | string | null
    providerId?: StringNullableFilter<"Network"> | string | null
    assignedToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    provider?: XOR<NetworkProviderNullableScalarRelationFilter, NetworkProviderWhereInput> | null
  }

  export type NetworkOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ssid?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    dns?: SortOrderInput | SortOrder
    gw?: SortOrderInput | SortOrder
    uploadSpeed?: SortOrderInput | SortOrder
    downloadSpeed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    assignedToUser?: UserOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    provider?: NetworkProviderOrderByWithRelationInput
  }

  export type NetworkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NetworkWhereInput | NetworkWhereInput[]
    OR?: NetworkWhereInput[]
    NOT?: NetworkWhereInput | NetworkWhereInput[]
    name?: StringFilter<"Network"> | string
    status?: EnumNetworkDeviceStatusFilter<"Network"> | $Enums.NetworkDeviceStatus
    location?: StringNullableFilter<"Network"> | string | null
    description?: StringNullableFilter<"Network"> | string | null
    notes?: StringNullableFilter<"Network"> | string | null
    ssid?: StringNullableFilter<"Network"> | string | null
    password?: StringNullableFilter<"Network"> | string | null
    ip?: StringNullableFilter<"Network"> | string | null
    dns?: StringNullableFilter<"Network"> | string | null
    gw?: StringNullableFilter<"Network"> | string | null
    uploadSpeed?: StringNullableFilter<"Network"> | string | null
    downloadSpeed?: StringNullableFilter<"Network"> | string | null
    createdAt?: DateTimeFilter<"Network"> | Date | string
    updatedAt?: DateTimeFilter<"Network"> | Date | string
    companyId?: StringFilter<"Network"> | string
    assignedToUserId?: StringNullableFilter<"Network"> | string | null
    createdByUserId?: StringNullableFilter<"Network"> | string | null
    providerId?: StringNullableFilter<"Network"> | string | null
    assignedToUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    createdBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    provider?: XOR<NetworkProviderNullableScalarRelationFilter, NetworkProviderWhereInput> | null
  }, "id">

  export type NetworkOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    ssid?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    dns?: SortOrderInput | SortOrder
    gw?: SortOrderInput | SortOrder
    uploadSpeed?: SortOrderInput | SortOrder
    downloadSpeed?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrderInput | SortOrder
    createdByUserId?: SortOrderInput | SortOrder
    providerId?: SortOrderInput | SortOrder
    _count?: NetworkCountOrderByAggregateInput
    _max?: NetworkMaxOrderByAggregateInput
    _min?: NetworkMinOrderByAggregateInput
  }

  export type NetworkScalarWhereWithAggregatesInput = {
    AND?: NetworkScalarWhereWithAggregatesInput | NetworkScalarWhereWithAggregatesInput[]
    OR?: NetworkScalarWhereWithAggregatesInput[]
    NOT?: NetworkScalarWhereWithAggregatesInput | NetworkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Network"> | string
    name?: StringWithAggregatesFilter<"Network"> | string
    status?: EnumNetworkDeviceStatusWithAggregatesFilter<"Network"> | $Enums.NetworkDeviceStatus
    location?: StringNullableWithAggregatesFilter<"Network"> | string | null
    description?: StringNullableWithAggregatesFilter<"Network"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Network"> | string | null
    ssid?: StringNullableWithAggregatesFilter<"Network"> | string | null
    password?: StringNullableWithAggregatesFilter<"Network"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Network"> | string | null
    dns?: StringNullableWithAggregatesFilter<"Network"> | string | null
    gw?: StringNullableWithAggregatesFilter<"Network"> | string | null
    uploadSpeed?: StringNullableWithAggregatesFilter<"Network"> | string | null
    downloadSpeed?: StringNullableWithAggregatesFilter<"Network"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Network"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Network"> | Date | string
    companyId?: StringWithAggregatesFilter<"Network"> | string
    assignedToUserId?: StringNullableWithAggregatesFilter<"Network"> | string | null
    createdByUserId?: StringNullableWithAggregatesFilter<"Network"> | string | null
    providerId?: StringNullableWithAggregatesFilter<"Network"> | string | null
  }

  export type AnnualSoftwareExpenseWhereInput = {
    AND?: AnnualSoftwareExpenseWhereInput | AnnualSoftwareExpenseWhereInput[]
    OR?: AnnualSoftwareExpenseWhereInput[]
    NOT?: AnnualSoftwareExpenseWhereInput | AnnualSoftwareExpenseWhereInput[]
    id?: StringFilter<"AnnualSoftwareExpense"> | string
    applicationName?: StringFilter<"AnnualSoftwareExpense"> | string
    provider?: StringFilter<"AnnualSoftwareExpense"> | string
    category?: EnumSoftwareCategoryFilter<"AnnualSoftwareExpense"> | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFilter<"AnnualSoftwareExpense"> | $Enums.ExpenseStatus
    annualCost?: FloatFilter<"AnnualSoftwareExpense"> | number
    numberOfUsers?: IntFilter<"AnnualSoftwareExpense"> | number
    costPerUser?: FloatFilter<"AnnualSoftwareExpense"> | number
    renewalDate?: DateTimeFilter<"AnnualSoftwareExpense"> | Date | string
    paymentFrequency?: EnumPaymentFrequencyFilter<"AnnualSoftwareExpense"> | $Enums.PaymentFrequency
    additionalNotes?: StringNullableFilter<"AnnualSoftwareExpense"> | string | null
    createdAt?: DateTimeFilter<"AnnualSoftwareExpense"> | Date | string
    updatedAt?: DateTimeFilter<"AnnualSoftwareExpense"> | Date | string
    assignedPersons?: PersonListRelationFilter
  }

  export type AnnualSoftwareExpenseOrderByWithRelationInput = {
    id?: SortOrder
    applicationName?: SortOrder
    provider?: SortOrder
    category?: SortOrder
    status?: SortOrder
    annualCost?: SortOrder
    numberOfUsers?: SortOrder
    costPerUser?: SortOrder
    renewalDate?: SortOrder
    paymentFrequency?: SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedPersons?: PersonOrderByRelationAggregateInput
  }

  export type AnnualSoftwareExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnnualSoftwareExpenseWhereInput | AnnualSoftwareExpenseWhereInput[]
    OR?: AnnualSoftwareExpenseWhereInput[]
    NOT?: AnnualSoftwareExpenseWhereInput | AnnualSoftwareExpenseWhereInput[]
    applicationName?: StringFilter<"AnnualSoftwareExpense"> | string
    provider?: StringFilter<"AnnualSoftwareExpense"> | string
    category?: EnumSoftwareCategoryFilter<"AnnualSoftwareExpense"> | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFilter<"AnnualSoftwareExpense"> | $Enums.ExpenseStatus
    annualCost?: FloatFilter<"AnnualSoftwareExpense"> | number
    numberOfUsers?: IntFilter<"AnnualSoftwareExpense"> | number
    costPerUser?: FloatFilter<"AnnualSoftwareExpense"> | number
    renewalDate?: DateTimeFilter<"AnnualSoftwareExpense"> | Date | string
    paymentFrequency?: EnumPaymentFrequencyFilter<"AnnualSoftwareExpense"> | $Enums.PaymentFrequency
    additionalNotes?: StringNullableFilter<"AnnualSoftwareExpense"> | string | null
    createdAt?: DateTimeFilter<"AnnualSoftwareExpense"> | Date | string
    updatedAt?: DateTimeFilter<"AnnualSoftwareExpense"> | Date | string
    assignedPersons?: PersonListRelationFilter
  }, "id">

  export type AnnualSoftwareExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    applicationName?: SortOrder
    provider?: SortOrder
    category?: SortOrder
    status?: SortOrder
    annualCost?: SortOrder
    numberOfUsers?: SortOrder
    costPerUser?: SortOrder
    renewalDate?: SortOrder
    paymentFrequency?: SortOrder
    additionalNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnnualSoftwareExpenseCountOrderByAggregateInput
    _avg?: AnnualSoftwareExpenseAvgOrderByAggregateInput
    _max?: AnnualSoftwareExpenseMaxOrderByAggregateInput
    _min?: AnnualSoftwareExpenseMinOrderByAggregateInput
    _sum?: AnnualSoftwareExpenseSumOrderByAggregateInput
  }

  export type AnnualSoftwareExpenseScalarWhereWithAggregatesInput = {
    AND?: AnnualSoftwareExpenseScalarWhereWithAggregatesInput | AnnualSoftwareExpenseScalarWhereWithAggregatesInput[]
    OR?: AnnualSoftwareExpenseScalarWhereWithAggregatesInput[]
    NOT?: AnnualSoftwareExpenseScalarWhereWithAggregatesInput | AnnualSoftwareExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnnualSoftwareExpense"> | string
    applicationName?: StringWithAggregatesFilter<"AnnualSoftwareExpense"> | string
    provider?: StringWithAggregatesFilter<"AnnualSoftwareExpense"> | string
    category?: EnumSoftwareCategoryWithAggregatesFilter<"AnnualSoftwareExpense"> | $Enums.SoftwareCategory
    status?: EnumExpenseStatusWithAggregatesFilter<"AnnualSoftwareExpense"> | $Enums.ExpenseStatus
    annualCost?: FloatWithAggregatesFilter<"AnnualSoftwareExpense"> | number
    numberOfUsers?: IntWithAggregatesFilter<"AnnualSoftwareExpense"> | number
    costPerUser?: FloatWithAggregatesFilter<"AnnualSoftwareExpense"> | number
    renewalDate?: DateTimeWithAggregatesFilter<"AnnualSoftwareExpense"> | Date | string
    paymentFrequency?: EnumPaymentFrequencyWithAggregatesFilter<"AnnualSoftwareExpense"> | $Enums.PaymentFrequency
    additionalNotes?: StringNullableWithAggregatesFilter<"AnnualSoftwareExpense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AnnualSoftwareExpense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnnualSoftwareExpense"> | Date | string
  }

  export type TicketCreateInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
    sendBy?: UserCreateNestedOneWithoutTicketsSentByInput
    sendTo?: UserCreateNestedOneWithoutTicketsSentToInput
    company?: CompanyCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    sendById?: string | null
    sendToId?: string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendBy?: UserUpdateOneWithoutTicketsSentByNestedInput
    sendTo?: UserUpdateOneWithoutTicketsSentToNestedInput
    company?: CompanyUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendById?: NullableStringFieldUpdateOperationsInput | string | null
    sendToId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketCreateManyInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    sendById?: string | null
    sendToId?: string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendById?: NullableStringFieldUpdateOperationsInput | string | null
    sendToId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkCreateNestedManyWithoutCreatedByInput
    person?: PersonCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketCreateNestedManyWithoutSendToInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyUncheckedCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkUncheckedCreateNestedManyWithoutCreatedByInput
    person?: PersonUncheckedCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketUncheckedCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketUncheckedCreateNestedManyWithoutSendToInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUpdateManyWithoutCreatedByNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUpdateManyWithoutSendToNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUncheckedUpdateManyWithoutCreatedByNestedInput
    person?: PersonUncheckedUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUncheckedUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUncheckedUpdateManyWithoutSendToNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCompanyCreateInput = {
    user: UserCreateNestedOneWithoutCompaniesInput
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type UserCompanyUncheckedCreateInput = {
    userId: string
    companyId: string
  }

  export type UserCompanyUpdateInput = {
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserCompanyUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCompanyCreateManyInput = {
    userId: string
    companyId: string
  }

  export type UserCompanyUpdateManyMutationInput = {

  }

  export type UserCompanyUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonCreateInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    department?: DepartmentCreateNestedOneWithoutPersonsInput
    user?: UserCreateNestedOneWithoutPersonInput
    assignedExpenses?: AnnualSoftwareExpenseCreateNestedManyWithoutAssignedPersonsInput
  }

  export type PersonUncheckedCreateInput = {
    id?: string
    userId?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    departmentId?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    assignedExpenses?: AnnualSoftwareExpenseUncheckedCreateNestedManyWithoutAssignedPersonsInput
  }

  export type PersonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutPersonsNestedInput
    user?: UserUpdateOneWithoutPersonNestedInput
    assignedExpenses?: AnnualSoftwareExpenseUpdateManyWithoutAssignedPersonsNestedInput
  }

  export type PersonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedExpenses?: AnnualSoftwareExpenseUncheckedUpdateManyWithoutAssignedPersonsNestedInput
  }

  export type PersonCreateManyInput = {
    id?: string
    userId?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    departmentId?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type PersonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CompanyCreateInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDepartmentsInput
    persons?: PersonCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    persons?: PersonUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDepartmentsNestedInput
    persons?: PersonUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    persons?: PersonUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type EquipmentCreateInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endUser?: string | null
    operatingSystem?: string | null
    documents?: DocumentCreateNestedManyWithoutEquipmentInput
    assignedToUser?: UserCreateNestedOneWithoutAssignedEquipmentsInput
    company: CompanyCreateNestedOneWithoutEquipmentsInput
    maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    endUser?: string | null
    operatingSystem?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutEquipmentInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUpdateManyWithoutEquipmentNestedInput
    assignedToUser?: UserUpdateOneWithoutAssignedEquipmentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEquipmentsNestedInput
    maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutEquipmentNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentCreateManyInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    endUser?: string | null
    operatingSystem?: string | null
  }

  export type EquipmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUser?: UserCreateNestedOneWithoutAssignedMaintenancesInput
    company: CompanyCreateNestedOneWithoutMaintenancesInput
    equipment: EquipmentCreateNestedOneWithoutMaintenancesInput
  }

  export type MaintenanceUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentId: string
    assignedToUserId?: string | null
    companyId: string
  }

  export type MaintenanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUser?: UserUpdateOneWithoutAssignedMaintenancesNestedInput
    company?: CompanyUpdateOneRequiredWithoutMaintenancesNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutMaintenancesNestedInput
  }

  export type MaintenanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentId: string
    assignedToUserId?: string | null
    companyId: string
  }

  export type MaintenanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentsInput
    equipment?: EquipmentCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    equipmentId?: string | null
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
    equipment?: EquipmentUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    equipmentId?: string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LicenseCreateInput = {
    id?: string
    softwareName: string
    licenseKey: string
    provider?: string | null
    activationDate: Date | string
    expirationDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutLicensesInput
  }

  export type LicenseUncheckedCreateInput = {
    id?: string
    softwareName: string
    licenseKey: string
    provider?: string | null
    activationDate: Date | string
    expirationDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type LicenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutLicensesNestedInput
  }

  export type LicenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type LicenseCreateManyInput = {
    id?: string
    softwareName: string
    licenseKey: string
    provider?: string | null
    activationDate: Date | string
    expirationDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type LicenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkProviderCreateInput = {
    id?: string
    name: string
    providerIp?: string | null
    dnsGateway?: string | null
    speed?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meshDevices?: string | null
    switchDevices?: string | null
    networks?: NetworkCreateNestedManyWithoutProviderInput
    company: CompanyCreateNestedOneWithoutNetworkProvidersInput
  }

  export type NetworkProviderUncheckedCreateInput = {
    id?: string
    name: string
    providerIp?: string | null
    dnsGateway?: string | null
    speed?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meshDevices?: string | null
    switchDevices?: string | null
    companyId: string
    networks?: NetworkUncheckedCreateNestedManyWithoutProviderInput
  }

  export type NetworkProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerIp?: NullableStringFieldUpdateOperationsInput | string | null
    dnsGateway?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meshDevices?: NullableStringFieldUpdateOperationsInput | string | null
    switchDevices?: NullableStringFieldUpdateOperationsInput | string | null
    networks?: NetworkUpdateManyWithoutProviderNestedInput
    company?: CompanyUpdateOneRequiredWithoutNetworkProvidersNestedInput
  }

  export type NetworkProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerIp?: NullableStringFieldUpdateOperationsInput | string | null
    dnsGateway?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meshDevices?: NullableStringFieldUpdateOperationsInput | string | null
    switchDevices?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
    networks?: NetworkUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type NetworkProviderCreateManyInput = {
    id?: string
    name: string
    providerIp?: string | null
    dnsGateway?: string | null
    speed?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meshDevices?: string | null
    switchDevices?: string | null
    companyId: string
  }

  export type NetworkProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerIp?: NullableStringFieldUpdateOperationsInput | string | null
    dnsGateway?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meshDevices?: NullableStringFieldUpdateOperationsInput | string | null
    switchDevices?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NetworkProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerIp?: NullableStringFieldUpdateOperationsInput | string | null
    dnsGateway?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meshDevices?: NullableStringFieldUpdateOperationsInput | string | null
    switchDevices?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkCreateInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUser?: UserCreateNestedOneWithoutAssignedNetworksInput
    createdBy?: UserCreateNestedOneWithoutCreatedNetworksInput
    company: CompanyCreateNestedOneWithoutNetworksInput
    provider?: NetworkProviderCreateNestedOneWithoutNetworksInput
  }

  export type NetworkUncheckedCreateInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    createdByUserId?: string | null
    providerId?: string | null
  }

  export type NetworkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUser?: UserUpdateOneWithoutAssignedNetworksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedNetworksNestedInput
    company?: CompanyUpdateOneRequiredWithoutNetworksNestedInput
    provider?: NetworkProviderUpdateOneWithoutNetworksNestedInput
  }

  export type NetworkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NetworkCreateManyInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    createdByUserId?: string | null
    providerId?: string | null
  }

  export type NetworkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NetworkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AnnualSoftwareExpenseCreateInput = {
    id?: string
    applicationName: string
    provider: string
    category: $Enums.SoftwareCategory
    status: $Enums.ExpenseStatus
    annualCost: number
    numberOfUsers: number
    costPerUser: number
    renewalDate: Date | string
    paymentFrequency: $Enums.PaymentFrequency
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedPersons?: PersonCreateNestedManyWithoutAssignedExpensesInput
  }

  export type AnnualSoftwareExpenseUncheckedCreateInput = {
    id?: string
    applicationName: string
    provider: string
    category: $Enums.SoftwareCategory
    status: $Enums.ExpenseStatus
    annualCost: number
    numberOfUsers: number
    costPerUser: number
    renewalDate: Date | string
    paymentFrequency: $Enums.PaymentFrequency
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedPersons?: PersonUncheckedCreateNestedManyWithoutAssignedExpensesInput
  }

  export type AnnualSoftwareExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    category?: EnumSoftwareCategoryFieldUpdateOperationsInput | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    annualCost?: FloatFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    costPerUser?: FloatFieldUpdateOperationsInput | number
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: EnumPaymentFrequencyFieldUpdateOperationsInput | $Enums.PaymentFrequency
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedPersons?: PersonUpdateManyWithoutAssignedExpensesNestedInput
  }

  export type AnnualSoftwareExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    category?: EnumSoftwareCategoryFieldUpdateOperationsInput | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    annualCost?: FloatFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    costPerUser?: FloatFieldUpdateOperationsInput | number
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: EnumPaymentFrequencyFieldUpdateOperationsInput | $Enums.PaymentFrequency
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedPersons?: PersonUncheckedUpdateManyWithoutAssignedExpensesNestedInput
  }

  export type AnnualSoftwareExpenseCreateManyInput = {
    id?: string
    applicationName: string
    provider: string
    category: $Enums.SoftwareCategory
    status: $Enums.ExpenseStatus
    annualCost: number
    numberOfUsers: number
    costPerUser: number
    renewalDate: Date | string
    paymentFrequency: $Enums.PaymentFrequency
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnualSoftwareExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    category?: EnumSoftwareCategoryFieldUpdateOperationsInput | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    annualCost?: FloatFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    costPerUser?: FloatFieldUpdateOperationsInput | number
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: EnumPaymentFrequencyFieldUpdateOperationsInput | $Enums.PaymentFrequency
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnualSoftwareExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    category?: EnumSoftwareCategoryFieldUpdateOperationsInput | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    annualCost?: FloatFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    costPerUser?: FloatFieldUpdateOperationsInput | number
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: EnumPaymentFrequencyFieldUpdateOperationsInput | $Enums.PaymentFrequency
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTicketTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeFilter<$PrismaModel> | $Enums.TicketType
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CompanyNullableScalarRelationFilter = {
    is?: CompanyWhereInput | null
    isNot?: CompanyWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    img?: SortOrder
    comment?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    requestDays?: SortOrder
    approvedDays?: SortOrder
    view?: SortOrder
    sendById?: SortOrder
    sendToId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewed?: SortOrder
  }

  export type TicketAvgOrderByAggregateInput = {
    ticketNumber?: SortOrder
    requestDays?: SortOrder
    approvedDays?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    img?: SortOrder
    comment?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    requestDays?: SortOrder
    approvedDays?: SortOrder
    view?: SortOrder
    sendById?: SortOrder
    sendToId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewed?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    ticketNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    img?: SortOrder
    comment?: SortOrder
    type?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    requestDays?: SortOrder
    approvedDays?: SortOrder
    view?: SortOrder
    sendById?: SortOrder
    sendToId?: SortOrder
    companyId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reviewed?: SortOrder
  }

  export type TicketSumOrderByAggregateInput = {
    ticketNumber?: SortOrder
    requestDays?: SortOrder
    approvedDays?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTicketTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel> | $Enums.TicketType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserCompanyListRelationFilter = {
    every?: UserCompanyWhereInput
    some?: UserCompanyWhereInput
    none?: UserCompanyWhereInput
  }

  export type CompanyListRelationFilter = {
    every?: CompanyWhereInput
    some?: CompanyWhereInput
    none?: CompanyWhereInput
  }

  export type EquipmentListRelationFilter = {
    every?: EquipmentWhereInput
    some?: EquipmentWhereInput
    none?: EquipmentWhereInput
  }

  export type MaintenanceListRelationFilter = {
    every?: MaintenanceWhereInput
    some?: MaintenanceWhereInput
    none?: MaintenanceWhereInput
  }

  export type NetworkListRelationFilter = {
    every?: NetworkWhereInput
    some?: NetworkWhereInput
    none?: NetworkWhereInput
  }

  export type PersonNullableScalarRelationFilter = {
    is?: PersonWhereInput | null
    isNot?: PersonWhereInput | null
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type UserCompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EquipmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NetworkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type UserCompanyUserIdCompanyIdCompoundUniqueInput = {
    userId: string
    companyId: string
  }

  export type UserCompanyCountOrderByAggregateInput = {
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type UserCompanyMaxOrderByAggregateInput = {
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type UserCompanyMinOrderByAggregateInput = {
    userId?: SortOrder
    companyId?: SortOrder
  }

  export type EnumPersonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonStatus | EnumPersonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PersonStatus[] | ListEnumPersonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonStatus[] | ListEnumPersonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonStatusFilter<$PrismaModel> | $Enums.PersonStatus
  }

  export type DepartmentNullableScalarRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type AnnualSoftwareExpenseListRelationFilter = {
    every?: AnnualSoftwareExpenseWhereInput
    some?: AnnualSoftwareExpenseWhereInput
    none?: AnnualSoftwareExpenseWhereInput
  }

  export type AnnualSoftwareExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    contactEmail?: SortOrder
    phoneNumber?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    status?: SortOrder
    userCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PersonMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    contactEmail?: SortOrder
    phoneNumber?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    status?: SortOrder
    userCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type PersonMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    contactEmail?: SortOrder
    phoneNumber?: SortOrder
    departmentId?: SortOrder
    position?: SortOrder
    status?: SortOrder
    userCode?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type EnumPersonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonStatus | EnumPersonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PersonStatus[] | ListEnumPersonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonStatus[] | ListEnumPersonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonStatusWithAggregatesFilter<$PrismaModel> | $Enums.PersonStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonStatusFilter<$PrismaModel>
    _max?: NestedEnumPersonStatusFilter<$PrismaModel>
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type LicenseListRelationFilter = {
    every?: LicenseWhereInput
    some?: LicenseWhereInput
    none?: LicenseWhereInput
  }

  export type NetworkProviderListRelationFilter = {
    every?: NetworkProviderWhereInput
    some?: NetworkProviderWhereInput
    none?: NetworkProviderWhereInput
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LicenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NetworkProviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    ruc?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByUserId?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    ruc?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByUserId?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    ruc?: SortOrder
    logoUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdByUserId?: SortOrder
  }

  export type PersonListRelationFilter = {
    every?: PersonWhereInput
    some?: PersonWhereInput
    none?: PersonWhereInput
  }

  export type PersonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type EnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EquipmentCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    plateNumber?: SortOrder
    location?: SortOrder
    status?: SortOrder
    acquisitionDate?: SortOrder
    warrantyDetails?: SortOrder
    qrCode?: SortOrder
    invoiceUrl?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrder
    endUser?: SortOrder
    operatingSystem?: SortOrder
  }

  export type EquipmentAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type EquipmentMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    plateNumber?: SortOrder
    location?: SortOrder
    status?: SortOrder
    acquisitionDate?: SortOrder
    warrantyDetails?: SortOrder
    qrCode?: SortOrder
    invoiceUrl?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrder
    endUser?: SortOrder
    operatingSystem?: SortOrder
  }

  export type EquipmentMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    serialNumber?: SortOrder
    plateNumber?: SortOrder
    location?: SortOrder
    status?: SortOrder
    acquisitionDate?: SortOrder
    warrantyDetails?: SortOrder
    qrCode?: SortOrder
    invoiceUrl?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrder
    endUser?: SortOrder
    operatingSystem?: SortOrder
  }

  export type EquipmentSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type EnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumMaintenanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeFilter<$PrismaModel> | $Enums.MaintenanceType
  }

  export type EnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type EquipmentScalarRelationFilter = {
    is?: EquipmentWhereInput
    isNot?: EquipmentWhereInput
  }

  export type MaintenanceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completionDate?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipmentId?: SortOrder
    assignedToUserId?: SortOrder
    companyId?: SortOrder
  }

  export type MaintenanceAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type MaintenanceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completionDate?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipmentId?: SortOrder
    assignedToUserId?: SortOrder
    companyId?: SortOrder
  }

  export type MaintenanceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    status?: SortOrder
    scheduledDate?: SortOrder
    completionDate?: SortOrder
    cost?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    equipmentId?: SortOrder
    assignedToUserId?: SortOrder
    companyId?: SortOrder
  }

  export type MaintenanceSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type EnumMaintenanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
  }

  export type EnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type EquipmentNullableScalarRelationFilter = {
    is?: EquipmentWhereInput | null
    isNot?: EquipmentWhereInput | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    equipmentId?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    equipmentId?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    equipmentId?: SortOrder
  }

  export type LicenseCountOrderByAggregateInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    provider?: SortOrder
    activationDate?: SortOrder
    expirationDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type LicenseMaxOrderByAggregateInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    provider?: SortOrder
    activationDate?: SortOrder
    expirationDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type LicenseMinOrderByAggregateInput = {
    id?: SortOrder
    softwareName?: SortOrder
    licenseKey?: SortOrder
    provider?: SortOrder
    activationDate?: SortOrder
    expirationDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NetworkProviderNameCompanyIdCompoundUniqueInput = {
    name: string
    companyId: string
  }

  export type NetworkProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    providerIp?: SortOrder
    dnsGateway?: SortOrder
    speed?: SortOrder
    cost?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meshDevices?: SortOrder
    switchDevices?: SortOrder
    companyId?: SortOrder
  }

  export type NetworkProviderAvgOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type NetworkProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    providerIp?: SortOrder
    dnsGateway?: SortOrder
    speed?: SortOrder
    cost?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meshDevices?: SortOrder
    switchDevices?: SortOrder
    companyId?: SortOrder
  }

  export type NetworkProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    providerIp?: SortOrder
    dnsGateway?: SortOrder
    speed?: SortOrder
    cost?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    meshDevices?: SortOrder
    switchDevices?: SortOrder
    companyId?: SortOrder
  }

  export type NetworkProviderSumOrderByAggregateInput = {
    cost?: SortOrder
  }

  export type EnumNetworkDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NetworkDeviceStatus | EnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NetworkDeviceStatus[] | ListEnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NetworkDeviceStatus[] | ListEnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNetworkDeviceStatusFilter<$PrismaModel> | $Enums.NetworkDeviceStatus
  }

  export type NetworkProviderNullableScalarRelationFilter = {
    is?: NetworkProviderWhereInput | null
    isNot?: NetworkProviderWhereInput | null
  }

  export type NetworkCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    location?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    ssid?: SortOrder
    password?: SortOrder
    ip?: SortOrder
    dns?: SortOrder
    gw?: SortOrder
    uploadSpeed?: SortOrder
    downloadSpeed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrder
    createdByUserId?: SortOrder
    providerId?: SortOrder
  }

  export type NetworkMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    location?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    ssid?: SortOrder
    password?: SortOrder
    ip?: SortOrder
    dns?: SortOrder
    gw?: SortOrder
    uploadSpeed?: SortOrder
    downloadSpeed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrder
    createdByUserId?: SortOrder
    providerId?: SortOrder
  }

  export type NetworkMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
    location?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    ssid?: SortOrder
    password?: SortOrder
    ip?: SortOrder
    dns?: SortOrder
    gw?: SortOrder
    uploadSpeed?: SortOrder
    downloadSpeed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    companyId?: SortOrder
    assignedToUserId?: SortOrder
    createdByUserId?: SortOrder
    providerId?: SortOrder
  }

  export type EnumNetworkDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NetworkDeviceStatus | EnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NetworkDeviceStatus[] | ListEnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NetworkDeviceStatus[] | ListEnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNetworkDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.NetworkDeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNetworkDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumNetworkDeviceStatusFilter<$PrismaModel>
  }

  export type EnumSoftwareCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SoftwareCategory | EnumSoftwareCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SoftwareCategory[] | ListEnumSoftwareCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SoftwareCategory[] | ListEnumSoftwareCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSoftwareCategoryFilter<$PrismaModel> | $Enums.SoftwareCategory
  }

  export type EnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumPaymentFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentFrequency | EnumPaymentFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentFrequency[] | ListEnumPaymentFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentFrequency[] | ListEnumPaymentFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentFrequencyFilter<$PrismaModel> | $Enums.PaymentFrequency
  }

  export type AnnualSoftwareExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    applicationName?: SortOrder
    provider?: SortOrder
    category?: SortOrder
    status?: SortOrder
    annualCost?: SortOrder
    numberOfUsers?: SortOrder
    costPerUser?: SortOrder
    renewalDate?: SortOrder
    paymentFrequency?: SortOrder
    additionalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnualSoftwareExpenseAvgOrderByAggregateInput = {
    annualCost?: SortOrder
    numberOfUsers?: SortOrder
    costPerUser?: SortOrder
  }

  export type AnnualSoftwareExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    applicationName?: SortOrder
    provider?: SortOrder
    category?: SortOrder
    status?: SortOrder
    annualCost?: SortOrder
    numberOfUsers?: SortOrder
    costPerUser?: SortOrder
    renewalDate?: SortOrder
    paymentFrequency?: SortOrder
    additionalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnualSoftwareExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    applicationName?: SortOrder
    provider?: SortOrder
    category?: SortOrder
    status?: SortOrder
    annualCost?: SortOrder
    numberOfUsers?: SortOrder
    costPerUser?: SortOrder
    renewalDate?: SortOrder
    paymentFrequency?: SortOrder
    additionalNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnnualSoftwareExpenseSumOrderByAggregateInput = {
    annualCost?: SortOrder
    numberOfUsers?: SortOrder
    costPerUser?: SortOrder
  }

  export type EnumSoftwareCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SoftwareCategory | EnumSoftwareCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SoftwareCategory[] | ListEnumSoftwareCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SoftwareCategory[] | ListEnumSoftwareCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSoftwareCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SoftwareCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSoftwareCategoryFilter<$PrismaModel>
    _max?: NestedEnumSoftwareCategoryFilter<$PrismaModel>
  }

  export type EnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumPaymentFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentFrequency | EnumPaymentFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentFrequency[] | ListEnumPaymentFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentFrequency[] | ListEnumPaymentFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.PaymentFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentFrequencyFilter<$PrismaModel>
    _max?: NestedEnumPaymentFrequencyFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutTicketsSentByInput = {
    create?: XOR<UserCreateWithoutTicketsSentByInput, UserUncheckedCreateWithoutTicketsSentByInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsSentByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketsSentToInput = {
    create?: XOR<UserCreateWithoutTicketsSentToInput, UserUncheckedCreateWithoutTicketsSentToInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsSentToInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutTicketsInput = {
    create?: XOR<CompanyCreateWithoutTicketsInput, CompanyUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTicketsInput
    connect?: CompanyWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumTicketTypeFieldUpdateOperationsInput = {
    set?: $Enums.TicketType
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneWithoutTicketsSentByNestedInput = {
    create?: XOR<UserCreateWithoutTicketsSentByInput, UserUncheckedCreateWithoutTicketsSentByInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsSentByInput
    upsert?: UserUpsertWithoutTicketsSentByInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsSentByInput, UserUpdateWithoutTicketsSentByInput>, UserUncheckedUpdateWithoutTicketsSentByInput>
  }

  export type UserUpdateOneWithoutTicketsSentToNestedInput = {
    create?: XOR<UserCreateWithoutTicketsSentToInput, UserUncheckedCreateWithoutTicketsSentToInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsSentToInput
    upsert?: UserUpsertWithoutTicketsSentToInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsSentToInput, UserUpdateWithoutTicketsSentToInput>, UserUncheckedUpdateWithoutTicketsSentToInput>
  }

  export type CompanyUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<CompanyCreateWithoutTicketsInput, CompanyUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTicketsInput
    upsert?: CompanyUpsertWithoutTicketsInput
    disconnect?: CompanyWhereInput | boolean
    delete?: CompanyWhereInput | boolean
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTicketsInput, CompanyUpdateWithoutTicketsInput>, CompanyUncheckedUpdateWithoutTicketsInput>
  }

  export type UserCompanyCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput> | UserCompanyCreateWithoutUserInput[] | UserCompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutUserInput | UserCompanyCreateOrConnectWithoutUserInput[]
    createMany?: UserCompanyCreateManyUserInputEnvelope
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
  }

  export type CompanyCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CompanyCreateWithoutCreatedByInput, CompanyUncheckedCreateWithoutCreatedByInput> | CompanyCreateWithoutCreatedByInput[] | CompanyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutCreatedByInput | CompanyCreateOrConnectWithoutCreatedByInput[]
    createMany?: CompanyCreateManyCreatedByInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<EquipmentCreateWithoutAssignedToUserInput, EquipmentUncheckedCreateWithoutAssignedToUserInput> | EquipmentCreateWithoutAssignedToUserInput[] | EquipmentUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAssignedToUserInput | EquipmentCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: EquipmentCreateManyAssignedToUserInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type MaintenanceCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<MaintenanceCreateWithoutAssignedToUserInput, MaintenanceUncheckedCreateWithoutAssignedToUserInput> | MaintenanceCreateWithoutAssignedToUserInput[] | MaintenanceUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutAssignedToUserInput | MaintenanceCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: MaintenanceCreateManyAssignedToUserInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type NetworkCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<NetworkCreateWithoutAssignedToUserInput, NetworkUncheckedCreateWithoutAssignedToUserInput> | NetworkCreateWithoutAssignedToUserInput[] | NetworkUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutAssignedToUserInput | NetworkCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: NetworkCreateManyAssignedToUserInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type NetworkCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<NetworkCreateWithoutCreatedByInput, NetworkUncheckedCreateWithoutCreatedByInput> | NetworkCreateWithoutCreatedByInput[] | NetworkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutCreatedByInput | NetworkCreateOrConnectWithoutCreatedByInput[]
    createMany?: NetworkCreateManyCreatedByInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type PersonCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserInput
    connect?: PersonWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutSendByInput = {
    create?: XOR<TicketCreateWithoutSendByInput, TicketUncheckedCreateWithoutSendByInput> | TicketCreateWithoutSendByInput[] | TicketUncheckedCreateWithoutSendByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSendByInput | TicketCreateOrConnectWithoutSendByInput[]
    createMany?: TicketCreateManySendByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutSendToInput = {
    create?: XOR<TicketCreateWithoutSendToInput, TicketUncheckedCreateWithoutSendToInput> | TicketCreateWithoutSendToInput[] | TicketUncheckedCreateWithoutSendToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSendToInput | TicketCreateOrConnectWithoutSendToInput[]
    createMany?: TicketCreateManySendToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type UserCompanyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput> | UserCompanyCreateWithoutUserInput[] | UserCompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutUserInput | UserCompanyCreateOrConnectWithoutUserInput[]
    createMany?: UserCompanyCreateManyUserInputEnvelope
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
  }

  export type CompanyUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<CompanyCreateWithoutCreatedByInput, CompanyUncheckedCreateWithoutCreatedByInput> | CompanyCreateWithoutCreatedByInput[] | CompanyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutCreatedByInput | CompanyCreateOrConnectWithoutCreatedByInput[]
    createMany?: CompanyCreateManyCreatedByInputEnvelope
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<EquipmentCreateWithoutAssignedToUserInput, EquipmentUncheckedCreateWithoutAssignedToUserInput> | EquipmentCreateWithoutAssignedToUserInput[] | EquipmentUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAssignedToUserInput | EquipmentCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: EquipmentCreateManyAssignedToUserInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<MaintenanceCreateWithoutAssignedToUserInput, MaintenanceUncheckedCreateWithoutAssignedToUserInput> | MaintenanceCreateWithoutAssignedToUserInput[] | MaintenanceUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutAssignedToUserInput | MaintenanceCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: MaintenanceCreateManyAssignedToUserInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput = {
    create?: XOR<NetworkCreateWithoutAssignedToUserInput, NetworkUncheckedCreateWithoutAssignedToUserInput> | NetworkCreateWithoutAssignedToUserInput[] | NetworkUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutAssignedToUserInput | NetworkCreateOrConnectWithoutAssignedToUserInput[]
    createMany?: NetworkCreateManyAssignedToUserInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type NetworkUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<NetworkCreateWithoutCreatedByInput, NetworkUncheckedCreateWithoutCreatedByInput> | NetworkCreateWithoutCreatedByInput[] | NetworkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutCreatedByInput | NetworkCreateOrConnectWithoutCreatedByInput[]
    createMany?: NetworkCreateManyCreatedByInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type PersonUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserInput
    connect?: PersonWhereUniqueInput
  }

  export type TicketUncheckedCreateNestedManyWithoutSendByInput = {
    create?: XOR<TicketCreateWithoutSendByInput, TicketUncheckedCreateWithoutSendByInput> | TicketCreateWithoutSendByInput[] | TicketUncheckedCreateWithoutSendByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSendByInput | TicketCreateOrConnectWithoutSendByInput[]
    createMany?: TicketCreateManySendByInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutSendToInput = {
    create?: XOR<TicketCreateWithoutSendToInput, TicketUncheckedCreateWithoutSendToInput> | TicketCreateWithoutSendToInput[] | TicketUncheckedCreateWithoutSendToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSendToInput | TicketCreateOrConnectWithoutSendToInput[]
    createMany?: TicketCreateManySendToInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserCompanyUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput> | UserCompanyCreateWithoutUserInput[] | UserCompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutUserInput | UserCompanyCreateOrConnectWithoutUserInput[]
    upsert?: UserCompanyUpsertWithWhereUniqueWithoutUserInput | UserCompanyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCompanyCreateManyUserInputEnvelope
    set?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    disconnect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    delete?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    update?: UserCompanyUpdateWithWhereUniqueWithoutUserInput | UserCompanyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCompanyUpdateManyWithWhereWithoutUserInput | UserCompanyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
  }

  export type CompanyUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CompanyCreateWithoutCreatedByInput, CompanyUncheckedCreateWithoutCreatedByInput> | CompanyCreateWithoutCreatedByInput[] | CompanyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutCreatedByInput | CompanyCreateOrConnectWithoutCreatedByInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutCreatedByInput | CompanyUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CompanyCreateManyCreatedByInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutCreatedByInput | CompanyUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutCreatedByInput | CompanyUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<EquipmentCreateWithoutAssignedToUserInput, EquipmentUncheckedCreateWithoutAssignedToUserInput> | EquipmentCreateWithoutAssignedToUserInput[] | EquipmentUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAssignedToUserInput | EquipmentCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutAssignedToUserInput | EquipmentUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: EquipmentCreateManyAssignedToUserInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutAssignedToUserInput | EquipmentUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutAssignedToUserInput | EquipmentUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type MaintenanceUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<MaintenanceCreateWithoutAssignedToUserInput, MaintenanceUncheckedCreateWithoutAssignedToUserInput> | MaintenanceCreateWithoutAssignedToUserInput[] | MaintenanceUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutAssignedToUserInput | MaintenanceCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutAssignedToUserInput | MaintenanceUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: MaintenanceCreateManyAssignedToUserInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutAssignedToUserInput | MaintenanceUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutAssignedToUserInput | MaintenanceUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type NetworkUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<NetworkCreateWithoutAssignedToUserInput, NetworkUncheckedCreateWithoutAssignedToUserInput> | NetworkCreateWithoutAssignedToUserInput[] | NetworkUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutAssignedToUserInput | NetworkCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutAssignedToUserInput | NetworkUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: NetworkCreateManyAssignedToUserInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutAssignedToUserInput | NetworkUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutAssignedToUserInput | NetworkUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type NetworkUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<NetworkCreateWithoutCreatedByInput, NetworkUncheckedCreateWithoutCreatedByInput> | NetworkCreateWithoutCreatedByInput[] | NetworkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutCreatedByInput | NetworkCreateOrConnectWithoutCreatedByInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutCreatedByInput | NetworkUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: NetworkCreateManyCreatedByInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutCreatedByInput | NetworkUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutCreatedByInput | NetworkUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type PersonUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserInput
    upsert?: PersonUpsertWithoutUserInput
    disconnect?: PersonWhereInput | boolean
    delete?: PersonWhereInput | boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutUserInput, PersonUpdateWithoutUserInput>, PersonUncheckedUpdateWithoutUserInput>
  }

  export type TicketUpdateManyWithoutSendByNestedInput = {
    create?: XOR<TicketCreateWithoutSendByInput, TicketUncheckedCreateWithoutSendByInput> | TicketCreateWithoutSendByInput[] | TicketUncheckedCreateWithoutSendByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSendByInput | TicketCreateOrConnectWithoutSendByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSendByInput | TicketUpsertWithWhereUniqueWithoutSendByInput[]
    createMany?: TicketCreateManySendByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSendByInput | TicketUpdateWithWhereUniqueWithoutSendByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSendByInput | TicketUpdateManyWithWhereWithoutSendByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutSendToNestedInput = {
    create?: XOR<TicketCreateWithoutSendToInput, TicketUncheckedCreateWithoutSendToInput> | TicketCreateWithoutSendToInput[] | TicketUncheckedCreateWithoutSendToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSendToInput | TicketCreateOrConnectWithoutSendToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSendToInput | TicketUpsertWithWhereUniqueWithoutSendToInput[]
    createMany?: TicketCreateManySendToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSendToInput | TicketUpdateWithWhereUniqueWithoutSendToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSendToInput | TicketUpdateManyWithWhereWithoutSendToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type UserCompanyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput> | UserCompanyCreateWithoutUserInput[] | UserCompanyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutUserInput | UserCompanyCreateOrConnectWithoutUserInput[]
    upsert?: UserCompanyUpsertWithWhereUniqueWithoutUserInput | UserCompanyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserCompanyCreateManyUserInputEnvelope
    set?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    disconnect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    delete?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    update?: UserCompanyUpdateWithWhereUniqueWithoutUserInput | UserCompanyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserCompanyUpdateManyWithWhereWithoutUserInput | UserCompanyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
  }

  export type CompanyUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<CompanyCreateWithoutCreatedByInput, CompanyUncheckedCreateWithoutCreatedByInput> | CompanyCreateWithoutCreatedByInput[] | CompanyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: CompanyCreateOrConnectWithoutCreatedByInput | CompanyCreateOrConnectWithoutCreatedByInput[]
    upsert?: CompanyUpsertWithWhereUniqueWithoutCreatedByInput | CompanyUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: CompanyCreateManyCreatedByInputEnvelope
    set?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    disconnect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    delete?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    connect?: CompanyWhereUniqueInput | CompanyWhereUniqueInput[]
    update?: CompanyUpdateWithWhereUniqueWithoutCreatedByInput | CompanyUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: CompanyUpdateManyWithWhereWithoutCreatedByInput | CompanyUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<EquipmentCreateWithoutAssignedToUserInput, EquipmentUncheckedCreateWithoutAssignedToUserInput> | EquipmentCreateWithoutAssignedToUserInput[] | EquipmentUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutAssignedToUserInput | EquipmentCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutAssignedToUserInput | EquipmentUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: EquipmentCreateManyAssignedToUserInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutAssignedToUserInput | EquipmentUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutAssignedToUserInput | EquipmentUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<MaintenanceCreateWithoutAssignedToUserInput, MaintenanceUncheckedCreateWithoutAssignedToUserInput> | MaintenanceCreateWithoutAssignedToUserInput[] | MaintenanceUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutAssignedToUserInput | MaintenanceCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutAssignedToUserInput | MaintenanceUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: MaintenanceCreateManyAssignedToUserInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutAssignedToUserInput | MaintenanceUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutAssignedToUserInput | MaintenanceUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput = {
    create?: XOR<NetworkCreateWithoutAssignedToUserInput, NetworkUncheckedCreateWithoutAssignedToUserInput> | NetworkCreateWithoutAssignedToUserInput[] | NetworkUncheckedCreateWithoutAssignedToUserInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutAssignedToUserInput | NetworkCreateOrConnectWithoutAssignedToUserInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutAssignedToUserInput | NetworkUpsertWithWhereUniqueWithoutAssignedToUserInput[]
    createMany?: NetworkCreateManyAssignedToUserInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutAssignedToUserInput | NetworkUpdateWithWhereUniqueWithoutAssignedToUserInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutAssignedToUserInput | NetworkUpdateManyWithWhereWithoutAssignedToUserInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type NetworkUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<NetworkCreateWithoutCreatedByInput, NetworkUncheckedCreateWithoutCreatedByInput> | NetworkCreateWithoutCreatedByInput[] | NetworkUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutCreatedByInput | NetworkCreateOrConnectWithoutCreatedByInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutCreatedByInput | NetworkUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: NetworkCreateManyCreatedByInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutCreatedByInput | NetworkUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutCreatedByInput | NetworkUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type PersonUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
    connectOrCreate?: PersonCreateOrConnectWithoutUserInput
    upsert?: PersonUpsertWithoutUserInput
    disconnect?: PersonWhereInput | boolean
    delete?: PersonWhereInput | boolean
    connect?: PersonWhereUniqueInput
    update?: XOR<XOR<PersonUpdateToOneWithWhereWithoutUserInput, PersonUpdateWithoutUserInput>, PersonUncheckedUpdateWithoutUserInput>
  }

  export type TicketUncheckedUpdateManyWithoutSendByNestedInput = {
    create?: XOR<TicketCreateWithoutSendByInput, TicketUncheckedCreateWithoutSendByInput> | TicketCreateWithoutSendByInput[] | TicketUncheckedCreateWithoutSendByInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSendByInput | TicketCreateOrConnectWithoutSendByInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSendByInput | TicketUpsertWithWhereUniqueWithoutSendByInput[]
    createMany?: TicketCreateManySendByInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSendByInput | TicketUpdateWithWhereUniqueWithoutSendByInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSendByInput | TicketUpdateManyWithWhereWithoutSendByInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutSendToNestedInput = {
    create?: XOR<TicketCreateWithoutSendToInput, TicketUncheckedCreateWithoutSendToInput> | TicketCreateWithoutSendToInput[] | TicketUncheckedCreateWithoutSendToInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutSendToInput | TicketCreateOrConnectWithoutSendToInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutSendToInput | TicketUpsertWithWhereUniqueWithoutSendToInput[]
    createMany?: TicketCreateManySendToInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutSendToInput | TicketUpdateWithWhereUniqueWithoutSendToInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutSendToInput | TicketUpdateManyWithWhereWithoutSendToInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompaniesInput
    upsert?: UserUpsertWithoutCompaniesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompaniesInput, UserUpdateWithoutCompaniesInput>, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type DepartmentCreateNestedOneWithoutPersonsInput = {
    create?: XOR<DepartmentCreateWithoutPersonsInput, DepartmentUncheckedCreateWithoutPersonsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPersonsInput
    connect?: DepartmentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPersonInput = {
    create?: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonInput
    connect?: UserWhereUniqueInput
  }

  export type AnnualSoftwareExpenseCreateNestedManyWithoutAssignedPersonsInput = {
    create?: XOR<AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput, AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput> | AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput[] | AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput[]
    connectOrCreate?: AnnualSoftwareExpenseCreateOrConnectWithoutAssignedPersonsInput | AnnualSoftwareExpenseCreateOrConnectWithoutAssignedPersonsInput[]
    connect?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
  }

  export type AnnualSoftwareExpenseUncheckedCreateNestedManyWithoutAssignedPersonsInput = {
    create?: XOR<AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput, AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput> | AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput[] | AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput[]
    connectOrCreate?: AnnualSoftwareExpenseCreateOrConnectWithoutAssignedPersonsInput | AnnualSoftwareExpenseCreateOrConnectWithoutAssignedPersonsInput[]
    connect?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
  }

  export type EnumPersonStatusFieldUpdateOperationsInput = {
    set?: $Enums.PersonStatus
  }

  export type DepartmentUpdateOneWithoutPersonsNestedInput = {
    create?: XOR<DepartmentCreateWithoutPersonsInput, DepartmentUncheckedCreateWithoutPersonsInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutPersonsInput
    upsert?: DepartmentUpsertWithoutPersonsInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutPersonsInput, DepartmentUpdateWithoutPersonsInput>, DepartmentUncheckedUpdateWithoutPersonsInput>
  }

  export type UserUpdateOneWithoutPersonNestedInput = {
    create?: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
    connectOrCreate?: UserCreateOrConnectWithoutPersonInput
    upsert?: UserUpsertWithoutPersonInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPersonInput, UserUpdateWithoutPersonInput>, UserUncheckedUpdateWithoutPersonInput>
  }

  export type AnnualSoftwareExpenseUpdateManyWithoutAssignedPersonsNestedInput = {
    create?: XOR<AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput, AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput> | AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput[] | AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput[]
    connectOrCreate?: AnnualSoftwareExpenseCreateOrConnectWithoutAssignedPersonsInput | AnnualSoftwareExpenseCreateOrConnectWithoutAssignedPersonsInput[]
    upsert?: AnnualSoftwareExpenseUpsertWithWhereUniqueWithoutAssignedPersonsInput | AnnualSoftwareExpenseUpsertWithWhereUniqueWithoutAssignedPersonsInput[]
    set?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
    disconnect?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
    delete?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
    connect?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
    update?: AnnualSoftwareExpenseUpdateWithWhereUniqueWithoutAssignedPersonsInput | AnnualSoftwareExpenseUpdateWithWhereUniqueWithoutAssignedPersonsInput[]
    updateMany?: AnnualSoftwareExpenseUpdateManyWithWhereWithoutAssignedPersonsInput | AnnualSoftwareExpenseUpdateManyWithWhereWithoutAssignedPersonsInput[]
    deleteMany?: AnnualSoftwareExpenseScalarWhereInput | AnnualSoftwareExpenseScalarWhereInput[]
  }

  export type AnnualSoftwareExpenseUncheckedUpdateManyWithoutAssignedPersonsNestedInput = {
    create?: XOR<AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput, AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput> | AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput[] | AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput[]
    connectOrCreate?: AnnualSoftwareExpenseCreateOrConnectWithoutAssignedPersonsInput | AnnualSoftwareExpenseCreateOrConnectWithoutAssignedPersonsInput[]
    upsert?: AnnualSoftwareExpenseUpsertWithWhereUniqueWithoutAssignedPersonsInput | AnnualSoftwareExpenseUpsertWithWhereUniqueWithoutAssignedPersonsInput[]
    set?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
    disconnect?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
    delete?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
    connect?: AnnualSoftwareExpenseWhereUniqueInput | AnnualSoftwareExpenseWhereUniqueInput[]
    update?: AnnualSoftwareExpenseUpdateWithWhereUniqueWithoutAssignedPersonsInput | AnnualSoftwareExpenseUpdateWithWhereUniqueWithoutAssignedPersonsInput[]
    updateMany?: AnnualSoftwareExpenseUpdateManyWithWhereWithoutAssignedPersonsInput | AnnualSoftwareExpenseUpdateManyWithWhereWithoutAssignedPersonsInput[]
    deleteMany?: AnnualSoftwareExpenseScalarWhereInput | AnnualSoftwareExpenseScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCreatedCompaniesInput = {
    create?: XOR<UserCreateWithoutCreatedCompaniesInput, UserUncheckedCreateWithoutCreatedCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCompaniesInput
    connect?: UserWhereUniqueInput
  }

  export type DepartmentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EquipmentCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EquipmentCreateWithoutCompanyInput, EquipmentUncheckedCreateWithoutCompanyInput> | EquipmentCreateWithoutCompanyInput[] | EquipmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutCompanyInput | EquipmentCreateOrConnectWithoutCompanyInput[]
    createMany?: EquipmentCreateManyCompanyInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type LicenseCreateNestedManyWithoutCompanyInput = {
    create?: XOR<LicenseCreateWithoutCompanyInput, LicenseUncheckedCreateWithoutCompanyInput> | LicenseCreateWithoutCompanyInput[] | LicenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutCompanyInput | LicenseCreateOrConnectWithoutCompanyInput[]
    createMany?: LicenseCreateManyCompanyInputEnvelope
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
  }

  export type MaintenanceCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MaintenanceCreateWithoutCompanyInput, MaintenanceUncheckedCreateWithoutCompanyInput> | MaintenanceCreateWithoutCompanyInput[] | MaintenanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutCompanyInput | MaintenanceCreateOrConnectWithoutCompanyInput[]
    createMany?: MaintenanceCreateManyCompanyInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type NetworkCreateNestedManyWithoutCompanyInput = {
    create?: XOR<NetworkCreateWithoutCompanyInput, NetworkUncheckedCreateWithoutCompanyInput> | NetworkCreateWithoutCompanyInput[] | NetworkUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutCompanyInput | NetworkCreateOrConnectWithoutCompanyInput[]
    createMany?: NetworkCreateManyCompanyInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type NetworkProviderCreateNestedManyWithoutCompanyInput = {
    create?: XOR<NetworkProviderCreateWithoutCompanyInput, NetworkProviderUncheckedCreateWithoutCompanyInput> | NetworkProviderCreateWithoutCompanyInput[] | NetworkProviderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NetworkProviderCreateOrConnectWithoutCompanyInput | NetworkProviderCreateOrConnectWithoutCompanyInput[]
    createMany?: NetworkProviderCreateManyCompanyInputEnvelope
    connect?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput> | TicketCreateWithoutCompanyInput[] | TicketUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCompanyInput | TicketCreateOrConnectWithoutCompanyInput[]
    createMany?: TicketCreateManyCompanyInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type UserCompanyCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput> | UserCompanyCreateWithoutCompanyInput[] | UserCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutCompanyInput | UserCompanyCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCompanyCreateManyCompanyInputEnvelope
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type EquipmentUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<EquipmentCreateWithoutCompanyInput, EquipmentUncheckedCreateWithoutCompanyInput> | EquipmentCreateWithoutCompanyInput[] | EquipmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutCompanyInput | EquipmentCreateOrConnectWithoutCompanyInput[]
    createMany?: EquipmentCreateManyCompanyInputEnvelope
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
  }

  export type LicenseUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<LicenseCreateWithoutCompanyInput, LicenseUncheckedCreateWithoutCompanyInput> | LicenseCreateWithoutCompanyInput[] | LicenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutCompanyInput | LicenseCreateOrConnectWithoutCompanyInput[]
    createMany?: LicenseCreateManyCompanyInputEnvelope
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<MaintenanceCreateWithoutCompanyInput, MaintenanceUncheckedCreateWithoutCompanyInput> | MaintenanceCreateWithoutCompanyInput[] | MaintenanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutCompanyInput | MaintenanceCreateOrConnectWithoutCompanyInput[]
    createMany?: MaintenanceCreateManyCompanyInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type NetworkUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<NetworkCreateWithoutCompanyInput, NetworkUncheckedCreateWithoutCompanyInput> | NetworkCreateWithoutCompanyInput[] | NetworkUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutCompanyInput | NetworkCreateOrConnectWithoutCompanyInput[]
    createMany?: NetworkCreateManyCompanyInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<NetworkProviderCreateWithoutCompanyInput, NetworkProviderUncheckedCreateWithoutCompanyInput> | NetworkProviderCreateWithoutCompanyInput[] | NetworkProviderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NetworkProviderCreateOrConnectWithoutCompanyInput | NetworkProviderCreateOrConnectWithoutCompanyInput[]
    createMany?: NetworkProviderCreateManyCompanyInputEnvelope
    connect?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput> | TicketCreateWithoutCompanyInput[] | TicketUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCompanyInput | TicketCreateOrConnectWithoutCompanyInput[]
    createMany?: TicketCreateManyCompanyInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type UserCompanyUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput> | UserCompanyCreateWithoutCompanyInput[] | UserCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutCompanyInput | UserCompanyCreateOrConnectWithoutCompanyInput[]
    createMany?: UserCompanyCreateManyCompanyInputEnvelope
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutCreatedCompaniesNestedInput = {
    create?: XOR<UserCreateWithoutCreatedCompaniesInput, UserUncheckedCreateWithoutCreatedCompaniesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedCompaniesInput
    upsert?: UserUpsertWithoutCreatedCompaniesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedCompaniesInput, UserUpdateWithoutCreatedCompaniesInput>, UserUncheckedUpdateWithoutCreatedCompaniesInput>
  }

  export type DepartmentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCompanyInput | DepartmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCompanyInput | DepartmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCompanyInput | DepartmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EquipmentUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EquipmentCreateWithoutCompanyInput, EquipmentUncheckedCreateWithoutCompanyInput> | EquipmentCreateWithoutCompanyInput[] | EquipmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutCompanyInput | EquipmentCreateOrConnectWithoutCompanyInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutCompanyInput | EquipmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EquipmentCreateManyCompanyInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutCompanyInput | EquipmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutCompanyInput | EquipmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type LicenseUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<LicenseCreateWithoutCompanyInput, LicenseUncheckedCreateWithoutCompanyInput> | LicenseCreateWithoutCompanyInput[] | LicenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutCompanyInput | LicenseCreateOrConnectWithoutCompanyInput[]
    upsert?: LicenseUpsertWithWhereUniqueWithoutCompanyInput | LicenseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: LicenseCreateManyCompanyInputEnvelope
    set?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    disconnect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    delete?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    update?: LicenseUpdateWithWhereUniqueWithoutCompanyInput | LicenseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: LicenseUpdateManyWithWhereWithoutCompanyInput | LicenseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
  }

  export type MaintenanceUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MaintenanceCreateWithoutCompanyInput, MaintenanceUncheckedCreateWithoutCompanyInput> | MaintenanceCreateWithoutCompanyInput[] | MaintenanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutCompanyInput | MaintenanceCreateOrConnectWithoutCompanyInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutCompanyInput | MaintenanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MaintenanceCreateManyCompanyInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutCompanyInput | MaintenanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutCompanyInput | MaintenanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type NetworkUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<NetworkCreateWithoutCompanyInput, NetworkUncheckedCreateWithoutCompanyInput> | NetworkCreateWithoutCompanyInput[] | NetworkUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutCompanyInput | NetworkCreateOrConnectWithoutCompanyInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutCompanyInput | NetworkUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: NetworkCreateManyCompanyInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutCompanyInput | NetworkUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutCompanyInput | NetworkUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type NetworkProviderUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<NetworkProviderCreateWithoutCompanyInput, NetworkProviderUncheckedCreateWithoutCompanyInput> | NetworkProviderCreateWithoutCompanyInput[] | NetworkProviderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NetworkProviderCreateOrConnectWithoutCompanyInput | NetworkProviderCreateOrConnectWithoutCompanyInput[]
    upsert?: NetworkProviderUpsertWithWhereUniqueWithoutCompanyInput | NetworkProviderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: NetworkProviderCreateManyCompanyInputEnvelope
    set?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
    disconnect?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
    delete?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
    connect?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
    update?: NetworkProviderUpdateWithWhereUniqueWithoutCompanyInput | NetworkProviderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: NetworkProviderUpdateManyWithWhereWithoutCompanyInput | NetworkProviderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: NetworkProviderScalarWhereInput | NetworkProviderScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput> | TicketCreateWithoutCompanyInput[] | TicketUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCompanyInput | TicketCreateOrConnectWithoutCompanyInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCompanyInput | TicketUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TicketCreateManyCompanyInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCompanyInput | TicketUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCompanyInput | TicketUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type UserCompanyUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput> | UserCompanyCreateWithoutCompanyInput[] | UserCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutCompanyInput | UserCompanyCreateOrConnectWithoutCompanyInput[]
    upsert?: UserCompanyUpsertWithWhereUniqueWithoutCompanyInput | UserCompanyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCompanyCreateManyCompanyInputEnvelope
    set?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    disconnect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    delete?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    update?: UserCompanyUpdateWithWhereUniqueWithoutCompanyInput | UserCompanyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserCompanyUpdateManyWithWhereWithoutCompanyInput | UserCompanyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput> | DepartmentCreateWithoutCompanyInput[] | DepartmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCompanyInput | DepartmentCreateOrConnectWithoutCompanyInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCompanyInput | DepartmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DepartmentCreateManyCompanyInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCompanyInput | DepartmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCompanyInput | DepartmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput> | DocumentCreateWithoutCompanyInput[] | DocumentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutCompanyInput | DocumentCreateOrConnectWithoutCompanyInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutCompanyInput | DocumentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DocumentCreateManyCompanyInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutCompanyInput | DocumentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutCompanyInput | DocumentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type EquipmentUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<EquipmentCreateWithoutCompanyInput, EquipmentUncheckedCreateWithoutCompanyInput> | EquipmentCreateWithoutCompanyInput[] | EquipmentUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: EquipmentCreateOrConnectWithoutCompanyInput | EquipmentCreateOrConnectWithoutCompanyInput[]
    upsert?: EquipmentUpsertWithWhereUniqueWithoutCompanyInput | EquipmentUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: EquipmentCreateManyCompanyInputEnvelope
    set?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    disconnect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    delete?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    connect?: EquipmentWhereUniqueInput | EquipmentWhereUniqueInput[]
    update?: EquipmentUpdateWithWhereUniqueWithoutCompanyInput | EquipmentUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: EquipmentUpdateManyWithWhereWithoutCompanyInput | EquipmentUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
  }

  export type LicenseUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<LicenseCreateWithoutCompanyInput, LicenseUncheckedCreateWithoutCompanyInput> | LicenseCreateWithoutCompanyInput[] | LicenseUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: LicenseCreateOrConnectWithoutCompanyInput | LicenseCreateOrConnectWithoutCompanyInput[]
    upsert?: LicenseUpsertWithWhereUniqueWithoutCompanyInput | LicenseUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: LicenseCreateManyCompanyInputEnvelope
    set?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    disconnect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    delete?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    connect?: LicenseWhereUniqueInput | LicenseWhereUniqueInput[]
    update?: LicenseUpdateWithWhereUniqueWithoutCompanyInput | LicenseUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: LicenseUpdateManyWithWhereWithoutCompanyInput | LicenseUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<MaintenanceCreateWithoutCompanyInput, MaintenanceUncheckedCreateWithoutCompanyInput> | MaintenanceCreateWithoutCompanyInput[] | MaintenanceUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutCompanyInput | MaintenanceCreateOrConnectWithoutCompanyInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutCompanyInput | MaintenanceUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: MaintenanceCreateManyCompanyInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutCompanyInput | MaintenanceUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutCompanyInput | MaintenanceUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type NetworkUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<NetworkCreateWithoutCompanyInput, NetworkUncheckedCreateWithoutCompanyInput> | NetworkCreateWithoutCompanyInput[] | NetworkUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutCompanyInput | NetworkCreateOrConnectWithoutCompanyInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutCompanyInput | NetworkUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: NetworkCreateManyCompanyInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutCompanyInput | NetworkUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutCompanyInput | NetworkUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<NetworkProviderCreateWithoutCompanyInput, NetworkProviderUncheckedCreateWithoutCompanyInput> | NetworkProviderCreateWithoutCompanyInput[] | NetworkProviderUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: NetworkProviderCreateOrConnectWithoutCompanyInput | NetworkProviderCreateOrConnectWithoutCompanyInput[]
    upsert?: NetworkProviderUpsertWithWhereUniqueWithoutCompanyInput | NetworkProviderUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: NetworkProviderCreateManyCompanyInputEnvelope
    set?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
    disconnect?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
    delete?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
    connect?: NetworkProviderWhereUniqueInput | NetworkProviderWhereUniqueInput[]
    update?: NetworkProviderUpdateWithWhereUniqueWithoutCompanyInput | NetworkProviderUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: NetworkProviderUpdateManyWithWhereWithoutCompanyInput | NetworkProviderUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: NetworkProviderScalarWhereInput | NetworkProviderScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput> | TicketCreateWithoutCompanyInput[] | TicketUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutCompanyInput | TicketCreateOrConnectWithoutCompanyInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutCompanyInput | TicketUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TicketCreateManyCompanyInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutCompanyInput | TicketUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutCompanyInput | TicketUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput> | UserCompanyCreateWithoutCompanyInput[] | UserCompanyUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: UserCompanyCreateOrConnectWithoutCompanyInput | UserCompanyCreateOrConnectWithoutCompanyInput[]
    upsert?: UserCompanyUpsertWithWhereUniqueWithoutCompanyInput | UserCompanyUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: UserCompanyCreateManyCompanyInputEnvelope
    set?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    disconnect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    delete?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    connect?: UserCompanyWhereUniqueInput | UserCompanyWhereUniqueInput[]
    update?: UserCompanyUpdateWithWhereUniqueWithoutCompanyInput | UserCompanyUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: UserCompanyUpdateManyWithWhereWithoutCompanyInput | UserCompanyUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutDepartmentsInput = {
    create?: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDepartmentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PersonCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<PersonCreateWithoutDepartmentInput, PersonUncheckedCreateWithoutDepartmentInput> | PersonCreateWithoutDepartmentInput[] | PersonUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutDepartmentInput | PersonCreateOrConnectWithoutDepartmentInput[]
    createMany?: PersonCreateManyDepartmentInputEnvelope
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
  }

  export type PersonUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<PersonCreateWithoutDepartmentInput, PersonUncheckedCreateWithoutDepartmentInput> | PersonCreateWithoutDepartmentInput[] | PersonUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutDepartmentInput | PersonCreateOrConnectWithoutDepartmentInput[]
    createMany?: PersonCreateManyDepartmentInputEnvelope
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
  }

  export type CompanyUpdateOneRequiredWithoutDepartmentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDepartmentsInput
    upsert?: CompanyUpsertWithoutDepartmentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDepartmentsInput, CompanyUpdateWithoutDepartmentsInput>, CompanyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type PersonUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<PersonCreateWithoutDepartmentInput, PersonUncheckedCreateWithoutDepartmentInput> | PersonCreateWithoutDepartmentInput[] | PersonUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutDepartmentInput | PersonCreateOrConnectWithoutDepartmentInput[]
    upsert?: PersonUpsertWithWhereUniqueWithoutDepartmentInput | PersonUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: PersonCreateManyDepartmentInputEnvelope
    set?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    disconnect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    delete?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    update?: PersonUpdateWithWhereUniqueWithoutDepartmentInput | PersonUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: PersonUpdateManyWithWhereWithoutDepartmentInput | PersonUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: PersonScalarWhereInput | PersonScalarWhereInput[]
  }

  export type PersonUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<PersonCreateWithoutDepartmentInput, PersonUncheckedCreateWithoutDepartmentInput> | PersonCreateWithoutDepartmentInput[] | PersonUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutDepartmentInput | PersonCreateOrConnectWithoutDepartmentInput[]
    upsert?: PersonUpsertWithWhereUniqueWithoutDepartmentInput | PersonUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: PersonCreateManyDepartmentInputEnvelope
    set?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    disconnect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    delete?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    update?: PersonUpdateWithWhereUniqueWithoutDepartmentInput | PersonUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: PersonUpdateManyWithWhereWithoutDepartmentInput | PersonUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: PersonScalarWhereInput | PersonScalarWhereInput[]
  }

  export type DocumentCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<DocumentCreateWithoutEquipmentInput, DocumentUncheckedCreateWithoutEquipmentInput> | DocumentCreateWithoutEquipmentInput[] | DocumentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEquipmentInput | DocumentCreateOrConnectWithoutEquipmentInput[]
    createMany?: DocumentCreateManyEquipmentInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutAssignedEquipmentsInput = {
    create?: XOR<UserCreateWithoutAssignedEquipmentsInput, UserUncheckedCreateWithoutAssignedEquipmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedEquipmentsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutEquipmentsInput = {
    create?: XOR<CompanyCreateWithoutEquipmentsInput, CompanyUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEquipmentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type MaintenanceCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput> | MaintenanceCreateWithoutEquipmentInput[] | MaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEquipmentInput | MaintenanceCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceCreateManyEquipmentInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<DocumentCreateWithoutEquipmentInput, DocumentUncheckedCreateWithoutEquipmentInput> | DocumentCreateWithoutEquipmentInput[] | DocumentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEquipmentInput | DocumentCreateOrConnectWithoutEquipmentInput[]
    createMany?: DocumentCreateManyEquipmentInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput = {
    create?: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput> | MaintenanceCreateWithoutEquipmentInput[] | MaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEquipmentInput | MaintenanceCreateOrConnectWithoutEquipmentInput[]
    createMany?: MaintenanceCreateManyEquipmentInputEnvelope
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
  }

  export type EnumEquipmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.EquipmentStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DocumentUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<DocumentCreateWithoutEquipmentInput, DocumentUncheckedCreateWithoutEquipmentInput> | DocumentCreateWithoutEquipmentInput[] | DocumentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEquipmentInput | DocumentCreateOrConnectWithoutEquipmentInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutEquipmentInput | DocumentUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: DocumentCreateManyEquipmentInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutEquipmentInput | DocumentUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutEquipmentInput | DocumentUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserUpdateOneWithoutAssignedEquipmentsNestedInput = {
    create?: XOR<UserCreateWithoutAssignedEquipmentsInput, UserUncheckedCreateWithoutAssignedEquipmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedEquipmentsInput
    upsert?: UserUpsertWithoutAssignedEquipmentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedEquipmentsInput, UserUpdateWithoutAssignedEquipmentsInput>, UserUncheckedUpdateWithoutAssignedEquipmentsInput>
  }

  export type CompanyUpdateOneRequiredWithoutEquipmentsNestedInput = {
    create?: XOR<CompanyCreateWithoutEquipmentsInput, CompanyUncheckedCreateWithoutEquipmentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutEquipmentsInput
    upsert?: CompanyUpsertWithoutEquipmentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutEquipmentsInput, CompanyUpdateWithoutEquipmentsInput>, CompanyUncheckedUpdateWithoutEquipmentsInput>
  }

  export type MaintenanceUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput> | MaintenanceCreateWithoutEquipmentInput[] | MaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEquipmentInput | MaintenanceCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceCreateManyEquipmentInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutEquipmentInput | MaintenanceUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<DocumentCreateWithoutEquipmentInput, DocumentUncheckedCreateWithoutEquipmentInput> | DocumentCreateWithoutEquipmentInput[] | DocumentUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutEquipmentInput | DocumentCreateOrConnectWithoutEquipmentInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutEquipmentInput | DocumentUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: DocumentCreateManyEquipmentInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutEquipmentInput | DocumentUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutEquipmentInput | DocumentUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput = {
    create?: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput> | MaintenanceCreateWithoutEquipmentInput[] | MaintenanceUncheckedCreateWithoutEquipmentInput[]
    connectOrCreate?: MaintenanceCreateOrConnectWithoutEquipmentInput | MaintenanceCreateOrConnectWithoutEquipmentInput[]
    upsert?: MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput | MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput[]
    createMany?: MaintenanceCreateManyEquipmentInputEnvelope
    set?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    disconnect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    delete?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    connect?: MaintenanceWhereUniqueInput | MaintenanceWhereUniqueInput[]
    update?: MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput | MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput[]
    updateMany?: MaintenanceUpdateManyWithWhereWithoutEquipmentInput | MaintenanceUpdateManyWithWhereWithoutEquipmentInput[]
    deleteMany?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAssignedMaintenancesInput = {
    create?: XOR<UserCreateWithoutAssignedMaintenancesInput, UserUncheckedCreateWithoutAssignedMaintenancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedMaintenancesInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutMaintenancesInput = {
    create?: XOR<CompanyCreateWithoutMaintenancesInput, CompanyUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMaintenancesInput
    connect?: CompanyWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutMaintenancesInput = {
    create?: XOR<EquipmentCreateWithoutMaintenancesInput, EquipmentUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenancesInput
    connect?: EquipmentWhereUniqueInput
  }

  export type EnumMaintenanceTypeFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceType
  }

  export type EnumMaintenanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceStatus
  }

  export type UserUpdateOneWithoutAssignedMaintenancesNestedInput = {
    create?: XOR<UserCreateWithoutAssignedMaintenancesInput, UserUncheckedCreateWithoutAssignedMaintenancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedMaintenancesInput
    upsert?: UserUpsertWithoutAssignedMaintenancesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedMaintenancesInput, UserUpdateWithoutAssignedMaintenancesInput>, UserUncheckedUpdateWithoutAssignedMaintenancesInput>
  }

  export type CompanyUpdateOneRequiredWithoutMaintenancesNestedInput = {
    create?: XOR<CompanyCreateWithoutMaintenancesInput, CompanyUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutMaintenancesInput
    upsert?: CompanyUpsertWithoutMaintenancesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutMaintenancesInput, CompanyUpdateWithoutMaintenancesInput>, CompanyUncheckedUpdateWithoutMaintenancesInput>
  }

  export type EquipmentUpdateOneRequiredWithoutMaintenancesNestedInput = {
    create?: XOR<EquipmentCreateWithoutMaintenancesInput, EquipmentUncheckedCreateWithoutMaintenancesInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutMaintenancesInput
    upsert?: EquipmentUpsertWithoutMaintenancesInput
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutMaintenancesInput, EquipmentUpdateWithoutMaintenancesInput>, EquipmentUncheckedUpdateWithoutMaintenancesInput>
  }

  export type CompanyCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
  }

  export type EquipmentCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<EquipmentCreateWithoutDocumentsInput, EquipmentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutDocumentsInput
    connect?: EquipmentWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDocumentsInput
    upsert?: CompanyUpsertWithoutDocumentsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDocumentsInput, CompanyUpdateWithoutDocumentsInput>, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type EquipmentUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<EquipmentCreateWithoutDocumentsInput, EquipmentUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: EquipmentCreateOrConnectWithoutDocumentsInput
    upsert?: EquipmentUpsertWithoutDocumentsInput
    disconnect?: EquipmentWhereInput | boolean
    delete?: EquipmentWhereInput | boolean
    connect?: EquipmentWhereUniqueInput
    update?: XOR<XOR<EquipmentUpdateToOneWithWhereWithoutDocumentsInput, EquipmentUpdateWithoutDocumentsInput>, EquipmentUncheckedUpdateWithoutDocumentsInput>
  }

  export type CompanyCreateNestedOneWithoutLicensesInput = {
    create?: XOR<CompanyCreateWithoutLicensesInput, CompanyUncheckedCreateWithoutLicensesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutLicensesInput
    connect?: CompanyWhereUniqueInput
  }

  export type CompanyUpdateOneRequiredWithoutLicensesNestedInput = {
    create?: XOR<CompanyCreateWithoutLicensesInput, CompanyUncheckedCreateWithoutLicensesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutLicensesInput
    upsert?: CompanyUpsertWithoutLicensesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutLicensesInput, CompanyUpdateWithoutLicensesInput>, CompanyUncheckedUpdateWithoutLicensesInput>
  }

  export type NetworkCreateNestedManyWithoutProviderInput = {
    create?: XOR<NetworkCreateWithoutProviderInput, NetworkUncheckedCreateWithoutProviderInput> | NetworkCreateWithoutProviderInput[] | NetworkUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutProviderInput | NetworkCreateOrConnectWithoutProviderInput[]
    createMany?: NetworkCreateManyProviderInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type CompanyCreateNestedOneWithoutNetworkProvidersInput = {
    create?: XOR<CompanyCreateWithoutNetworkProvidersInput, CompanyUncheckedCreateWithoutNetworkProvidersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutNetworkProvidersInput
    connect?: CompanyWhereUniqueInput
  }

  export type NetworkUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<NetworkCreateWithoutProviderInput, NetworkUncheckedCreateWithoutProviderInput> | NetworkCreateWithoutProviderInput[] | NetworkUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutProviderInput | NetworkCreateOrConnectWithoutProviderInput[]
    createMany?: NetworkCreateManyProviderInputEnvelope
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
  }

  export type NetworkUpdateManyWithoutProviderNestedInput = {
    create?: XOR<NetworkCreateWithoutProviderInput, NetworkUncheckedCreateWithoutProviderInput> | NetworkCreateWithoutProviderInput[] | NetworkUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutProviderInput | NetworkCreateOrConnectWithoutProviderInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutProviderInput | NetworkUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: NetworkCreateManyProviderInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutProviderInput | NetworkUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutProviderInput | NetworkUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type CompanyUpdateOneRequiredWithoutNetworkProvidersNestedInput = {
    create?: XOR<CompanyCreateWithoutNetworkProvidersInput, CompanyUncheckedCreateWithoutNetworkProvidersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutNetworkProvidersInput
    upsert?: CompanyUpsertWithoutNetworkProvidersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutNetworkProvidersInput, CompanyUpdateWithoutNetworkProvidersInput>, CompanyUncheckedUpdateWithoutNetworkProvidersInput>
  }

  export type NetworkUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<NetworkCreateWithoutProviderInput, NetworkUncheckedCreateWithoutProviderInput> | NetworkCreateWithoutProviderInput[] | NetworkUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: NetworkCreateOrConnectWithoutProviderInput | NetworkCreateOrConnectWithoutProviderInput[]
    upsert?: NetworkUpsertWithWhereUniqueWithoutProviderInput | NetworkUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: NetworkCreateManyProviderInputEnvelope
    set?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    disconnect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    delete?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    connect?: NetworkWhereUniqueInput | NetworkWhereUniqueInput[]
    update?: NetworkUpdateWithWhereUniqueWithoutProviderInput | NetworkUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: NetworkUpdateManyWithWhereWithoutProviderInput | NetworkUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAssignedNetworksInput = {
    create?: XOR<UserCreateWithoutAssignedNetworksInput, UserUncheckedCreateWithoutAssignedNetworksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedNetworksInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCreatedNetworksInput = {
    create?: XOR<UserCreateWithoutCreatedNetworksInput, UserUncheckedCreateWithoutCreatedNetworksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedNetworksInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutNetworksInput = {
    create?: XOR<CompanyCreateWithoutNetworksInput, CompanyUncheckedCreateWithoutNetworksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutNetworksInput
    connect?: CompanyWhereUniqueInput
  }

  export type NetworkProviderCreateNestedOneWithoutNetworksInput = {
    create?: XOR<NetworkProviderCreateWithoutNetworksInput, NetworkProviderUncheckedCreateWithoutNetworksInput>
    connectOrCreate?: NetworkProviderCreateOrConnectWithoutNetworksInput
    connect?: NetworkProviderWhereUniqueInput
  }

  export type EnumNetworkDeviceStatusFieldUpdateOperationsInput = {
    set?: $Enums.NetworkDeviceStatus
  }

  export type UserUpdateOneWithoutAssignedNetworksNestedInput = {
    create?: XOR<UserCreateWithoutAssignedNetworksInput, UserUncheckedCreateWithoutAssignedNetworksInput>
    connectOrCreate?: UserCreateOrConnectWithoutAssignedNetworksInput
    upsert?: UserUpsertWithoutAssignedNetworksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAssignedNetworksInput, UserUpdateWithoutAssignedNetworksInput>, UserUncheckedUpdateWithoutAssignedNetworksInput>
  }

  export type UserUpdateOneWithoutCreatedNetworksNestedInput = {
    create?: XOR<UserCreateWithoutCreatedNetworksInput, UserUncheckedCreateWithoutCreatedNetworksInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedNetworksInput
    upsert?: UserUpsertWithoutCreatedNetworksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedNetworksInput, UserUpdateWithoutCreatedNetworksInput>, UserUncheckedUpdateWithoutCreatedNetworksInput>
  }

  export type CompanyUpdateOneRequiredWithoutNetworksNestedInput = {
    create?: XOR<CompanyCreateWithoutNetworksInput, CompanyUncheckedCreateWithoutNetworksInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutNetworksInput
    upsert?: CompanyUpsertWithoutNetworksInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutNetworksInput, CompanyUpdateWithoutNetworksInput>, CompanyUncheckedUpdateWithoutNetworksInput>
  }

  export type NetworkProviderUpdateOneWithoutNetworksNestedInput = {
    create?: XOR<NetworkProviderCreateWithoutNetworksInput, NetworkProviderUncheckedCreateWithoutNetworksInput>
    connectOrCreate?: NetworkProviderCreateOrConnectWithoutNetworksInput
    upsert?: NetworkProviderUpsertWithoutNetworksInput
    disconnect?: NetworkProviderWhereInput | boolean
    delete?: NetworkProviderWhereInput | boolean
    connect?: NetworkProviderWhereUniqueInput
    update?: XOR<XOR<NetworkProviderUpdateToOneWithWhereWithoutNetworksInput, NetworkProviderUpdateWithoutNetworksInput>, NetworkProviderUncheckedUpdateWithoutNetworksInput>
  }

  export type PersonCreateNestedManyWithoutAssignedExpensesInput = {
    create?: XOR<PersonCreateWithoutAssignedExpensesInput, PersonUncheckedCreateWithoutAssignedExpensesInput> | PersonCreateWithoutAssignedExpensesInput[] | PersonUncheckedCreateWithoutAssignedExpensesInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutAssignedExpensesInput | PersonCreateOrConnectWithoutAssignedExpensesInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
  }

  export type PersonUncheckedCreateNestedManyWithoutAssignedExpensesInput = {
    create?: XOR<PersonCreateWithoutAssignedExpensesInput, PersonUncheckedCreateWithoutAssignedExpensesInput> | PersonCreateWithoutAssignedExpensesInput[] | PersonUncheckedCreateWithoutAssignedExpensesInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutAssignedExpensesInput | PersonCreateOrConnectWithoutAssignedExpensesInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
  }

  export type EnumSoftwareCategoryFieldUpdateOperationsInput = {
    set?: $Enums.SoftwareCategory
  }

  export type EnumExpenseStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseStatus
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumPaymentFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.PaymentFrequency
  }

  export type PersonUpdateManyWithoutAssignedExpensesNestedInput = {
    create?: XOR<PersonCreateWithoutAssignedExpensesInput, PersonUncheckedCreateWithoutAssignedExpensesInput> | PersonCreateWithoutAssignedExpensesInput[] | PersonUncheckedCreateWithoutAssignedExpensesInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutAssignedExpensesInput | PersonCreateOrConnectWithoutAssignedExpensesInput[]
    upsert?: PersonUpsertWithWhereUniqueWithoutAssignedExpensesInput | PersonUpsertWithWhereUniqueWithoutAssignedExpensesInput[]
    set?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    disconnect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    delete?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    update?: PersonUpdateWithWhereUniqueWithoutAssignedExpensesInput | PersonUpdateWithWhereUniqueWithoutAssignedExpensesInput[]
    updateMany?: PersonUpdateManyWithWhereWithoutAssignedExpensesInput | PersonUpdateManyWithWhereWithoutAssignedExpensesInput[]
    deleteMany?: PersonScalarWhereInput | PersonScalarWhereInput[]
  }

  export type PersonUncheckedUpdateManyWithoutAssignedExpensesNestedInput = {
    create?: XOR<PersonCreateWithoutAssignedExpensesInput, PersonUncheckedCreateWithoutAssignedExpensesInput> | PersonCreateWithoutAssignedExpensesInput[] | PersonUncheckedCreateWithoutAssignedExpensesInput[]
    connectOrCreate?: PersonCreateOrConnectWithoutAssignedExpensesInput | PersonCreateOrConnectWithoutAssignedExpensesInput[]
    upsert?: PersonUpsertWithWhereUniqueWithoutAssignedExpensesInput | PersonUpsertWithWhereUniqueWithoutAssignedExpensesInput[]
    set?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    disconnect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    delete?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    connect?: PersonWhereUniqueInput | PersonWhereUniqueInput[]
    update?: PersonUpdateWithWhereUniqueWithoutAssignedExpensesInput | PersonUpdateWithWhereUniqueWithoutAssignedExpensesInput[]
    updateMany?: PersonUpdateManyWithWhereWithoutAssignedExpensesInput | PersonUpdateManyWithWhereWithoutAssignedExpensesInput[]
    deleteMany?: PersonScalarWhereInput | PersonScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTicketTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeFilter<$PrismaModel> | $Enums.TicketType
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketType | EnumTicketTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketType[] | ListEnumTicketTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketTypeWithAggregatesFilter<$PrismaModel> | $Enums.TicketType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketTypeFilter<$PrismaModel>
    _max?: NestedEnumTicketTypeFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumPersonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonStatus | EnumPersonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PersonStatus[] | ListEnumPersonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonStatus[] | ListEnumPersonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonStatusFilter<$PrismaModel> | $Enums.PersonStatus
  }

  export type NestedEnumPersonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PersonStatus | EnumPersonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PersonStatus[] | ListEnumPersonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PersonStatus[] | ListEnumPersonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPersonStatusWithAggregatesFilter<$PrismaModel> | $Enums.PersonStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPersonStatusFilter<$PrismaModel>
    _max?: NestedEnumPersonStatusFilter<$PrismaModel>
  }

  export type NestedEnumEquipmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusFilter<$PrismaModel> | $Enums.EquipmentStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EquipmentStatus | EnumEquipmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EquipmentStatus[] | ListEnumEquipmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEquipmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.EquipmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEquipmentStatusFilter<$PrismaModel>
    _max?: NestedEnumEquipmentStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeFilter<$PrismaModel> | $Enums.MaintenanceType
  }

  export type NestedEnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type NestedEnumMaintenanceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceType | EnumMaintenanceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceType[] | ListEnumMaintenanceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceTypeWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceTypeFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MaintenanceStatus[] | ListEnumMaintenanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumNetworkDeviceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NetworkDeviceStatus | EnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NetworkDeviceStatus[] | ListEnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NetworkDeviceStatus[] | ListEnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNetworkDeviceStatusFilter<$PrismaModel> | $Enums.NetworkDeviceStatus
  }

  export type NestedEnumNetworkDeviceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NetworkDeviceStatus | EnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NetworkDeviceStatus[] | ListEnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NetworkDeviceStatus[] | ListEnumNetworkDeviceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNetworkDeviceStatusWithAggregatesFilter<$PrismaModel> | $Enums.NetworkDeviceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNetworkDeviceStatusFilter<$PrismaModel>
    _max?: NestedEnumNetworkDeviceStatusFilter<$PrismaModel>
  }

  export type NestedEnumSoftwareCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.SoftwareCategory | EnumSoftwareCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SoftwareCategory[] | ListEnumSoftwareCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SoftwareCategory[] | ListEnumSoftwareCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSoftwareCategoryFilter<$PrismaModel> | $Enums.SoftwareCategory
  }

  export type NestedEnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPaymentFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentFrequency | EnumPaymentFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentFrequency[] | ListEnumPaymentFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentFrequency[] | ListEnumPaymentFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentFrequencyFilter<$PrismaModel> | $Enums.PaymentFrequency
  }

  export type NestedEnumSoftwareCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SoftwareCategory | EnumSoftwareCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.SoftwareCategory[] | ListEnumSoftwareCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.SoftwareCategory[] | ListEnumSoftwareCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumSoftwareCategoryWithAggregatesFilter<$PrismaModel> | $Enums.SoftwareCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSoftwareCategoryFilter<$PrismaModel>
    _max?: NestedEnumSoftwareCategoryFilter<$PrismaModel>
  }

  export type NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumPaymentFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentFrequency | EnumPaymentFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentFrequency[] | ListEnumPaymentFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentFrequency[] | ListEnumPaymentFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.PaymentFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentFrequencyFilter<$PrismaModel>
    _max?: NestedEnumPaymentFrequencyFilter<$PrismaModel>
  }

  export type UserCreateWithoutTicketsSentByInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkCreateNestedManyWithoutCreatedByInput
    person?: PersonCreateNestedOneWithoutUserInput
    ticketsSentTo?: TicketCreateNestedManyWithoutSendToInput
  }

  export type UserUncheckedCreateWithoutTicketsSentByInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyUncheckedCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkUncheckedCreateNestedManyWithoutCreatedByInput
    person?: PersonUncheckedCreateNestedOneWithoutUserInput
    ticketsSentTo?: TicketUncheckedCreateNestedManyWithoutSendToInput
  }

  export type UserCreateOrConnectWithoutTicketsSentByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsSentByInput, UserUncheckedCreateWithoutTicketsSentByInput>
  }

  export type UserCreateWithoutTicketsSentToInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkCreateNestedManyWithoutCreatedByInput
    person?: PersonCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketCreateNestedManyWithoutSendByInput
  }

  export type UserUncheckedCreateWithoutTicketsSentToInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyUncheckedCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkUncheckedCreateNestedManyWithoutCreatedByInput
    person?: PersonUncheckedCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketUncheckedCreateNestedManyWithoutSendByInput
  }

  export type UserCreateOrConnectWithoutTicketsSentToInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsSentToInput, UserUncheckedCreateWithoutTicketsSentToInput>
  }

  export type CompanyCreateWithoutTicketsInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTicketsInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTicketsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTicketsInput, CompanyUncheckedCreateWithoutTicketsInput>
  }

  export type UserUpsertWithoutTicketsSentByInput = {
    update: XOR<UserUpdateWithoutTicketsSentByInput, UserUncheckedUpdateWithoutTicketsSentByInput>
    create: XOR<UserCreateWithoutTicketsSentByInput, UserUncheckedCreateWithoutTicketsSentByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsSentByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsSentByInput, UserUncheckedUpdateWithoutTicketsSentByInput>
  }

  export type UserUpdateWithoutTicketsSentByInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUpdateManyWithoutCreatedByNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    ticketsSentTo?: TicketUpdateManyWithoutSendToNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsSentByInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUncheckedUpdateManyWithoutCreatedByNestedInput
    person?: PersonUncheckedUpdateOneWithoutUserNestedInput
    ticketsSentTo?: TicketUncheckedUpdateManyWithoutSendToNestedInput
  }

  export type UserUpsertWithoutTicketsSentToInput = {
    update: XOR<UserUpdateWithoutTicketsSentToInput, UserUncheckedUpdateWithoutTicketsSentToInput>
    create: XOR<UserCreateWithoutTicketsSentToInput, UserUncheckedCreateWithoutTicketsSentToInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsSentToInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsSentToInput, UserUncheckedUpdateWithoutTicketsSentToInput>
  }

  export type UserUpdateWithoutTicketsSentToInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUpdateManyWithoutCreatedByNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUpdateManyWithoutSendByNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsSentToInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUncheckedUpdateManyWithoutCreatedByNestedInput
    person?: PersonUncheckedUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUncheckedUpdateManyWithoutSendByNestedInput
  }

  export type CompanyUpsertWithoutTicketsInput = {
    update: XOR<CompanyUpdateWithoutTicketsInput, CompanyUncheckedUpdateWithoutTicketsInput>
    create: XOR<CompanyCreateWithoutTicketsInput, CompanyUncheckedCreateWithoutTicketsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTicketsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTicketsInput, CompanyUncheckedUpdateWithoutTicketsInput>
  }

  export type CompanyUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCompanyCreateWithoutUserInput = {
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type UserCompanyUncheckedCreateWithoutUserInput = {
    companyId: string
  }

  export type UserCompanyCreateOrConnectWithoutUserInput = {
    where: UserCompanyWhereUniqueInput
    create: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput>
  }

  export type UserCompanyCreateManyUserInputEnvelope = {
    data: UserCompanyCreateManyUserInput | UserCompanyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutCreatedByInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutCreatedByInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutCreatedByInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutCreatedByInput, CompanyUncheckedCreateWithoutCreatedByInput>
  }

  export type CompanyCreateManyCreatedByInputEnvelope = {
    data: CompanyCreateManyCreatedByInput | CompanyCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutAssignedToUserInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endUser?: string | null
    operatingSystem?: string | null
    documents?: DocumentCreateNestedManyWithoutEquipmentInput
    company: CompanyCreateNestedOneWithoutEquipmentsInput
    maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutAssignedToUserInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    endUser?: string | null
    operatingSystem?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutEquipmentInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutAssignedToUserInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutAssignedToUserInput, EquipmentUncheckedCreateWithoutAssignedToUserInput>
  }

  export type EquipmentCreateManyAssignedToUserInputEnvelope = {
    data: EquipmentCreateManyAssignedToUserInput | EquipmentCreateManyAssignedToUserInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceCreateWithoutAssignedToUserInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutMaintenancesInput
    equipment: EquipmentCreateNestedOneWithoutMaintenancesInput
  }

  export type MaintenanceUncheckedCreateWithoutAssignedToUserInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentId: string
    companyId: string
  }

  export type MaintenanceCreateOrConnectWithoutAssignedToUserInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutAssignedToUserInput, MaintenanceUncheckedCreateWithoutAssignedToUserInput>
  }

  export type MaintenanceCreateManyAssignedToUserInputEnvelope = {
    data: MaintenanceCreateManyAssignedToUserInput | MaintenanceCreateManyAssignedToUserInput[]
    skipDuplicates?: boolean
  }

  export type NetworkCreateWithoutAssignedToUserInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedNetworksInput
    company: CompanyCreateNestedOneWithoutNetworksInput
    provider?: NetworkProviderCreateNestedOneWithoutNetworksInput
  }

  export type NetworkUncheckedCreateWithoutAssignedToUserInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    createdByUserId?: string | null
    providerId?: string | null
  }

  export type NetworkCreateOrConnectWithoutAssignedToUserInput = {
    where: NetworkWhereUniqueInput
    create: XOR<NetworkCreateWithoutAssignedToUserInput, NetworkUncheckedCreateWithoutAssignedToUserInput>
  }

  export type NetworkCreateManyAssignedToUserInputEnvelope = {
    data: NetworkCreateManyAssignedToUserInput | NetworkCreateManyAssignedToUserInput[]
    skipDuplicates?: boolean
  }

  export type NetworkCreateWithoutCreatedByInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUser?: UserCreateNestedOneWithoutAssignedNetworksInput
    company: CompanyCreateNestedOneWithoutNetworksInput
    provider?: NetworkProviderCreateNestedOneWithoutNetworksInput
  }

  export type NetworkUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    providerId?: string | null
  }

  export type NetworkCreateOrConnectWithoutCreatedByInput = {
    where: NetworkWhereUniqueInput
    create: XOR<NetworkCreateWithoutCreatedByInput, NetworkUncheckedCreateWithoutCreatedByInput>
  }

  export type NetworkCreateManyCreatedByInputEnvelope = {
    data: NetworkCreateManyCreatedByInput | NetworkCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PersonCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    department?: DepartmentCreateNestedOneWithoutPersonsInput
    assignedExpenses?: AnnualSoftwareExpenseCreateNestedManyWithoutAssignedPersonsInput
  }

  export type PersonUncheckedCreateWithoutUserInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    departmentId?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    assignedExpenses?: AnnualSoftwareExpenseUncheckedCreateNestedManyWithoutAssignedPersonsInput
  }

  export type PersonCreateOrConnectWithoutUserInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
  }

  export type TicketCreateWithoutSendByInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
    sendTo?: UserCreateNestedOneWithoutTicketsSentToInput
    company?: CompanyCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutSendByInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    sendToId?: string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
  }

  export type TicketCreateOrConnectWithoutSendByInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutSendByInput, TicketUncheckedCreateWithoutSendByInput>
  }

  export type TicketCreateManySendByInputEnvelope = {
    data: TicketCreateManySendByInput | TicketCreateManySendByInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutSendToInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
    sendBy?: UserCreateNestedOneWithoutTicketsSentByInput
    company?: CompanyCreateNestedOneWithoutTicketsInput
  }

  export type TicketUncheckedCreateWithoutSendToInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    sendById?: string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
  }

  export type TicketCreateOrConnectWithoutSendToInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutSendToInput, TicketUncheckedCreateWithoutSendToInput>
  }

  export type TicketCreateManySendToInputEnvelope = {
    data: TicketCreateManySendToInput | TicketCreateManySendToInput[]
    skipDuplicates?: boolean
  }

  export type UserCompanyUpsertWithWhereUniqueWithoutUserInput = {
    where: UserCompanyWhereUniqueInput
    update: XOR<UserCompanyUpdateWithoutUserInput, UserCompanyUncheckedUpdateWithoutUserInput>
    create: XOR<UserCompanyCreateWithoutUserInput, UserCompanyUncheckedCreateWithoutUserInput>
  }

  export type UserCompanyUpdateWithWhereUniqueWithoutUserInput = {
    where: UserCompanyWhereUniqueInput
    data: XOR<UserCompanyUpdateWithoutUserInput, UserCompanyUncheckedUpdateWithoutUserInput>
  }

  export type UserCompanyUpdateManyWithWhereWithoutUserInput = {
    where: UserCompanyScalarWhereInput
    data: XOR<UserCompanyUpdateManyMutationInput, UserCompanyUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCompanyScalarWhereInput = {
    AND?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
    OR?: UserCompanyScalarWhereInput[]
    NOT?: UserCompanyScalarWhereInput | UserCompanyScalarWhereInput[]
    userId?: StringFilter<"UserCompany"> | string
    companyId?: StringFilter<"UserCompany"> | string
  }

  export type CompanyUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: CompanyWhereUniqueInput
    update: XOR<CompanyUpdateWithoutCreatedByInput, CompanyUncheckedUpdateWithoutCreatedByInput>
    create: XOR<CompanyCreateWithoutCreatedByInput, CompanyUncheckedCreateWithoutCreatedByInput>
  }

  export type CompanyUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: CompanyWhereUniqueInput
    data: XOR<CompanyUpdateWithoutCreatedByInput, CompanyUncheckedUpdateWithoutCreatedByInput>
  }

  export type CompanyUpdateManyWithWhereWithoutCreatedByInput = {
    where: CompanyScalarWhereInput
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type CompanyScalarWhereInput = {
    AND?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    OR?: CompanyScalarWhereInput[]
    NOT?: CompanyScalarWhereInput | CompanyScalarWhereInput[]
    id?: StringFilter<"Company"> | string
    code?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    address?: StringNullableFilter<"Company"> | string | null
    phone?: StringNullableFilter<"Company"> | string | null
    email?: StringNullableFilter<"Company"> | string | null
    ruc?: StringNullableFilter<"Company"> | string | null
    logoUrl?: StringNullableFilter<"Company"> | string | null
    isActive?: BoolFilter<"Company"> | boolean
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    createdByUserId?: StringNullableFilter<"Company"> | string | null
  }

  export type EquipmentUpsertWithWhereUniqueWithoutAssignedToUserInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutAssignedToUserInput, EquipmentUncheckedUpdateWithoutAssignedToUserInput>
    create: XOR<EquipmentCreateWithoutAssignedToUserInput, EquipmentUncheckedCreateWithoutAssignedToUserInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutAssignedToUserInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutAssignedToUserInput, EquipmentUncheckedUpdateWithoutAssignedToUserInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutAssignedToUserInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutAssignedToUserInput>
  }

  export type EquipmentScalarWhereInput = {
    AND?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    OR?: EquipmentScalarWhereInput[]
    NOT?: EquipmentScalarWhereInput | EquipmentScalarWhereInput[]
    id?: StringFilter<"Equipment"> | string
    type?: StringFilter<"Equipment"> | string
    brand?: StringFilter<"Equipment"> | string
    model?: StringFilter<"Equipment"> | string
    serialNumber?: StringFilter<"Equipment"> | string
    plateNumber?: StringNullableFilter<"Equipment"> | string | null
    location?: StringNullableFilter<"Equipment"> | string | null
    status?: EnumEquipmentStatusFilter<"Equipment"> | $Enums.EquipmentStatus
    acquisitionDate?: DateTimeNullableFilter<"Equipment"> | Date | string | null
    warrantyDetails?: StringNullableFilter<"Equipment"> | string | null
    qrCode?: StringNullableFilter<"Equipment"> | string | null
    invoiceUrl?: StringNullableFilter<"Equipment"> | string | null
    cost?: DecimalNullableFilter<"Equipment"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Equipment"> | Date | string
    updatedAt?: DateTimeFilter<"Equipment"> | Date | string
    companyId?: StringFilter<"Equipment"> | string
    assignedToUserId?: StringNullableFilter<"Equipment"> | string | null
    endUser?: StringNullableFilter<"Equipment"> | string | null
    operatingSystem?: StringNullableFilter<"Equipment"> | string | null
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutAssignedToUserInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutAssignedToUserInput, MaintenanceUncheckedUpdateWithoutAssignedToUserInput>
    create: XOR<MaintenanceCreateWithoutAssignedToUserInput, MaintenanceUncheckedCreateWithoutAssignedToUserInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutAssignedToUserInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutAssignedToUserInput, MaintenanceUncheckedUpdateWithoutAssignedToUserInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutAssignedToUserInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutAssignedToUserInput>
  }

  export type MaintenanceScalarWhereInput = {
    AND?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    OR?: MaintenanceScalarWhereInput[]
    NOT?: MaintenanceScalarWhereInput | MaintenanceScalarWhereInput[]
    id?: StringFilter<"Maintenance"> | string
    title?: StringFilter<"Maintenance"> | string
    description?: StringNullableFilter<"Maintenance"> | string | null
    type?: EnumMaintenanceTypeFilter<"Maintenance"> | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFilter<"Maintenance"> | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFilter<"Maintenance"> | Date | string
    completionDate?: DateTimeNullableFilter<"Maintenance"> | Date | string | null
    cost?: DecimalNullableFilter<"Maintenance"> | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFilter<"Maintenance"> | Date | string
    updatedAt?: DateTimeFilter<"Maintenance"> | Date | string
    equipmentId?: StringFilter<"Maintenance"> | string
    assignedToUserId?: StringNullableFilter<"Maintenance"> | string | null
    companyId?: StringFilter<"Maintenance"> | string
  }

  export type NetworkUpsertWithWhereUniqueWithoutAssignedToUserInput = {
    where: NetworkWhereUniqueInput
    update: XOR<NetworkUpdateWithoutAssignedToUserInput, NetworkUncheckedUpdateWithoutAssignedToUserInput>
    create: XOR<NetworkCreateWithoutAssignedToUserInput, NetworkUncheckedCreateWithoutAssignedToUserInput>
  }

  export type NetworkUpdateWithWhereUniqueWithoutAssignedToUserInput = {
    where: NetworkWhereUniqueInput
    data: XOR<NetworkUpdateWithoutAssignedToUserInput, NetworkUncheckedUpdateWithoutAssignedToUserInput>
  }

  export type NetworkUpdateManyWithWhereWithoutAssignedToUserInput = {
    where: NetworkScalarWhereInput
    data: XOR<NetworkUpdateManyMutationInput, NetworkUncheckedUpdateManyWithoutAssignedToUserInput>
  }

  export type NetworkScalarWhereInput = {
    AND?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
    OR?: NetworkScalarWhereInput[]
    NOT?: NetworkScalarWhereInput | NetworkScalarWhereInput[]
    id?: StringFilter<"Network"> | string
    name?: StringFilter<"Network"> | string
    status?: EnumNetworkDeviceStatusFilter<"Network"> | $Enums.NetworkDeviceStatus
    location?: StringNullableFilter<"Network"> | string | null
    description?: StringNullableFilter<"Network"> | string | null
    notes?: StringNullableFilter<"Network"> | string | null
    ssid?: StringNullableFilter<"Network"> | string | null
    password?: StringNullableFilter<"Network"> | string | null
    ip?: StringNullableFilter<"Network"> | string | null
    dns?: StringNullableFilter<"Network"> | string | null
    gw?: StringNullableFilter<"Network"> | string | null
    uploadSpeed?: StringNullableFilter<"Network"> | string | null
    downloadSpeed?: StringNullableFilter<"Network"> | string | null
    createdAt?: DateTimeFilter<"Network"> | Date | string
    updatedAt?: DateTimeFilter<"Network"> | Date | string
    companyId?: StringFilter<"Network"> | string
    assignedToUserId?: StringNullableFilter<"Network"> | string | null
    createdByUserId?: StringNullableFilter<"Network"> | string | null
    providerId?: StringNullableFilter<"Network"> | string | null
  }

  export type NetworkUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: NetworkWhereUniqueInput
    update: XOR<NetworkUpdateWithoutCreatedByInput, NetworkUncheckedUpdateWithoutCreatedByInput>
    create: XOR<NetworkCreateWithoutCreatedByInput, NetworkUncheckedCreateWithoutCreatedByInput>
  }

  export type NetworkUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: NetworkWhereUniqueInput
    data: XOR<NetworkUpdateWithoutCreatedByInput, NetworkUncheckedUpdateWithoutCreatedByInput>
  }

  export type NetworkUpdateManyWithWhereWithoutCreatedByInput = {
    where: NetworkScalarWhereInput
    data: XOR<NetworkUpdateManyMutationInput, NetworkUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PersonUpsertWithoutUserInput = {
    update: XOR<PersonUpdateWithoutUserInput, PersonUncheckedUpdateWithoutUserInput>
    create: XOR<PersonCreateWithoutUserInput, PersonUncheckedCreateWithoutUserInput>
    where?: PersonWhereInput
  }

  export type PersonUpdateToOneWithWhereWithoutUserInput = {
    where?: PersonWhereInput
    data: XOR<PersonUpdateWithoutUserInput, PersonUncheckedUpdateWithoutUserInput>
  }

  export type PersonUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutPersonsNestedInput
    assignedExpenses?: AnnualSoftwareExpenseUpdateManyWithoutAssignedPersonsNestedInput
  }

  export type PersonUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedExpenses?: AnnualSoftwareExpenseUncheckedUpdateManyWithoutAssignedPersonsNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutSendByInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutSendByInput, TicketUncheckedUpdateWithoutSendByInput>
    create: XOR<TicketCreateWithoutSendByInput, TicketUncheckedCreateWithoutSendByInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutSendByInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutSendByInput, TicketUncheckedUpdateWithoutSendByInput>
  }

  export type TicketUpdateManyWithWhereWithoutSendByInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutSendByInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    ticketNumber?: IntNullableFilter<"Ticket"> | number | null
    title?: StringFilter<"Ticket"> | string
    description?: StringFilter<"Ticket"> | string
    img?: StringNullableFilter<"Ticket"> | string | null
    comment?: StringNullableFilter<"Ticket"> | string | null
    type?: EnumTicketTypeFilter<"Ticket"> | $Enums.TicketType
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    startDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Ticket"> | Date | string | null
    requestDays?: IntNullableFilter<"Ticket"> | number | null
    approvedDays?: IntNullableFilter<"Ticket"> | number | null
    view?: BoolNullableFilter<"Ticket"> | boolean | null
    sendById?: StringNullableFilter<"Ticket"> | string | null
    sendToId?: StringNullableFilter<"Ticket"> | string | null
    companyId?: StringNullableFilter<"Ticket"> | string | null
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    reviewed?: BoolNullableFilter<"Ticket"> | boolean | null
  }

  export type TicketUpsertWithWhereUniqueWithoutSendToInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutSendToInput, TicketUncheckedUpdateWithoutSendToInput>
    create: XOR<TicketCreateWithoutSendToInput, TicketUncheckedCreateWithoutSendToInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutSendToInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutSendToInput, TicketUncheckedUpdateWithoutSendToInput>
  }

  export type TicketUpdateManyWithWhereWithoutSendToInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutSendToInput>
  }

  export type UserCreateWithoutCompaniesInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCompanies?: CompanyCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkCreateNestedManyWithoutCreatedByInput
    person?: PersonCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketCreateNestedManyWithoutSendToInput
  }

  export type UserUncheckedCreateWithoutCompaniesInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCompanies?: CompanyUncheckedCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkUncheckedCreateNestedManyWithoutCreatedByInput
    person?: PersonUncheckedCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketUncheckedCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketUncheckedCreateNestedManyWithoutSendToInput
  }

  export type UserCreateOrConnectWithoutCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutCompaniesInput = {
    update: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
    create: XOR<UserCreateWithoutCompaniesInput, UserUncheckedCreateWithoutCompaniesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompaniesInput, UserUncheckedUpdateWithoutCompaniesInput>
  }

  export type UserUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCompanies?: CompanyUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUpdateManyWithoutCreatedByNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUpdateManyWithoutSendToNestedInput
  }

  export type UserUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCompanies?: CompanyUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUncheckedUpdateManyWithoutCreatedByNestedInput
    person?: PersonUncheckedUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUncheckedUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUncheckedUpdateManyWithoutSendToNestedInput
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type DepartmentCreateWithoutPersonsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDepartmentsInput
  }

  export type DepartmentUncheckedCreateWithoutPersonsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DepartmentCreateOrConnectWithoutPersonsInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutPersonsInput, DepartmentUncheckedCreateWithoutPersonsInput>
  }

  export type UserCreateWithoutPersonInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkCreateNestedManyWithoutCreatedByInput
    ticketsSentBy?: TicketCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketCreateNestedManyWithoutSendToInput
  }

  export type UserUncheckedCreateWithoutPersonInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyUncheckedCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkUncheckedCreateNestedManyWithoutCreatedByInput
    ticketsSentBy?: TicketUncheckedCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketUncheckedCreateNestedManyWithoutSendToInput
  }

  export type UserCreateOrConnectWithoutPersonInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
  }

  export type AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput = {
    id?: string
    applicationName: string
    provider: string
    category: $Enums.SoftwareCategory
    status: $Enums.ExpenseStatus
    annualCost: number
    numberOfUsers: number
    costPerUser: number
    renewalDate: Date | string
    paymentFrequency: $Enums.PaymentFrequency
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput = {
    id?: string
    applicationName: string
    provider: string
    category: $Enums.SoftwareCategory
    status: $Enums.ExpenseStatus
    annualCost: number
    numberOfUsers: number
    costPerUser: number
    renewalDate: Date | string
    paymentFrequency: $Enums.PaymentFrequency
    additionalNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnnualSoftwareExpenseCreateOrConnectWithoutAssignedPersonsInput = {
    where: AnnualSoftwareExpenseWhereUniqueInput
    create: XOR<AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput, AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput>
  }

  export type DepartmentUpsertWithoutPersonsInput = {
    update: XOR<DepartmentUpdateWithoutPersonsInput, DepartmentUncheckedUpdateWithoutPersonsInput>
    create: XOR<DepartmentCreateWithoutPersonsInput, DepartmentUncheckedCreateWithoutPersonsInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutPersonsInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutPersonsInput, DepartmentUncheckedUpdateWithoutPersonsInput>
  }

  export type DepartmentUpdateWithoutPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDepartmentsNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutPersonInput = {
    update: XOR<UserUpdateWithoutPersonInput, UserUncheckedUpdateWithoutPersonInput>
    create: XOR<UserCreateWithoutPersonInput, UserUncheckedCreateWithoutPersonInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPersonInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPersonInput, UserUncheckedUpdateWithoutPersonInput>
  }

  export type UserUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUpdateManyWithoutCreatedByNestedInput
    ticketsSentBy?: TicketUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUpdateManyWithoutSendToNestedInput
  }

  export type UserUncheckedUpdateWithoutPersonInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUncheckedUpdateManyWithoutCreatedByNestedInput
    ticketsSentBy?: TicketUncheckedUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUncheckedUpdateManyWithoutSendToNestedInput
  }

  export type AnnualSoftwareExpenseUpsertWithWhereUniqueWithoutAssignedPersonsInput = {
    where: AnnualSoftwareExpenseWhereUniqueInput
    update: XOR<AnnualSoftwareExpenseUpdateWithoutAssignedPersonsInput, AnnualSoftwareExpenseUncheckedUpdateWithoutAssignedPersonsInput>
    create: XOR<AnnualSoftwareExpenseCreateWithoutAssignedPersonsInput, AnnualSoftwareExpenseUncheckedCreateWithoutAssignedPersonsInput>
  }

  export type AnnualSoftwareExpenseUpdateWithWhereUniqueWithoutAssignedPersonsInput = {
    where: AnnualSoftwareExpenseWhereUniqueInput
    data: XOR<AnnualSoftwareExpenseUpdateWithoutAssignedPersonsInput, AnnualSoftwareExpenseUncheckedUpdateWithoutAssignedPersonsInput>
  }

  export type AnnualSoftwareExpenseUpdateManyWithWhereWithoutAssignedPersonsInput = {
    where: AnnualSoftwareExpenseScalarWhereInput
    data: XOR<AnnualSoftwareExpenseUpdateManyMutationInput, AnnualSoftwareExpenseUncheckedUpdateManyWithoutAssignedPersonsInput>
  }

  export type AnnualSoftwareExpenseScalarWhereInput = {
    AND?: AnnualSoftwareExpenseScalarWhereInput | AnnualSoftwareExpenseScalarWhereInput[]
    OR?: AnnualSoftwareExpenseScalarWhereInput[]
    NOT?: AnnualSoftwareExpenseScalarWhereInput | AnnualSoftwareExpenseScalarWhereInput[]
    id?: StringFilter<"AnnualSoftwareExpense"> | string
    applicationName?: StringFilter<"AnnualSoftwareExpense"> | string
    provider?: StringFilter<"AnnualSoftwareExpense"> | string
    category?: EnumSoftwareCategoryFilter<"AnnualSoftwareExpense"> | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFilter<"AnnualSoftwareExpense"> | $Enums.ExpenseStatus
    annualCost?: FloatFilter<"AnnualSoftwareExpense"> | number
    numberOfUsers?: IntFilter<"AnnualSoftwareExpense"> | number
    costPerUser?: FloatFilter<"AnnualSoftwareExpense"> | number
    renewalDate?: DateTimeFilter<"AnnualSoftwareExpense"> | Date | string
    paymentFrequency?: EnumPaymentFrequencyFilter<"AnnualSoftwareExpense"> | $Enums.PaymentFrequency
    additionalNotes?: StringNullableFilter<"AnnualSoftwareExpense"> | string | null
    createdAt?: DateTimeFilter<"AnnualSoftwareExpense"> | Date | string
    updatedAt?: DateTimeFilter<"AnnualSoftwareExpense"> | Date | string
  }

  export type UserCreateWithoutCreatedCompaniesInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyCreateNestedManyWithoutUserInput
    assignedEquipments?: EquipmentCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkCreateNestedManyWithoutCreatedByInput
    person?: PersonCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketCreateNestedManyWithoutSendToInput
  }

  export type UserUncheckedCreateWithoutCreatedCompaniesInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    assignedEquipments?: EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkUncheckedCreateNestedManyWithoutCreatedByInput
    person?: PersonUncheckedCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketUncheckedCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketUncheckedCreateNestedManyWithoutSendToInput
  }

  export type UserCreateOrConnectWithoutCreatedCompaniesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedCompaniesInput, UserUncheckedCreateWithoutCreatedCompaniesInput>
  }

  export type DepartmentCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    persons?: PersonCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    persons?: PersonUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutCompanyInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput>
  }

  export type DepartmentCreateManyCompanyInputEnvelope = {
    data: DepartmentCreateManyCompanyInput | DepartmentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutCompanyInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipment?: EquipmentCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutCompanyInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentId?: string | null
  }

  export type DocumentCreateOrConnectWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentCreateManyCompanyInputEnvelope = {
    data: DocumentCreateManyCompanyInput | DocumentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type EquipmentCreateWithoutCompanyInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endUser?: string | null
    operatingSystem?: string | null
    documents?: DocumentCreateNestedManyWithoutEquipmentInput
    assignedToUser?: UserCreateNestedOneWithoutAssignedEquipmentsInput
    maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutCompanyInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUserId?: string | null
    endUser?: string | null
    operatingSystem?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutEquipmentInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutCompanyInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutCompanyInput, EquipmentUncheckedCreateWithoutCompanyInput>
  }

  export type EquipmentCreateManyCompanyInputEnvelope = {
    data: EquipmentCreateManyCompanyInput | EquipmentCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type LicenseCreateWithoutCompanyInput = {
    id?: string
    softwareName: string
    licenseKey: string
    provider?: string | null
    activationDate: Date | string
    expirationDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseUncheckedCreateWithoutCompanyInput = {
    id?: string
    softwareName: string
    licenseKey: string
    provider?: string | null
    activationDate: Date | string
    expirationDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LicenseCreateOrConnectWithoutCompanyInput = {
    where: LicenseWhereUniqueInput
    create: XOR<LicenseCreateWithoutCompanyInput, LicenseUncheckedCreateWithoutCompanyInput>
  }

  export type LicenseCreateManyCompanyInputEnvelope = {
    data: LicenseCreateManyCompanyInput | LicenseCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type MaintenanceCreateWithoutCompanyInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUser?: UserCreateNestedOneWithoutAssignedMaintenancesInput
    equipment: EquipmentCreateNestedOneWithoutMaintenancesInput
  }

  export type MaintenanceUncheckedCreateWithoutCompanyInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentId: string
    assignedToUserId?: string | null
  }

  export type MaintenanceCreateOrConnectWithoutCompanyInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutCompanyInput, MaintenanceUncheckedCreateWithoutCompanyInput>
  }

  export type MaintenanceCreateManyCompanyInputEnvelope = {
    data: MaintenanceCreateManyCompanyInput | MaintenanceCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type NetworkCreateWithoutCompanyInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUser?: UserCreateNestedOneWithoutAssignedNetworksInput
    createdBy?: UserCreateNestedOneWithoutCreatedNetworksInput
    provider?: NetworkProviderCreateNestedOneWithoutNetworksInput
  }

  export type NetworkUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUserId?: string | null
    createdByUserId?: string | null
    providerId?: string | null
  }

  export type NetworkCreateOrConnectWithoutCompanyInput = {
    where: NetworkWhereUniqueInput
    create: XOR<NetworkCreateWithoutCompanyInput, NetworkUncheckedCreateWithoutCompanyInput>
  }

  export type NetworkCreateManyCompanyInputEnvelope = {
    data: NetworkCreateManyCompanyInput | NetworkCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type NetworkProviderCreateWithoutCompanyInput = {
    id?: string
    name: string
    providerIp?: string | null
    dnsGateway?: string | null
    speed?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meshDevices?: string | null
    switchDevices?: string | null
    networks?: NetworkCreateNestedManyWithoutProviderInput
  }

  export type NetworkProviderUncheckedCreateWithoutCompanyInput = {
    id?: string
    name: string
    providerIp?: string | null
    dnsGateway?: string | null
    speed?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meshDevices?: string | null
    switchDevices?: string | null
    networks?: NetworkUncheckedCreateNestedManyWithoutProviderInput
  }

  export type NetworkProviderCreateOrConnectWithoutCompanyInput = {
    where: NetworkProviderWhereUniqueInput
    create: XOR<NetworkProviderCreateWithoutCompanyInput, NetworkProviderUncheckedCreateWithoutCompanyInput>
  }

  export type NetworkProviderCreateManyCompanyInputEnvelope = {
    data: NetworkProviderCreateManyCompanyInput | NetworkProviderCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutCompanyInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
    sendBy?: UserCreateNestedOneWithoutTicketsSentByInput
    sendTo?: UserCreateNestedOneWithoutTicketsSentToInput
  }

  export type TicketUncheckedCreateWithoutCompanyInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    sendById?: string | null
    sendToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
  }

  export type TicketCreateOrConnectWithoutCompanyInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput>
  }

  export type TicketCreateManyCompanyInputEnvelope = {
    data: TicketCreateManyCompanyInput | TicketCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserCompanyCreateWithoutCompanyInput = {
    user: UserCreateNestedOneWithoutCompaniesInput
  }

  export type UserCompanyUncheckedCreateWithoutCompanyInput = {
    userId: string
  }

  export type UserCompanyCreateOrConnectWithoutCompanyInput = {
    where: UserCompanyWhereUniqueInput
    create: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput>
  }

  export type UserCompanyCreateManyCompanyInputEnvelope = {
    data: UserCompanyCreateManyCompanyInput | UserCompanyCreateManyCompanyInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCreatedCompaniesInput = {
    update: XOR<UserUpdateWithoutCreatedCompaniesInput, UserUncheckedUpdateWithoutCreatedCompaniesInput>
    create: XOR<UserCreateWithoutCreatedCompaniesInput, UserUncheckedCreateWithoutCreatedCompaniesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedCompaniesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedCompaniesInput, UserUncheckedUpdateWithoutCreatedCompaniesInput>
  }

  export type UserUpdateWithoutCreatedCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUpdateManyWithoutUserNestedInput
    assignedEquipments?: EquipmentUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUpdateManyWithoutCreatedByNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUpdateManyWithoutSendToNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    assignedEquipments?: EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUncheckedUpdateManyWithoutCreatedByNestedInput
    person?: PersonUncheckedUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUncheckedUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUncheckedUpdateManyWithoutSendToNestedInput
  }

  export type DepartmentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutCompanyInput, DepartmentUncheckedUpdateWithoutCompanyInput>
    create: XOR<DepartmentCreateWithoutCompanyInput, DepartmentUncheckedCreateWithoutCompanyInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutCompanyInput, DepartmentUncheckedUpdateWithoutCompanyInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutCompanyInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    isActive?: BoolFilter<"Department"> | boolean
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    companyId?: StringFilter<"Department"> | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
    create: XOR<DocumentCreateWithoutCompanyInput, DocumentUncheckedCreateWithoutCompanyInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutCompanyInput, DocumentUncheckedUpdateWithoutCompanyInput>
  }

  export type DocumentUpdateManyWithWhereWithoutCompanyInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    description?: StringNullableFilter<"Document"> | string | null
    fileUrl?: StringFilter<"Document"> | string
    fileType?: StringNullableFilter<"Document"> | string | null
    category?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    companyId?: StringFilter<"Document"> | string
    equipmentId?: StringNullableFilter<"Document"> | string | null
  }

  export type EquipmentUpsertWithWhereUniqueWithoutCompanyInput = {
    where: EquipmentWhereUniqueInput
    update: XOR<EquipmentUpdateWithoutCompanyInput, EquipmentUncheckedUpdateWithoutCompanyInput>
    create: XOR<EquipmentCreateWithoutCompanyInput, EquipmentUncheckedCreateWithoutCompanyInput>
  }

  export type EquipmentUpdateWithWhereUniqueWithoutCompanyInput = {
    where: EquipmentWhereUniqueInput
    data: XOR<EquipmentUpdateWithoutCompanyInput, EquipmentUncheckedUpdateWithoutCompanyInput>
  }

  export type EquipmentUpdateManyWithWhereWithoutCompanyInput = {
    where: EquipmentScalarWhereInput
    data: XOR<EquipmentUpdateManyMutationInput, EquipmentUncheckedUpdateManyWithoutCompanyInput>
  }

  export type LicenseUpsertWithWhereUniqueWithoutCompanyInput = {
    where: LicenseWhereUniqueInput
    update: XOR<LicenseUpdateWithoutCompanyInput, LicenseUncheckedUpdateWithoutCompanyInput>
    create: XOR<LicenseCreateWithoutCompanyInput, LicenseUncheckedCreateWithoutCompanyInput>
  }

  export type LicenseUpdateWithWhereUniqueWithoutCompanyInput = {
    where: LicenseWhereUniqueInput
    data: XOR<LicenseUpdateWithoutCompanyInput, LicenseUncheckedUpdateWithoutCompanyInput>
  }

  export type LicenseUpdateManyWithWhereWithoutCompanyInput = {
    where: LicenseScalarWhereInput
    data: XOR<LicenseUpdateManyMutationInput, LicenseUncheckedUpdateManyWithoutCompanyInput>
  }

  export type LicenseScalarWhereInput = {
    AND?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
    OR?: LicenseScalarWhereInput[]
    NOT?: LicenseScalarWhereInput | LicenseScalarWhereInput[]
    id?: StringFilter<"License"> | string
    softwareName?: StringFilter<"License"> | string
    licenseKey?: StringFilter<"License"> | string
    provider?: StringNullableFilter<"License"> | string | null
    activationDate?: DateTimeFilter<"License"> | Date | string
    expirationDate?: DateTimeNullableFilter<"License"> | Date | string | null
    notes?: StringNullableFilter<"License"> | string | null
    createdAt?: DateTimeFilter<"License"> | Date | string
    updatedAt?: DateTimeFilter<"License"> | Date | string
    companyId?: StringFilter<"License"> | string
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutCompanyInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutCompanyInput, MaintenanceUncheckedUpdateWithoutCompanyInput>
    create: XOR<MaintenanceCreateWithoutCompanyInput, MaintenanceUncheckedCreateWithoutCompanyInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutCompanyInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutCompanyInput, MaintenanceUncheckedUpdateWithoutCompanyInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutCompanyInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutCompanyInput>
  }

  export type NetworkUpsertWithWhereUniqueWithoutCompanyInput = {
    where: NetworkWhereUniqueInput
    update: XOR<NetworkUpdateWithoutCompanyInput, NetworkUncheckedUpdateWithoutCompanyInput>
    create: XOR<NetworkCreateWithoutCompanyInput, NetworkUncheckedCreateWithoutCompanyInput>
  }

  export type NetworkUpdateWithWhereUniqueWithoutCompanyInput = {
    where: NetworkWhereUniqueInput
    data: XOR<NetworkUpdateWithoutCompanyInput, NetworkUncheckedUpdateWithoutCompanyInput>
  }

  export type NetworkUpdateManyWithWhereWithoutCompanyInput = {
    where: NetworkScalarWhereInput
    data: XOR<NetworkUpdateManyMutationInput, NetworkUncheckedUpdateManyWithoutCompanyInput>
  }

  export type NetworkProviderUpsertWithWhereUniqueWithoutCompanyInput = {
    where: NetworkProviderWhereUniqueInput
    update: XOR<NetworkProviderUpdateWithoutCompanyInput, NetworkProviderUncheckedUpdateWithoutCompanyInput>
    create: XOR<NetworkProviderCreateWithoutCompanyInput, NetworkProviderUncheckedCreateWithoutCompanyInput>
  }

  export type NetworkProviderUpdateWithWhereUniqueWithoutCompanyInput = {
    where: NetworkProviderWhereUniqueInput
    data: XOR<NetworkProviderUpdateWithoutCompanyInput, NetworkProviderUncheckedUpdateWithoutCompanyInput>
  }

  export type NetworkProviderUpdateManyWithWhereWithoutCompanyInput = {
    where: NetworkProviderScalarWhereInput
    data: XOR<NetworkProviderUpdateManyMutationInput, NetworkProviderUncheckedUpdateManyWithoutCompanyInput>
  }

  export type NetworkProviderScalarWhereInput = {
    AND?: NetworkProviderScalarWhereInput | NetworkProviderScalarWhereInput[]
    OR?: NetworkProviderScalarWhereInput[]
    NOT?: NetworkProviderScalarWhereInput | NetworkProviderScalarWhereInput[]
    id?: StringFilter<"NetworkProvider"> | string
    name?: StringFilter<"NetworkProvider"> | string
    providerIp?: StringNullableFilter<"NetworkProvider"> | string | null
    dnsGateway?: StringNullableFilter<"NetworkProvider"> | string | null
    speed?: StringNullableFilter<"NetworkProvider"> | string | null
    cost?: DecimalNullableFilter<"NetworkProvider"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"NetworkProvider"> | string | null
    createdAt?: DateTimeFilter<"NetworkProvider"> | Date | string
    updatedAt?: DateTimeFilter<"NetworkProvider"> | Date | string
    meshDevices?: StringNullableFilter<"NetworkProvider"> | string | null
    switchDevices?: StringNullableFilter<"NetworkProvider"> | string | null
    companyId?: StringFilter<"NetworkProvider"> | string
  }

  export type TicketUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutCompanyInput, TicketUncheckedUpdateWithoutCompanyInput>
    create: XOR<TicketCreateWithoutCompanyInput, TicketUncheckedCreateWithoutCompanyInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutCompanyInput, TicketUncheckedUpdateWithoutCompanyInput>
  }

  export type TicketUpdateManyWithWhereWithoutCompanyInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserCompanyUpsertWithWhereUniqueWithoutCompanyInput = {
    where: UserCompanyWhereUniqueInput
    update: XOR<UserCompanyUpdateWithoutCompanyInput, UserCompanyUncheckedUpdateWithoutCompanyInput>
    create: XOR<UserCompanyCreateWithoutCompanyInput, UserCompanyUncheckedCreateWithoutCompanyInput>
  }

  export type UserCompanyUpdateWithWhereUniqueWithoutCompanyInput = {
    where: UserCompanyWhereUniqueInput
    data: XOR<UserCompanyUpdateWithoutCompanyInput, UserCompanyUncheckedUpdateWithoutCompanyInput>
  }

  export type UserCompanyUpdateManyWithWhereWithoutCompanyInput = {
    where: UserCompanyScalarWhereInput
    data: XOR<UserCompanyUpdateManyMutationInput, UserCompanyUncheckedUpdateManyWithoutCompanyInput>
  }

  export type CompanyCreateWithoutDepartmentsInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDepartmentsInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDepartmentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
  }

  export type PersonCreateWithoutDepartmentInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    user?: UserCreateNestedOneWithoutPersonInput
    assignedExpenses?: AnnualSoftwareExpenseCreateNestedManyWithoutAssignedPersonsInput
  }

  export type PersonUncheckedCreateWithoutDepartmentInput = {
    id?: string
    userId?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    assignedExpenses?: AnnualSoftwareExpenseUncheckedCreateNestedManyWithoutAssignedPersonsInput
  }

  export type PersonCreateOrConnectWithoutDepartmentInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutDepartmentInput, PersonUncheckedCreateWithoutDepartmentInput>
  }

  export type PersonCreateManyDepartmentInputEnvelope = {
    data: PersonCreateManyDepartmentInput | PersonCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type CompanyUpsertWithoutDepartmentsInput = {
    update: XOR<CompanyUpdateWithoutDepartmentsInput, CompanyUncheckedUpdateWithoutDepartmentsInput>
    create: XOR<CompanyCreateWithoutDepartmentsInput, CompanyUncheckedCreateWithoutDepartmentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDepartmentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDepartmentsInput, CompanyUncheckedUpdateWithoutDepartmentsInput>
  }

  export type CompanyUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDepartmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PersonUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: PersonWhereUniqueInput
    update: XOR<PersonUpdateWithoutDepartmentInput, PersonUncheckedUpdateWithoutDepartmentInput>
    create: XOR<PersonCreateWithoutDepartmentInput, PersonUncheckedCreateWithoutDepartmentInput>
  }

  export type PersonUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: PersonWhereUniqueInput
    data: XOR<PersonUpdateWithoutDepartmentInput, PersonUncheckedUpdateWithoutDepartmentInput>
  }

  export type PersonUpdateManyWithWhereWithoutDepartmentInput = {
    where: PersonScalarWhereInput
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type PersonScalarWhereInput = {
    AND?: PersonScalarWhereInput | PersonScalarWhereInput[]
    OR?: PersonScalarWhereInput[]
    NOT?: PersonScalarWhereInput | PersonScalarWhereInput[]
    id?: StringFilter<"Person"> | string
    userId?: StringNullableFilter<"Person"> | string | null
    firstName?: StringNullableFilter<"Person"> | string | null
    lastName?: StringNullableFilter<"Person"> | string | null
    fullName?: StringNullableFilter<"Person"> | string | null
    contactEmail?: StringNullableFilter<"Person"> | string | null
    phoneNumber?: StringNullableFilter<"Person"> | string | null
    departmentId?: StringNullableFilter<"Person"> | string | null
    position?: StringNullableFilter<"Person"> | string | null
    status?: EnumPersonStatusFilter<"Person"> | $Enums.PersonStatus
    userCode?: StringFilter<"Person"> | string
    createdAt?: DateTimeFilter<"Person"> | Date | string
    updatedAt?: DateTimeFilter<"Person"> | Date | string
    companyId?: StringNullableFilter<"Person"> | string | null
  }

  export type DocumentCreateWithoutEquipmentInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutEquipmentInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type DocumentCreateOrConnectWithoutEquipmentInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutEquipmentInput, DocumentUncheckedCreateWithoutEquipmentInput>
  }

  export type DocumentCreateManyEquipmentInputEnvelope = {
    data: DocumentCreateManyEquipmentInput | DocumentCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAssignedEquipmentsInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyCreateNestedManyWithoutCreatedByInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkCreateNestedManyWithoutCreatedByInput
    person?: PersonCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketCreateNestedManyWithoutSendToInput
  }

  export type UserUncheckedCreateWithoutAssignedEquipmentsInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyUncheckedCreateNestedManyWithoutCreatedByInput
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkUncheckedCreateNestedManyWithoutCreatedByInput
    person?: PersonUncheckedCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketUncheckedCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketUncheckedCreateNestedManyWithoutSendToInput
  }

  export type UserCreateOrConnectWithoutAssignedEquipmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedEquipmentsInput, UserUncheckedCreateWithoutAssignedEquipmentsInput>
  }

  export type CompanyCreateWithoutEquipmentsInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutEquipmentsInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutEquipmentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutEquipmentsInput, CompanyUncheckedCreateWithoutEquipmentsInput>
  }

  export type MaintenanceCreateWithoutEquipmentInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUser?: UserCreateNestedOneWithoutAssignedMaintenancesInput
    company: CompanyCreateNestedOneWithoutMaintenancesInput
  }

  export type MaintenanceUncheckedCreateWithoutEquipmentInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUserId?: string | null
    companyId: string
  }

  export type MaintenanceCreateOrConnectWithoutEquipmentInput = {
    where: MaintenanceWhereUniqueInput
    create: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceCreateManyEquipmentInputEnvelope = {
    data: MaintenanceCreateManyEquipmentInput | MaintenanceCreateManyEquipmentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutEquipmentInput, DocumentUncheckedUpdateWithoutEquipmentInput>
    create: XOR<DocumentCreateWithoutEquipmentInput, DocumentUncheckedCreateWithoutEquipmentInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutEquipmentInput, DocumentUncheckedUpdateWithoutEquipmentInput>
  }

  export type DocumentUpdateManyWithWhereWithoutEquipmentInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type UserUpsertWithoutAssignedEquipmentsInput = {
    update: XOR<UserUpdateWithoutAssignedEquipmentsInput, UserUncheckedUpdateWithoutAssignedEquipmentsInput>
    create: XOR<UserCreateWithoutAssignedEquipmentsInput, UserUncheckedCreateWithoutAssignedEquipmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedEquipmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedEquipmentsInput, UserUncheckedUpdateWithoutAssignedEquipmentsInput>
  }

  export type UserUpdateWithoutAssignedEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUpdateManyWithoutCreatedByNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUpdateManyWithoutCreatedByNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUpdateManyWithoutSendToNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUncheckedUpdateManyWithoutCreatedByNestedInput
    person?: PersonUncheckedUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUncheckedUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUncheckedUpdateManyWithoutSendToNestedInput
  }

  export type CompanyUpsertWithoutEquipmentsInput = {
    update: XOR<CompanyUpdateWithoutEquipmentsInput, CompanyUncheckedUpdateWithoutEquipmentsInput>
    create: XOR<CompanyCreateWithoutEquipmentsInput, CompanyUncheckedCreateWithoutEquipmentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutEquipmentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutEquipmentsInput, CompanyUncheckedUpdateWithoutEquipmentsInput>
  }

  export type CompanyUpdateWithoutEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutEquipmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type MaintenanceUpsertWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceWhereUniqueInput
    update: XOR<MaintenanceUpdateWithoutEquipmentInput, MaintenanceUncheckedUpdateWithoutEquipmentInput>
    create: XOR<MaintenanceCreateWithoutEquipmentInput, MaintenanceUncheckedCreateWithoutEquipmentInput>
  }

  export type MaintenanceUpdateWithWhereUniqueWithoutEquipmentInput = {
    where: MaintenanceWhereUniqueInput
    data: XOR<MaintenanceUpdateWithoutEquipmentInput, MaintenanceUncheckedUpdateWithoutEquipmentInput>
  }

  export type MaintenanceUpdateManyWithWhereWithoutEquipmentInput = {
    where: MaintenanceScalarWhereInput
    data: XOR<MaintenanceUpdateManyMutationInput, MaintenanceUncheckedUpdateManyWithoutEquipmentInput>
  }

  export type UserCreateWithoutAssignedMaintenancesInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkCreateNestedManyWithoutCreatedByInput
    person?: PersonCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketCreateNestedManyWithoutSendToInput
  }

  export type UserUncheckedCreateWithoutAssignedMaintenancesInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyUncheckedCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkUncheckedCreateNestedManyWithoutCreatedByInput
    person?: PersonUncheckedCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketUncheckedCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketUncheckedCreateNestedManyWithoutSendToInput
  }

  export type UserCreateOrConnectWithoutAssignedMaintenancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedMaintenancesInput, UserUncheckedCreateWithoutAssignedMaintenancesInput>
  }

  export type CompanyCreateWithoutMaintenancesInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutMaintenancesInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutMaintenancesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutMaintenancesInput, CompanyUncheckedCreateWithoutMaintenancesInput>
  }

  export type EquipmentCreateWithoutMaintenancesInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endUser?: string | null
    operatingSystem?: string | null
    documents?: DocumentCreateNestedManyWithoutEquipmentInput
    assignedToUser?: UserCreateNestedOneWithoutAssignedEquipmentsInput
    company: CompanyCreateNestedOneWithoutEquipmentsInput
  }

  export type EquipmentUncheckedCreateWithoutMaintenancesInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    endUser?: string | null
    operatingSystem?: string | null
    documents?: DocumentUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutMaintenancesInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutMaintenancesInput, EquipmentUncheckedCreateWithoutMaintenancesInput>
  }

  export type UserUpsertWithoutAssignedMaintenancesInput = {
    update: XOR<UserUpdateWithoutAssignedMaintenancesInput, UserUncheckedUpdateWithoutAssignedMaintenancesInput>
    create: XOR<UserCreateWithoutAssignedMaintenancesInput, UserUncheckedCreateWithoutAssignedMaintenancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedMaintenancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedMaintenancesInput, UserUncheckedUpdateWithoutAssignedMaintenancesInput>
  }

  export type UserUpdateWithoutAssignedMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUpdateManyWithoutCreatedByNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUpdateManyWithoutSendToNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUncheckedUpdateManyWithoutCreatedByNestedInput
    person?: PersonUncheckedUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUncheckedUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUncheckedUpdateManyWithoutSendToNestedInput
  }

  export type CompanyUpsertWithoutMaintenancesInput = {
    update: XOR<CompanyUpdateWithoutMaintenancesInput, CompanyUncheckedUpdateWithoutMaintenancesInput>
    create: XOR<CompanyCreateWithoutMaintenancesInput, CompanyUncheckedCreateWithoutMaintenancesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutMaintenancesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutMaintenancesInput, CompanyUncheckedUpdateWithoutMaintenancesInput>
  }

  export type CompanyUpdateWithoutMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EquipmentUpsertWithoutMaintenancesInput = {
    update: XOR<EquipmentUpdateWithoutMaintenancesInput, EquipmentUncheckedUpdateWithoutMaintenancesInput>
    create: XOR<EquipmentCreateWithoutMaintenancesInput, EquipmentUncheckedCreateWithoutMaintenancesInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutMaintenancesInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutMaintenancesInput, EquipmentUncheckedUpdateWithoutMaintenancesInput>
  }

  export type EquipmentUpdateWithoutMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUpdateManyWithoutEquipmentNestedInput
    assignedToUser?: UserUpdateOneWithoutAssignedEquipmentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEquipmentsNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutMaintenancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type CompanyCreateWithoutDocumentsInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDocumentsInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDocumentsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
  }

  export type EquipmentCreateWithoutDocumentsInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    endUser?: string | null
    operatingSystem?: string | null
    assignedToUser?: UserCreateNestedOneWithoutAssignedEquipmentsInput
    company: CompanyCreateNestedOneWithoutEquipmentsInput
    maintenances?: MaintenanceCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentUncheckedCreateWithoutDocumentsInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    endUser?: string | null
    operatingSystem?: string | null
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutEquipmentInput
  }

  export type EquipmentCreateOrConnectWithoutDocumentsInput = {
    where: EquipmentWhereUniqueInput
    create: XOR<EquipmentCreateWithoutDocumentsInput, EquipmentUncheckedCreateWithoutDocumentsInput>
  }

  export type CompanyUpsertWithoutDocumentsInput = {
    update: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
    create: XOR<CompanyCreateWithoutDocumentsInput, CompanyUncheckedCreateWithoutDocumentsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDocumentsInput, CompanyUncheckedUpdateWithoutDocumentsInput>
  }

  export type CompanyUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type EquipmentUpsertWithoutDocumentsInput = {
    update: XOR<EquipmentUpdateWithoutDocumentsInput, EquipmentUncheckedUpdateWithoutDocumentsInput>
    create: XOR<EquipmentCreateWithoutDocumentsInput, EquipmentUncheckedCreateWithoutDocumentsInput>
    where?: EquipmentWhereInput
  }

  export type EquipmentUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: EquipmentWhereInput
    data: XOR<EquipmentUpdateWithoutDocumentsInput, EquipmentUncheckedUpdateWithoutDocumentsInput>
  }

  export type EquipmentUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    assignedToUser?: UserUpdateOneWithoutAssignedEquipmentsNestedInput
    company?: CompanyUpdateOneRequiredWithoutEquipmentsNestedInput
    maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type CompanyCreateWithoutLicensesInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutLicensesInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutLicensesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutLicensesInput, CompanyUncheckedCreateWithoutLicensesInput>
  }

  export type CompanyUpsertWithoutLicensesInput = {
    update: XOR<CompanyUpdateWithoutLicensesInput, CompanyUncheckedUpdateWithoutLicensesInput>
    create: XOR<CompanyCreateWithoutLicensesInput, CompanyUncheckedCreateWithoutLicensesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutLicensesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutLicensesInput, CompanyUncheckedUpdateWithoutLicensesInput>
  }

  export type CompanyUpdateWithoutLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutLicensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type NetworkCreateWithoutProviderInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUser?: UserCreateNestedOneWithoutAssignedNetworksInput
    createdBy?: UserCreateNestedOneWithoutCreatedNetworksInput
    company: CompanyCreateNestedOneWithoutNetworksInput
  }

  export type NetworkUncheckedCreateWithoutProviderInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    createdByUserId?: string | null
  }

  export type NetworkCreateOrConnectWithoutProviderInput = {
    where: NetworkWhereUniqueInput
    create: XOR<NetworkCreateWithoutProviderInput, NetworkUncheckedCreateWithoutProviderInput>
  }

  export type NetworkCreateManyProviderInputEnvelope = {
    data: NetworkCreateManyProviderInput | NetworkCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type CompanyCreateWithoutNetworkProvidersInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networks?: NetworkCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutNetworkProvidersInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networks?: NetworkUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutNetworkProvidersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutNetworkProvidersInput, CompanyUncheckedCreateWithoutNetworkProvidersInput>
  }

  export type NetworkUpsertWithWhereUniqueWithoutProviderInput = {
    where: NetworkWhereUniqueInput
    update: XOR<NetworkUpdateWithoutProviderInput, NetworkUncheckedUpdateWithoutProviderInput>
    create: XOR<NetworkCreateWithoutProviderInput, NetworkUncheckedCreateWithoutProviderInput>
  }

  export type NetworkUpdateWithWhereUniqueWithoutProviderInput = {
    where: NetworkWhereUniqueInput
    data: XOR<NetworkUpdateWithoutProviderInput, NetworkUncheckedUpdateWithoutProviderInput>
  }

  export type NetworkUpdateManyWithWhereWithoutProviderInput = {
    where: NetworkScalarWhereInput
    data: XOR<NetworkUpdateManyMutationInput, NetworkUncheckedUpdateManyWithoutProviderInput>
  }

  export type CompanyUpsertWithoutNetworkProvidersInput = {
    update: XOR<CompanyUpdateWithoutNetworkProvidersInput, CompanyUncheckedUpdateWithoutNetworkProvidersInput>
    create: XOR<CompanyCreateWithoutNetworkProvidersInput, CompanyUncheckedCreateWithoutNetworkProvidersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutNetworkProvidersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutNetworkProvidersInput, CompanyUncheckedUpdateWithoutNetworkProvidersInput>
  }

  export type CompanyUpdateWithoutNetworkProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutNetworkProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type UserCreateWithoutAssignedNetworksInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkCreateNestedManyWithoutCreatedByInput
    person?: PersonCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketCreateNestedManyWithoutSendToInput
  }

  export type UserUncheckedCreateWithoutAssignedNetworksInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyUncheckedCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput
    createdNetworks?: NetworkUncheckedCreateNestedManyWithoutCreatedByInput
    person?: PersonUncheckedCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketUncheckedCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketUncheckedCreateNestedManyWithoutSendToInput
  }

  export type UserCreateOrConnectWithoutAssignedNetworksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAssignedNetworksInput, UserUncheckedCreateWithoutAssignedNetworksInput>
  }

  export type UserCreateWithoutCreatedNetworksInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkCreateNestedManyWithoutAssignedToUserInput
    person?: PersonCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketCreateNestedManyWithoutSendToInput
  }

  export type UserUncheckedCreateWithoutCreatedNetworksInput = {
    id?: string
    username: string
    email: string
    password: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    companies?: UserCompanyUncheckedCreateNestedManyWithoutUserInput
    createdCompanies?: CompanyUncheckedCreateNestedManyWithoutCreatedByInput
    assignedEquipments?: EquipmentUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedMaintenances?: MaintenanceUncheckedCreateNestedManyWithoutAssignedToUserInput
    assignedNetworks?: NetworkUncheckedCreateNestedManyWithoutAssignedToUserInput
    person?: PersonUncheckedCreateNestedOneWithoutUserInput
    ticketsSentBy?: TicketUncheckedCreateNestedManyWithoutSendByInput
    ticketsSentTo?: TicketUncheckedCreateNestedManyWithoutSendToInput
  }

  export type UserCreateOrConnectWithoutCreatedNetworksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedNetworksInput, UserUncheckedCreateWithoutCreatedNetworksInput>
  }

  export type CompanyCreateWithoutNetworksInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: UserCreateNestedOneWithoutCreatedCompaniesInput
    departments?: DepartmentCreateNestedManyWithoutCompanyInput
    documents?: DocumentCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentCreateNestedManyWithoutCompanyInput
    licenses?: LicenseCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderCreateNestedManyWithoutCompanyInput
    tickets?: TicketCreateNestedManyWithoutCompanyInput
    users?: UserCompanyCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutNetworksInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    createdByUserId?: string | null
    departments?: DepartmentUncheckedCreateNestedManyWithoutCompanyInput
    documents?: DocumentUncheckedCreateNestedManyWithoutCompanyInput
    equipments?: EquipmentUncheckedCreateNestedManyWithoutCompanyInput
    licenses?: LicenseUncheckedCreateNestedManyWithoutCompanyInput
    maintenances?: MaintenanceUncheckedCreateNestedManyWithoutCompanyInput
    networkProviders?: NetworkProviderUncheckedCreateNestedManyWithoutCompanyInput
    tickets?: TicketUncheckedCreateNestedManyWithoutCompanyInput
    users?: UserCompanyUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutNetworksInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutNetworksInput, CompanyUncheckedCreateWithoutNetworksInput>
  }

  export type NetworkProviderCreateWithoutNetworksInput = {
    id?: string
    name: string
    providerIp?: string | null
    dnsGateway?: string | null
    speed?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meshDevices?: string | null
    switchDevices?: string | null
    company: CompanyCreateNestedOneWithoutNetworkProvidersInput
  }

  export type NetworkProviderUncheckedCreateWithoutNetworksInput = {
    id?: string
    name: string
    providerIp?: string | null
    dnsGateway?: string | null
    speed?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meshDevices?: string | null
    switchDevices?: string | null
    companyId: string
  }

  export type NetworkProviderCreateOrConnectWithoutNetworksInput = {
    where: NetworkProviderWhereUniqueInput
    create: XOR<NetworkProviderCreateWithoutNetworksInput, NetworkProviderUncheckedCreateWithoutNetworksInput>
  }

  export type UserUpsertWithoutAssignedNetworksInput = {
    update: XOR<UserUpdateWithoutAssignedNetworksInput, UserUncheckedUpdateWithoutAssignedNetworksInput>
    create: XOR<UserCreateWithoutAssignedNetworksInput, UserUncheckedCreateWithoutAssignedNetworksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAssignedNetworksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAssignedNetworksInput, UserUncheckedUpdateWithoutAssignedNetworksInput>
  }

  export type UserUpdateWithoutAssignedNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUpdateManyWithoutCreatedByNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUpdateManyWithoutSendToNestedInput
  }

  export type UserUncheckedUpdateWithoutAssignedNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput
    createdNetworks?: NetworkUncheckedUpdateManyWithoutCreatedByNestedInput
    person?: PersonUncheckedUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUncheckedUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUncheckedUpdateManyWithoutSendToNestedInput
  }

  export type UserUpsertWithoutCreatedNetworksInput = {
    update: XOR<UserUpdateWithoutCreatedNetworksInput, UserUncheckedUpdateWithoutCreatedNetworksInput>
    create: XOR<UserCreateWithoutCreatedNetworksInput, UserUncheckedCreateWithoutCreatedNetworksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedNetworksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedNetworksInput, UserUncheckedUpdateWithoutCreatedNetworksInput>
  }

  export type UserUpdateWithoutCreatedNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUpdateManyWithoutAssignedToUserNestedInput
    person?: PersonUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUpdateManyWithoutSendToNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: UserCompanyUncheckedUpdateManyWithoutUserNestedInput
    createdCompanies?: CompanyUncheckedUpdateManyWithoutCreatedByNestedInput
    assignedEquipments?: EquipmentUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedMaintenances?: MaintenanceUncheckedUpdateManyWithoutAssignedToUserNestedInput
    assignedNetworks?: NetworkUncheckedUpdateManyWithoutAssignedToUserNestedInput
    person?: PersonUncheckedUpdateOneWithoutUserNestedInput
    ticketsSentBy?: TicketUncheckedUpdateManyWithoutSendByNestedInput
    ticketsSentTo?: TicketUncheckedUpdateManyWithoutSendToNestedInput
  }

  export type CompanyUpsertWithoutNetworksInput = {
    update: XOR<CompanyUpdateWithoutNetworksInput, CompanyUncheckedUpdateWithoutNetworksInput>
    create: XOR<CompanyCreateWithoutNetworksInput, CompanyUncheckedCreateWithoutNetworksInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutNetworksInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutNetworksInput, CompanyUncheckedUpdateWithoutNetworksInput>
  }

  export type CompanyUpdateWithoutNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedCompaniesNestedInput
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type NetworkProviderUpsertWithoutNetworksInput = {
    update: XOR<NetworkProviderUpdateWithoutNetworksInput, NetworkProviderUncheckedUpdateWithoutNetworksInput>
    create: XOR<NetworkProviderCreateWithoutNetworksInput, NetworkProviderUncheckedCreateWithoutNetworksInput>
    where?: NetworkProviderWhereInput
  }

  export type NetworkProviderUpdateToOneWithWhereWithoutNetworksInput = {
    where?: NetworkProviderWhereInput
    data: XOR<NetworkProviderUpdateWithoutNetworksInput, NetworkProviderUncheckedUpdateWithoutNetworksInput>
  }

  export type NetworkProviderUpdateWithoutNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerIp?: NullableStringFieldUpdateOperationsInput | string | null
    dnsGateway?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meshDevices?: NullableStringFieldUpdateOperationsInput | string | null
    switchDevices?: NullableStringFieldUpdateOperationsInput | string | null
    company?: CompanyUpdateOneRequiredWithoutNetworkProvidersNestedInput
  }

  export type NetworkProviderUncheckedUpdateWithoutNetworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerIp?: NullableStringFieldUpdateOperationsInput | string | null
    dnsGateway?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meshDevices?: NullableStringFieldUpdateOperationsInput | string | null
    switchDevices?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonCreateWithoutAssignedExpensesInput = {
    id?: string
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
    department?: DepartmentCreateNestedOneWithoutPersonsInput
    user?: UserCreateNestedOneWithoutPersonInput
  }

  export type PersonUncheckedCreateWithoutAssignedExpensesInput = {
    id?: string
    userId?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    departmentId?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type PersonCreateOrConnectWithoutAssignedExpensesInput = {
    where: PersonWhereUniqueInput
    create: XOR<PersonCreateWithoutAssignedExpensesInput, PersonUncheckedCreateWithoutAssignedExpensesInput>
  }

  export type PersonUpsertWithWhereUniqueWithoutAssignedExpensesInput = {
    where: PersonWhereUniqueInput
    update: XOR<PersonUpdateWithoutAssignedExpensesInput, PersonUncheckedUpdateWithoutAssignedExpensesInput>
    create: XOR<PersonCreateWithoutAssignedExpensesInput, PersonUncheckedCreateWithoutAssignedExpensesInput>
  }

  export type PersonUpdateWithWhereUniqueWithoutAssignedExpensesInput = {
    where: PersonWhereUniqueInput
    data: XOR<PersonUpdateWithoutAssignedExpensesInput, PersonUncheckedUpdateWithoutAssignedExpensesInput>
  }

  export type PersonUpdateManyWithWhereWithoutAssignedExpensesInput = {
    where: PersonScalarWhereInput
    data: XOR<PersonUpdateManyMutationInput, PersonUncheckedUpdateManyWithoutAssignedExpensesInput>
  }

  export type UserCompanyCreateManyUserInput = {
    companyId: string
  }

  export type CompanyCreateManyCreatedByInput = {
    id?: string
    code?: string
    name: string
    address?: string | null
    phone?: string | null
    email?: string | null
    ruc?: string | null
    logoUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EquipmentCreateManyAssignedToUserInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    endUser?: string | null
    operatingSystem?: string | null
  }

  export type MaintenanceCreateManyAssignedToUserInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentId: string
    companyId: string
  }

  export type NetworkCreateManyAssignedToUserInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    createdByUserId?: string | null
    providerId?: string | null
  }

  export type NetworkCreateManyCreatedByInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    providerId?: string | null
  }

  export type TicketCreateManySendByInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    sendToId?: string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
  }

  export type TicketCreateManySendToInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    sendById?: string | null
    companyId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
  }

  export type UserCompanyUpdateWithoutUserInput = {
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type UserCompanyUncheckedUpdateWithoutUserInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCompanyUncheckedUpdateManyWithoutUserInput = {
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type CompanyUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    departments?: DepartmentUncheckedUpdateManyWithoutCompanyNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutCompanyNestedInput
    equipments?: EquipmentUncheckedUpdateManyWithoutCompanyNestedInput
    licenses?: LicenseUncheckedUpdateManyWithoutCompanyNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutCompanyNestedInput
    networks?: NetworkUncheckedUpdateManyWithoutCompanyNestedInput
    networkProviders?: NetworkProviderUncheckedUpdateManyWithoutCompanyNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutCompanyNestedInput
    users?: UserCompanyUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ruc?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EquipmentUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUpdateManyWithoutEquipmentNestedInput
    company?: CompanyUpdateOneRequiredWithoutEquipmentsNestedInput
    maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutEquipmentNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutMaintenancesNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutMaintenancesNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceUncheckedUpdateManyWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneWithoutCreatedNetworksNestedInput
    company?: CompanyUpdateOneRequiredWithoutNetworksNestedInput
    provider?: NetworkProviderUpdateOneWithoutNetworksNestedInput
  }

  export type NetworkUncheckedUpdateWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NetworkUncheckedUpdateManyWithoutAssignedToUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NetworkUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUser?: UserUpdateOneWithoutAssignedNetworksNestedInput
    company?: CompanyUpdateOneRequiredWithoutNetworksNestedInput
    provider?: NetworkProviderUpdateOneWithoutNetworksNestedInput
  }

  export type NetworkUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NetworkUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUpdateWithoutSendByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendTo?: UserUpdateOneWithoutTicketsSentToNestedInput
    company?: CompanyUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutSendByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendToId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketUncheckedUpdateManyWithoutSendByInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendToId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketUpdateWithoutSendToInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendBy?: UserUpdateOneWithoutTicketsSentByNestedInput
    company?: CompanyUpdateOneWithoutTicketsNestedInput
  }

  export type TicketUncheckedUpdateWithoutSendToInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendById?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketUncheckedUpdateManyWithoutSendToInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendById?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type AnnualSoftwareExpenseUpdateWithoutAssignedPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    category?: EnumSoftwareCategoryFieldUpdateOperationsInput | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    annualCost?: FloatFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    costPerUser?: FloatFieldUpdateOperationsInput | number
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: EnumPaymentFrequencyFieldUpdateOperationsInput | $Enums.PaymentFrequency
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnualSoftwareExpenseUncheckedUpdateWithoutAssignedPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    category?: EnumSoftwareCategoryFieldUpdateOperationsInput | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    annualCost?: FloatFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    costPerUser?: FloatFieldUpdateOperationsInput | number
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: EnumPaymentFrequencyFieldUpdateOperationsInput | $Enums.PaymentFrequency
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnnualSoftwareExpenseUncheckedUpdateManyWithoutAssignedPersonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    applicationName?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    category?: EnumSoftwareCategoryFieldUpdateOperationsInput | $Enums.SoftwareCategory
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    annualCost?: FloatFieldUpdateOperationsInput | number
    numberOfUsers?: IntFieldUpdateOperationsInput | number
    costPerUser?: FloatFieldUpdateOperationsInput | number
    renewalDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentFrequency?: EnumPaymentFrequencyFieldUpdateOperationsInput | $Enums.PaymentFrequency
    additionalNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateManyCompanyInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyCompanyInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentId?: string | null
  }

  export type EquipmentCreateManyCompanyInput = {
    id?: string
    type: string
    brand: string
    model: string
    serialNumber: string
    plateNumber?: string | null
    location?: string | null
    status?: $Enums.EquipmentStatus
    acquisitionDate?: Date | string | null
    warrantyDetails?: string | null
    qrCode?: string | null
    invoiceUrl?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUserId?: string | null
    endUser?: string | null
    operatingSystem?: string | null
  }

  export type LicenseCreateManyCompanyInput = {
    id?: string
    softwareName: string
    licenseKey: string
    provider?: string | null
    activationDate: Date | string
    expirationDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceCreateManyCompanyInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    equipmentId: string
    assignedToUserId?: string | null
  }

  export type NetworkCreateManyCompanyInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUserId?: string | null
    createdByUserId?: string | null
    providerId?: string | null
  }

  export type NetworkProviderCreateManyCompanyInput = {
    id?: string
    name: string
    providerIp?: string | null
    dnsGateway?: string | null
    speed?: string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    meshDevices?: string | null
    switchDevices?: string | null
  }

  export type TicketCreateManyCompanyInput = {
    id?: string
    ticketNumber?: number | null
    title: string
    description: string
    img?: string | null
    comment?: string | null
    type: $Enums.TicketType
    priority: $Enums.TicketPriority
    status: $Enums.TicketStatus
    startDate?: Date | string | null
    endDate?: Date | string | null
    requestDays?: number | null
    approvedDays?: number | null
    view?: boolean | null
    sendById?: string | null
    sendToId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewed?: boolean | null
  }

  export type UserCompanyCreateManyCompanyInput = {
    userId: string
  }

  export type DepartmentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    persons?: PersonUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    persons?: PersonUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipment?: EquipmentUpdateOneWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EquipmentUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUpdateManyWithoutEquipmentNestedInput
    assignedToUser?: UserUpdateOneWithoutAssignedEquipmentsNestedInput
    maintenances?: MaintenanceUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
    documents?: DocumentUncheckedUpdateManyWithoutEquipmentNestedInput
    maintenances?: MaintenanceUncheckedUpdateManyWithoutEquipmentNestedInput
  }

  export type EquipmentUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    serialNumber?: StringFieldUpdateOperationsInput | string
    plateNumber?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumEquipmentStatusFieldUpdateOperationsInput | $Enums.EquipmentStatus
    acquisitionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    warrantyDetails?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    invoiceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    operatingSystem?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LicenseUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LicenseUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    softwareName?: StringFieldUpdateOperationsInput | string
    licenseKey?: StringFieldUpdateOperationsInput | string
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    activationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expirationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUser?: UserUpdateOneWithoutAssignedMaintenancesNestedInput
    equipment?: EquipmentUpdateOneRequiredWithoutMaintenancesNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MaintenanceUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    equipmentId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NetworkUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUser?: UserUpdateOneWithoutAssignedNetworksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedNetworksNestedInput
    provider?: NetworkProviderUpdateOneWithoutNetworksNestedInput
  }

  export type NetworkUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NetworkUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NetworkProviderUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerIp?: NullableStringFieldUpdateOperationsInput | string | null
    dnsGateway?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meshDevices?: NullableStringFieldUpdateOperationsInput | string | null
    switchDevices?: NullableStringFieldUpdateOperationsInput | string | null
    networks?: NetworkUpdateManyWithoutProviderNestedInput
  }

  export type NetworkProviderUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerIp?: NullableStringFieldUpdateOperationsInput | string | null
    dnsGateway?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meshDevices?: NullableStringFieldUpdateOperationsInput | string | null
    switchDevices?: NullableStringFieldUpdateOperationsInput | string | null
    networks?: NetworkUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type NetworkProviderUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    providerIp?: NullableStringFieldUpdateOperationsInput | string | null
    dnsGateway?: NullableStringFieldUpdateOperationsInput | string | null
    speed?: NullableStringFieldUpdateOperationsInput | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    meshDevices?: NullableStringFieldUpdateOperationsInput | string | null
    switchDevices?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendBy?: UserUpdateOneWithoutTicketsSentByNestedInput
    sendTo?: UserUpdateOneWithoutTicketsSentToNestedInput
  }

  export type TicketUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendById?: NullableStringFieldUpdateOperationsInput | string | null
    sendToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type TicketUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketNumber?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    img?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTicketTypeFieldUpdateOperationsInput | $Enums.TicketType
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestDays?: NullableIntFieldUpdateOperationsInput | number | null
    approvedDays?: NullableIntFieldUpdateOperationsInput | number | null
    view?: NullableBoolFieldUpdateOperationsInput | boolean | null
    sendById?: NullableStringFieldUpdateOperationsInput | string | null
    sendToId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewed?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type UserCompanyUpdateWithoutCompanyInput = {
    user?: UserUpdateOneRequiredWithoutCompaniesNestedInput
  }

  export type UserCompanyUncheckedUpdateWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserCompanyUncheckedUpdateManyWithoutCompanyInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type PersonCreateManyDepartmentInput = {
    id?: string
    userId?: string | null
    firstName?: string | null
    lastName?: string | null
    fullName?: string | null
    contactEmail?: string | null
    phoneNumber?: string | null
    position?: string | null
    status?: $Enums.PersonStatus
    userCode: string
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId?: string | null
  }

  export type PersonUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutPersonNestedInput
    assignedExpenses?: AnnualSoftwareExpenseUpdateManyWithoutAssignedPersonsNestedInput
  }

  export type PersonUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedExpenses?: AnnualSoftwareExpenseUncheckedUpdateManyWithoutAssignedPersonsNestedInput
  }

  export type PersonUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyEquipmentInput = {
    id?: string
    title: string
    description?: string | null
    fileUrl: string
    fileType?: string | null
    category?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
  }

  export type MaintenanceCreateManyEquipmentInput = {
    id?: string
    title: string
    description?: string | null
    type: $Enums.MaintenanceType
    status?: $Enums.MaintenanceStatus
    scheduledDate: Date | string
    completionDate?: Date | string | null
    cost?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedToUserId?: string | null
    companyId: string
  }

  export type DocumentUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUser?: UserUpdateOneWithoutAssignedMaintenancesNestedInput
    company?: CompanyUpdateOneRequiredWithoutMaintenancesNestedInput
  }

  export type MaintenanceUncheckedUpdateWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceUncheckedUpdateManyWithoutEquipmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumMaintenanceTypeFieldUpdateOperationsInput | $Enums.MaintenanceType
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    scheduledDate?: DateTimeFieldUpdateOperationsInput | Date | string
    completionDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    companyId?: StringFieldUpdateOperationsInput | string
  }

  export type NetworkCreateManyProviderInput = {
    id?: string
    name: string
    status?: $Enums.NetworkDeviceStatus
    location?: string | null
    description?: string | null
    notes?: string | null
    ssid?: string | null
    password?: string | null
    ip?: string | null
    dns?: string | null
    gw?: string | null
    uploadSpeed?: string | null
    downloadSpeed?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    companyId: string
    assignedToUserId?: string | null
    createdByUserId?: string | null
  }

  export type NetworkUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedToUser?: UserUpdateOneWithoutAssignedNetworksNestedInput
    createdBy?: UserUpdateOneWithoutCreatedNetworksNestedInput
    company?: CompanyUpdateOneRequiredWithoutNetworksNestedInput
  }

  export type NetworkUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NetworkUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumNetworkDeviceStatusFieldUpdateOperationsInput | $Enums.NetworkDeviceStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    ssid?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    dns?: NullableStringFieldUpdateOperationsInput | string | null
    gw?: NullableStringFieldUpdateOperationsInput | string | null
    uploadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    downloadSpeed?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: StringFieldUpdateOperationsInput | string
    assignedToUserId?: NullableStringFieldUpdateOperationsInput | string | null
    createdByUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUpdateWithoutAssignedExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
    department?: DepartmentUpdateOneWithoutPersonsNestedInput
    user?: UserUpdateOneWithoutPersonNestedInput
  }

  export type PersonUncheckedUpdateWithoutAssignedExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonUncheckedUpdateManyWithoutAssignedExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    contactEmail?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPersonStatusFieldUpdateOperationsInput | $Enums.PersonStatus
    userCode?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    companyId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}